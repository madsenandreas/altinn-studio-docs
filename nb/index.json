[
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/data-models-tool/",
	"title": "Altinn Studio Datamodellering",
	"tags": ["translate-to-english"],
	"description": "Brukerguide for verktøyet Altinn Studio Datamodellering",
	"content": "Datamodelleringsfunksjonalitet utvikles nå i Altinn Studio. Funksjonalitet vil være begrenset, men vil bygges på fortløpende.\rAltinn Studio Datamodellering er et verktøy for å utvikle datamodeller. Den baserer seg på en datamodell i JSONSchema format, og kan ut fra dette generere XSD- og C#-modell.\nNavigere til Altinn Studio Datamodellering Logg inn i Altinn Studio På førstesiden, velg rediger (blått penn-ikon) på enten: a. En app, eller b. Datamodellerings repo for din organisasjon Velg Datamodell fanen i topp-menyen Når man kommer til den nye siden for datamodellering vises en dialog med informasjon om den nye siden. Om man ikke ønsker å se denne hver gang man går inn på siden kan man velge Ikke vis igjen. Da vil dialogen skjules så lenge man bruker samme PC og nettleser - frem til det ev. kommer endringer vi ønsker å varsle om.\nLaste opp / vise datamodell Datamodellen definerer hvilke data som kan sendes inn via en app, og hvilket format det skal sendes på. Vi støtter pr. nå kun opplasting av XSD datamodell.\nKlikk på Last opp datamodell - enten fra startsiden om det ikke er noen eksisterende datamodeller, eller fra verktøylinjen øverst i verktøyet og velg XSD-en i filvelgeren Klikk Last opp Datamodellen blir da lastet opp og prosessert, og alle nødvendige filer generert og lagret i app-repositoryet. Tre-visning av datamodellen kan åpnes for å se en visuell representasjon av datamodellen.\nVelge modell fra nedtrekkslisten Alle modeller som er lastet opp i verktøyet for en app eller \u0026lt;org\u0026gt;-datamodels repo er tilgjengelig i listen. XSD\u0026rsquo;er som ligger i repo som ikke har noen tilknyttede modell-filer (JSONSchema) vil også vises i listen, se neste avsnitt for mer info.\nSpesielt for datamodellering på organisasjonsnivå Når man jobber mot et datamodell-repo på organisasjonsnivå (i stedet for direkte mot en app), er det 2 grupper med datamodeller som vises i nedtrekkslisten.\nDen første er JSONSchema - dette er modellene der man har hentet inn/lastet opp XSD i verktøyet og prosessert denne, og fått generert modell-filene. Den andre er XSD - dette er de XSD\u0026rsquo;ene som ligger i \u0026lt;org\u0026gt;-datamodels repo som ikke har blitt hentet inn og prosessert i verktøyet. Når man velger en modell fra XSD-listen, vil denne automatisk lastes inn i verktøyet og JSONSchema modell-fil genereres - denne kan så jobbes videre med i ASD. Lage ny datamodell Det er mulig å opprette en ny datamodell fra bunnen av:\nKlikk på Lag ny datamodell. Skriv inn navnet på datamodellen i feltet. Klikk på Opprett modell. Datamodellen opprettes med utgangspunkt:\nEn rot-node med referanse til en type Typen får samme navn som navnet man har gitt modellen, og vises som en klikkbar boks på noden. Den inneholder et enkelt tekst-felt e1. Dette kan gis nytt navn, type, osv, eller slettes. For å redigere denne modellen, kan man gå til typen ved å klikke på den, eller ved å velge Typer-fanen og klikke på typen i listen. Her kan man legge til/redigere felter via kontekst-menyen på noden, eller legge til nye typer via Legg til element øverst. For mer info om redigering av modeller, se avsnitt om redigering av modeller.\nRedigere datamodell Funksjonalitet for å redigere datamodell er under utvikling. Denne funksjonaliteten vil være begrenset, men bygges på fortløpende.\rFor å redigere en datamodell må modellen være valgt i nedtrekkslisten. I tillegg må man velge Rediger øverst til høyre i modellverktøyet - da vil et panel for å redigere modellen vises på høyre side av verktøyet. Valget her vil huskes til neste gang man er inne.\nModellen lagres automatisk mens man jobber med den. For å generere opp modell-filer som XSD (og C#-fil for apper) må man trykke på Generer modeller-knappen øverst til høyre.\rMerk at dersom man ønsker å endre en pre-definert type, må dette gjøres fra Typer-fanen. Dersom man ikke har definert noen gjenbrukbar type for et felt eller gruppe, kan det redigeres direkte fra Modell-fanen.\nRedigere navn på felt Klikk på feltet, og se at navnet på feltet vises i høyre-panelet. Endre navn til ønsket verdi. Navnet oppdateres. Legge til nytt felt Hold musepekeren over noden du ønsker å legge til et felt på. Klikk på de tre prikkene til høyre for noden. Velg Legg til felt fra menyen. Feltet blir lagt til. Legge til en referanse til en type Hold musepekeren over noden du ønsker å legge til et felt på. Klikk på de tre prikkene til høyre for noden. Velg Legg til referanse fra menyen. Feltet blir lagt til Velg type i Refererer til feltet i høyre-panelet Slette et felt Hold musepekeren over noden du ønsker å slette. Klikk på de tre prikkene til høyre for noden. Velg Slett felt fra menyen. Feltet blir slettet. Redigere egenskaper til et felt Klikk på noden/feltet du ønsker å redigere for å få opp egenskaper i høyre-panelet Rediger egenskapene for noden/feltet som ønsket. Tilgjengelige egenskaper for feltet vil variere basert på base-typen for feltet. Redigere/legge til XSD-attributter, namespaces, osv, inkl dataFormatId og dataFormatVersion`. Foreløpig er ikke dette noe som støttes direkte i verktøyet. Det er allikevel mulig å gjøre dette manuelt. Beskrivelser for hvordan dette gjores finnes i lenkene under:\ndataFormatId og dataFormatVersion XSD attributter generelt XSD namespaces Generere modellfiler (XSD og C#) Når modellen er klar, kan man generere modell-filer ved å klikke på Generer modeller-knappen over høyre-panelet. For \u0026lt;org\u0026gt;-datamodels-repo vil det kun genereres XSD, mens for app-repo vil det også genereres C# modell-fil. Husk å trykke på Push til venstre i hovedmenyen til Altinn Studio for å dele dine endringer.\nLaste ned XSD XSD fil kan så lastes ned ved å gå til repoet - klikk på person-ikonet øverst til høyre på siden, og velg \u0026ldquo;Åpne repository\u0026rdquo;. Naviger til ønsker fil i mappestrukturen, og klikk på nedlastingsikonet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/insight/",
	"title": "Innsiktsfase",
	"tags": [],
	"description": "Først av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?",
	"content": "Tenk gjennom Hva er dagens utfordring? Start med å definere problemet. Hva er det dere skal løse? Med et klart avgrenset problem er det lettere å lage en klar løsning. Her kan det være en idé å samle prosjektgruppen, komme vekk fra møtebordet og bruke post-its på veggene. Hvem er brukerne og hvilke behov har de? Vi anbefaler at dere starter med å definere målgruppe og brukerbehov så tidlig som mulig i prosjektet. Lag en oversikt over hvem brukerne er. I de fleste tilfellene skal man lage løsninger som fungerer for flere brukergrupper. Er det innbyggere eller aktører i næringslivet? Hvilken bakgrunn har de? Er de digitale eller ikke så vant til å bruke digitale tjenester? I denne fasen gjøres det typisk innledende innsiktsarbeid i form av intervjuer, observasjoner eller fokusgruppe. Kontaktpunkter for brukeren Sett opp en oversikt/brukerreise over brukerens kontaktpunkt. Eksempel på hvordan en fragmentert brukerreise kan fortone seg: Skal Altinn være skjult for sluttbruker eller er det Altinns grensesnitt som skal benyttes? Stemmer dette med hvordan brukeren forventer å få løst sin oppgave? Er det mulig å tilby brukerne den relevante delen av altinn i den konteksten de er i, i stedet for å sende dem frem og tilbake? Hva er databehovet? Behovet for en digital løsning starter gjerne med at det er behov for å samle inn data. Start med å undersøke om andre har dataene du trenger og om disse er tilgjengelige for gjenbruk. Det kan du sjekke i Felles datakatalog. Hvis ikke - hvordan kan du spørre på en måte som krever minst mulig av brukerne? Noen ganger kan det være en idé å prøve noe annet enn opplagte løsninger hvor man spør i form av et skjema. Når du har kommet deg gjennom innsiktsfasen og definert brukerbehov, anbefaler vi at du setter sammen en prototype som kan brukertestes på relevante brukere. Dersom du skal lage et skjema, kan du bruke vårt prototype-Kit for Figma.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/",
	"title": "Om Altinn 3",
	"tags": [],
	"description": "Altinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.",
	"content": "Plattformen er eid av Digitaliseringsdirektoratet og utviklet som en åpen kildekode-plattform.\nDen nåværende løsningen og plattformen (Altinn II - lansert i 2010) regnes av Gartner som en av verdens fem ledende plattformer for digitale myndigheter.\nPlattformen brukes av over 90 % av den norske befolknigen og nær 100 % av alle virksomheter Mer enn 62 etater, fylkeskommuner og kommuner bruker Altinn som platform for sine tjenester.\nDet finnes nær 1000 aktive tjenester på plattformen som dekker ulike bruksscenarier.\nEksempler på slike tjenester er skattemeldingen, rapportering av ulykker i luftfarten, meldinger fra forsvaret, oppslag mot data i Brønnøysundregistrene og mye, mye mer.\nKonsept Ved å bruke Altinn 3 kan etater og andre myndighetsutøvere bygge tjenester som fullverdige applikasjoner og produksjonssette dem som containere til deres isolerte infrastruktur i skyen. Altinn Platform gir appene kjernefunksjonalitet som lagring, autorisasjon, autentisering, tilgang på registerdatam med mer.\nInfrastrukturen er svært skalerbar for å støtte de ulike behovene tjenesteeierne har, og forvaltes av DevOps-teamet hos Altinn.\nApplikasjons-templaten som følger med Altinn Studio er gjort klar for de vanligste typene digitale tjenester, noe som gjør det mulig å lage og publisere de enkleste tjenestene i løpet av timer.\nNår applikasjonen er produksjonssatt til Altinn Apps er den tilgjengelig for så godt som alle privatpersoner og virksomheter i Norge.\nHvorfor Altinn 3? Det er mange grunner til å bruke Altinn 3 til å bygge og kjøre dine digitale tjenester.\nApplikasjons-template som har innebygd funksjonalitet for de vanligste bruksområdene for digitale tjenester Lett å utvikle og kjøre applikasjoner Gjenbruk av data, brukergrensesnitt, APIer og funksjonalitet En kjent plattform for sluttbrukerne Svært skalerbar og sikker infrastruktur Åpen kildekode Tilgang til så godt som alle privatpersoner og virksomheter i Norge Når ble Altinn 3 lansert? Første versjon av Altinn 3 kom i juni 2020, og de første applikasjonene på løsningen ble satt i produksjon 19. juni 2020.\nHvordan lære mer om Altinn 3 Begynn gjerne med å lese om de ulike delløsningene i Altinn 3.\nAltinn Studio lar deg bygge dine digitale tjenester Altinn Apps lar deg kjøre dine digitale tjenester Altinn Platform gir deg standardfunksjonalitet til bruk i dine digitale tjenester Altinn og åpen kildekode\rAltinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.\nMål\rOppsummering av målene for Altinn 3.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/setup/",
	"title": "Oppsett for gruppering av felter",
	"tags": [],
	"description": "Generelt oppsett for gruppering av felter i skjema.",
	"content": "Felter i skjema kan settes opp til å bli del av en gruppe. Dette kan brukes til å f.eks. sette opp dynamikk på en enkelt gruppe av felter, i stedet for på hvert enkelt felt. I tillegg må felter kunnne grupperes for å støtte repeterende grupper i skjema.\nEn gruppe settes opp i FormLayout.json, sammen med de andre komponentene i skjemaet. Dette kan enten gjøres manuelt direkte i filen, eller via skjemaeditor i Atinn Studio ved å bruke Gruppe-komponenten.\nNoen punkter å notere seg ved manuelt oppsett:\nGruppen må ligge før ev. komponenter som skal inngå i gruppen i FormLayout.json. En gruppe MÅ ha type: \u0026quot;group\u0026quot; satt for at den skal registreres som en gruppe Eksempel på en (repeterende) gruppe definert i FormLayout.json som inneholder 4 felter som kan repetere 3 ganger: En gruppe defineres på følgende måte i FormLayout.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;unik-id\u0026gt;\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;group\u0026#34;, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;\u0026lt;gruppen i datamodellen (kun repeterende grupper)\u0026gt;\u0026#34; }, \u0026#34;maxCount\u0026#34;: \u0026#34;\u0026lt;Antall ganger gruppen kan repetere\u0026gt;\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34;, \u0026#34;osv...\u0026#34; ], \u0026#34;tableHeaders\u0026#34;: [ \u0026#34;\u0026lt;felt-id\u0026gt;\u0026#34; ], \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;add_button\u0026#34;: \u0026#34;tekstressurs.felt\u0026#34; } } Parameter Påkrevd Beskrivelse id Ja Unik ID, tilsvarer ID på andre komponenter. Må være unik i FormLayout.json-filen. type Ja MÅ være \u0026ldquo;group\u0026rdquo;. Sier at dette er en gruppe. dataModelBindings Nei MÅ være satt for repeterende grupper, med group-parameteren som i eksempelet over. Skal peke på den repeterende gruppen i datamodellen. textResourceBindings Nei Kan være satt for repeterende grupper, se beskrivelse. maxCount Ja Antall ganger en gruppe kan repetere. Settes til 1 om gruppen ikke er repeterende. children Ja Liste over de feltene som skal inngå i gruppen. Her brukes felt-id fra FormLayout.json tableHeaders Nei Liste over komponentener som skal inngå som en del av tabbel header feltene. Om ikke spesifisert så vises alle komponentene. textResourceBindings Det er mulig å legge til ulike nøkler i textResourceBindings for å overstyre default tekster.\nadd_button - blir lagt til på enden av \u0026ldquo;Legg til ny\u0026rdquo; teksten på knappen, og kan brukes til å f.eks ha tekst som sier \u0026ldquo;Legg til ny person\u0026rdquo;. save_button - blir brukt som tekst i \u0026ldquo;Lagre\u0026rdquo;-knappen når brukeren fyller ut data. save_and_next_button - blir brukt som tekst i \u0026ldquo;Lagre og åpne neste\u0026rdquo;-knappen dersom denne er aktivert. edit_button_open - blir brukt som tekst i \u0026ldquo;Endre\u0026rdquo; knappen i tabellen når brukeren skal åpne et element. edit_button_close - blir brukt som tekst i \u0026ldquo;Endre\u0026rdquo; knappen tabellen når brukeren skal lukke et element. Separat ledetekst for tabellvisning Elementer i repeterende grupper som ikke er i redigeringsmodus vises som en tabell. I denne tabellvisningen er det begrenset plass til lange ledetekster. En kortere ledetekst for tabellvisninger kan settes ved å definere tableTitle under textResourceBindings for hver komponent i en repeterende gruppe.\nEksempel:\n{ ... \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Skriv inn ditt fulle navn\u0026#34;, \u0026#34;tableTitle\u0026#34;: \u0026#34;Navn\u0026#34; }, ... }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/repeating/",
	"title": "Repeterende grupper",
	"tags": [],
	"description": "Oppsett for repeterende grupper.",
	"content": "Grupper i datamodellen inneholder ett eller flere felter. Grupper er definert som repeterende dersom de har maxOccurs \u0026gt; 1 i xsd\u0026rsquo;en. En gruppe som er repeterende i datamodellen må også settes opp som repeterende i skjemaet, ellers vil lagring av data feile.\nEksempel Skjema med noen enkelt-felt, og en repeterende gruppe som:\ninneholder 3 felter kan repeteres opp til 3 ganger Oppsett i FormLayout.json fra eksempelet over:\n1{ 2 \u0026#34;data\u0026#34;: { 3 \u0026#34;layout\u0026#34;: [ 4 { 5 \u0026#34;id\u0026#34;: \u0026#34;gruppe-1\u0026#34;, 6 \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, 7 \u0026#34;children\u0026#34;: [ 8 \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 9 \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34; 10 ], 11 \u0026#34;maxCount\u0026#34;: 3, 12 \u0026#34;dataModelBindings\u0026#34;: { 13 \u0026#34;group\u0026#34;: \u0026#34;spesifisering-grp-5836\u0026#34; 14 }, 15 \u0026#34;textResourceBindings\u0026#34;: { 16 \u0026#34;header\u0026#34;: \u0026#34;person\u0026#34; 17 } 18 }, 19 { 20 \u0026#34;id\u0026#34;: \u0026#34;ac555386-ac2b-47a0-bb1b-842f8612eddb\u0026#34;, 21 \u0026#34;type\u0026#34;: \u0026#34;Checkboxes\u0026#34;, 22 \u0026#34;componentType\u0026#34;: 5, 23 \u0026#34;textResourceBindings\u0026#34;: { 24 \u0026#34;title\u0026#34;: \u0026#34;Avkrysningsboks\u0026#34; 25 }, 26 \u0026#34;dataModelBindings\u0026#34;: { 27 \u0026#34;simpleBinding\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifisering-datadef-25457.value\u0026#34; 28 }, 29 \u0026#34;options\u0026#34;: [ 30 { 31 \u0026#34;label\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34;, 32 \u0026#34;value\u0026#34;: \u0026#34;Verdi1\u0026#34; 33 }, 34 { 35 \u0026#34;label\u0026#34;: \u0026#34;25796.OppgavegiverAdressePreutfyltdatadef25796.Label\u0026#34;, 36 \u0026#34;value\u0026#34;: \u0026#34;Verdi2\u0026#34; 37 } 38 ], 39 \u0026#34;required\u0026#34;: true 40 }, 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;5c079cd4-c80c-44ea-b8b8-18e323267a37\u0026#34;, 43 \u0026#34;type\u0026#34;: \u0026#34;AddressComponent\u0026#34;, 44 \u0026#34;componentType\u0026#34;: 11, 45 \u0026#34;textResourceBindings\u0026#34;: { 46 \u0026#34;title\u0026#34;: \u0026#34;Adresse\u0026#34; 47 }, 48 \u0026#34;dataModelBindings\u0026#34;: { 49 \u0026#34;address\u0026#34;: \u0026#34;klage-grp-5805.spesifisering-grp-5836.KlageSpesifiseringg-datadef-12345.value\u0026#34; 50 }, 51 \u0026#34;simplified\u0026#34;: true, 52 \u0026#34;readOnly\u0026#34;: false, 53 \u0026#34;required\u0026#34;: true 54 } 55 ] 56 } 57} Vedlegg i repeterende grupper Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre.\rFor å sette opp filopplastingskomponenter i repeterende grupper kreves det noe ekstra oppsett.\nNår man laster opp vedlegg kan det bli vanskelig å skille hvilket vedlegg som hører til hvilken rad i den repeterende gruppen, og dermed hvilken utfyllt informasjon som hører til hvert enkelt vedlegg. Derfor må man sette opp knytninger mot datamodellen når filopplasting blir brukt i repeterende grupper, slik at Altinn kan fylle inn den unike identifikatoren som hører til hvert vedlegg og sende dette med resten av dataene i instansen.\nMuligheten til å plassere en referanse til vedlegget i datamodellen kan også brukes utenfor repeterende grupper om man ønsker en referanse til vedlegg sammen med skjemadataene på mottakersiden.\nFølgende er et eksempel på en datamodell som forventer en referanse til et opplastet vedlegg:\n\u0026lt;xsd:schema xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; elementFormDefault=\u0026#34;qualified\u0026#34; attributeFormDefault=\u0026#34;unqualified\u0026#34;\u0026gt; \u0026lt;xsd:element name=\u0026#34;FamilieMedlemmer\u0026#34; type=\u0026#34;Skjema\u0026#34; /\u0026gt; \u0026lt;xsd:complexType name=\u0026#34;Skjema\u0026#34;\u0026gt; \u0026lt;xsd:sequence\u0026gt; \u0026lt;xsd:element name=\u0026#34;FamilieMedlem\u0026#34; type=\u0026#34;FamilieMedlem\u0026#34; maxOccurs=\u0026#34;99\u0026#34; /\u0026gt; \u0026lt;/xsd:sequence\u0026gt; \u0026lt;xsd:anyAttribute /\u0026gt; \u0026lt;/xsd:complexType\u0026gt; \u0026lt;xsd:complexType name=\u0026#34;FamilieMedlem\u0026#34;\u0026gt; \u0026lt;xsd:sequence\u0026gt; \u0026lt;xsd:element name=\u0026#34;Fornavn\u0026#34; type=\u0026#34;xsd:string\u0026#34; /\u0026gt; \u0026lt;xsd:element name=\u0026#34;Bilde\u0026#34; type=\u0026#34;xsd:string\u0026#34; /\u0026gt; \u0026lt;/xsd:sequence\u0026gt; \u0026lt;/xsd:complexType\u0026gt; \u0026lt;/xsd:schema\u0026gt; Dette knyttes til vedleggskomponenten i gruppen:\n{ \u0026#34;id\u0026#34;: \u0026#34;bilde\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;FileUpload\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Bilde\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;FamilieMedlem.Bilde\u0026#34; }, \u0026#34;maxFileSizeInMB\u0026#34;: 25, \u0026#34;maxNumberOfAttachments\u0026#34;: 1, \u0026#34;minNumberOfAttachments\u0026#34;: 1, \u0026#34;displayMode\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;required\u0026#34;: true } I tilfeller hvor man tillater opplasting av flere filer i samme vedleggskomponent må man benytte en datamodellknytning av typen list:\n\u0026lt;xsd:complexType name=\u0026#34;FamilieMedlem\u0026#34;\u0026gt; \u0026lt;xsd:sequence\u0026gt; \u0026lt;xsd:element name=\u0026#34;Fornavn\u0026#34; type=\u0026#34;xsd:string\u0026#34; /\u0026gt; \u0026lt;xsd:element name=\u0026#34;Bilder\u0026#34; type=\u0026#34;xsd:string\u0026#34; maxOccurs=\u0026#34;5\u0026#34; /\u0026gt; \u0026lt;/xsd:sequence\u0026gt; \u0026lt;/xsd:complexType\u0026gt; { [...] \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;list\u0026#34;: \u0026#34;FamilieMedlem.Bilder\u0026#34; } } Mottakersiden vil da få en liste med flere unike IDer, en for hvert vedlegg.\nSamme unike ID vil også vises i PDF-kvitteringen - men det enbefales å skjule dette ettersom vedlegg vises separat på kvitteringssiden og den unike IDen kan bli forvirrende for brukerne.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/alternatives/",
	"title": "Innstillinger",
	"tags": [],
	"description": "Innstillinger for visning.",
	"content": "Det er implementert en ny (valgfri) parameter som kan legges inn på definisjonen av en repeterende gruppe i layout-filen, som gjør at man kan styre litt rundt visningen og oppførselen til gruppen på siden. I tillegg er det lagt til støtte for flere \u0026ldquo;sider\u0026rdquo; inne i redigerings-flaten til gruppen.\nStyre visning Det er lagt til en ny parameter, edit, som kan settes på en gruppe-komponent (repeterende gruppe). Denne lar oss definere forskjellige innstillinger mtp visning av et gruppe-element under redigering/utfylling. Følgende innstillinger kan settes.\nmode Definerer om tabellen (som viser alle elementene i gruppen) skal vises når et element er åpent i redigerings-modus. Følgende verdier godtas:\nVerdi Beskrivelse \u0026ldquo;showTable\u0026rdquo; Standard oppførsel om ingenting er satt. Viser tabellen over flaten for redigering av gruppe-element. \u0026ldquo;hideTable\u0026rdquo; Skjuler tabellen når et gruppe-element er åpent for redigering. \u0026ldquo;showAll\u0026rdquo; Skjuler tabellen. Viser alle elementene i gruppen i redigerings-modus, under hverandre. Lagre-knapp skjules. \u0026ldquo;likert\u0026rdquo; Likert visning. filter Støtte for å filtrere elementene i gruppen, slik at kun de elementene som matcher de definerte kriteriene vises. F.eks. i en gruppe som viser arbeidserfaring, vis kun de elementene der arbeidssted var Oslo. Liste med kriterier er basert på verdi av ett eller flere felter i gruppen, på formen\n\u0026#34;edit\u0026#34;: { \u0026#34;filter\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;felt i datamodell\u0026gt;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026lt;ønsket verdi\u0026gt;\u0026#34; } ] } Dersom det er flere kriterier, må alle matche for at elementet skal vises.\nOm det kun er ett resultat, vises dette automatsk i redigerings-modus. Om det er flere elementer i gruppen som matcher filteret, vil disse vises. Andre elementer i gruppen skjules. filter kan kombineres med mode-parameter.\nOm man kombinerer \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot; med \u0026quot;filter\u0026quot;, vil det ikke fungere å legge til nye elementer i gruppen. Dette er fordi man med \u0026ldquo;showAll\u0026rdquo; kun viser redigerings-flaten, og så lenge filteret ikke matcher, vil ikke elementet vises.\raddButton Bestemmer om \u0026ldquo;Legg til ny\u0026rdquo;-knappen vises under tabellen. Nyttig å skjule denne om man kun ønsker å presentere data.\nsaveButton Bestemmer om \u0026ldquo;Lagre\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Lagre\u0026rdquo;-knapp vises. Dersom man har satt \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot; skjules Lagre-knappen alltid, da man i denne modusen ikke har mulighet til å lukke redigerings-flaten for gruppe-elementet. Dataene lagres uansett.\ndeleteButton Bestemmer om \u0026ldquo;Slett\u0026rdquo;-knappen vises når et gruppeelement er i redigeringsmodus. Standard oppførsel om parameteren ikke er satt er at \u0026ldquo;Slett\u0026rdquo;-knapp vises.\nmultiPage Sier at redigering/utfylling av gruppe kan gjøres over flere \u0026ldquo;sider\u0026rdquo;/visninger. Krever mer oppsett for å fungere, se under for mer informasjon.\nopenByDefault Sier at gruppen skal åpnes i redigeringsmodus til å begynne med. Følgende verdier godtas:\nValue Description \u0026ldquo;first\u0026rdquo; Dersom det finnes preutfylte elementer eller eksisterende data i gruppen vil det første elementet åpnes i redigeringsmodus til å begynne med. Dersom det ikke finnes noen elementer i gruppen fra før av, vil et nytt element legges til og åpnes i redigeringsmodus. \u0026ldquo;last\u0026rdquo; Dersom det finnes preutfylte elementer eller eksisterende data i gruppen vil det siste elementet åpnes i redigeringsmodus til å begynne med. Dersom det ikke finnes noen elementer i gruppen fra før av, vil et nytt element legges til og åpnes i redigeringsmodus. true Dersom det ikke finnes noen preutfylte elementer eller eksisterende data i gruppen fra før av, vil et nytt element legges til og åpnes i redigeringsmodus. false Ingen elementer åpnes til å begynne med. Merk at denne ikke har noen effekt om den brukes sammen med \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot;.\nEksempel:\n{ ... \u0026#34;edit\u0026#34;: { \u0026#34;openByDefault\u0026#34;: \u0026#34;first\u0026#34; } } saveAndNextButton Bestemmer om \u0026ldquo;Lagre og åpne neste\u0026rdquo;-knappen skal vises når et gruppeelement er i redigeringsmodus. Standard oppførsel dersom parameteren ikke er satt er at knappen ikke vises.\nMerk at denne ikke har noen effekt om den brukes sammen med \u0026quot;mode\u0026quot;: \u0026quot;showAll\u0026quot;.\nalertOnDelete Bestemmer om det skal vises et varslingspanel når brukeren trykker på \u0026ldquo;Slett\u0026rdquo; knappen. En potensiell situasjon hvor dette kan være ønskelig er hvis en rad inneholder store mengder data. Standard oppførsel om parameteren ikke er satt er at varslingspanelet ikke vises.\nEksempel:\n{ ... \u0026#34;edit\u0026#34;: { \u0026#34;alertOnDelete\u0026#34;: true } } Vise gruppen som del av Panel Det er lagt til en ny parameter, panel, som kan settes på en gruppe-komponent. Denne sier at gruppen skal vises som en del av Panel-komponenten.\nHer vil du kjenne igjen utseende og innstillinger som kan settes på panel-komponenten. Eksempeloppsett:\n{ \u0026#34;id\u0026#34;: \u0026#34;input-panel-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;panel-1\u0026#34;, \u0026#34;panel-2\u0026#34; ], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Dette er bare en demo av input panel utenfor repeterende gruppe.\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Her ser jeg bare at ting fungerer som forventet.\u0026#34; }, \u0026#34;panel\u0026#34;: { \u0026#34;variant\u0026#34;: \u0026#34;info\u0026#34; } }, Her har man satt opp gruppen til å vises som panel med variant \u0026ldquo;info\u0026rdquo;. Oppsettet er ellers helt likt som en vanlig gruppe.\nDette vil gi følgende output:\nDet er mulig å konfigurere følgende settings i panel feltet på en gruppe:\nParameter Påkrevd Beskrivelse variant Ja Hvilken variant av panel gruppen skal ligge i. Tilgjengelige verdier er \u0026ldquo;info\u0026rdquo;, \u0026ldquo;success\u0026rdquo; og \u0026ldquo;warning\u0026rdquo; iconUrl Nei Om man ønsker eget ikon som del av panel kan dette settes. Relativ eller full path, f.eks \u0026ldquo;awesomeIcon.png\u0026rdquo; eller \u0026ldquo;http://cdn.example.com/awesomeIcon.png\u0026quot; iconAlt Nei Alternativ tekst til custom icon. Kan kun settes om iconUrl er satt. Kan være ren tekst eller en refereanse til en tekstressurs. groupReference Nei Referanse til en annen gruppe. Kan benyttes om man ønsker legge til elementer i en repeterende gruppe fra en annen kontest. Les mer. Eksempel:\n\u0026#34;panel\u0026#34;: { \u0026#34;variant\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;iconUrl\u0026#34;: \u0026#34;kort.svg\u0026#34;, \u0026#34;iconAlt\u0026#34;: \u0026#34;Betalingskort ikon\u0026#34; } Legge til element fra en annen repeterende gruppe Et use case man kan se for seg er at brukeren bes om å velge fra en tidligere utfylt gruppe. Et tenkt eksempel kan være at brukeren skal registrere et sett med mistenksomme transaksjoner. Her legger først brukeren inn et sett med ulike betalingskort som en repeterende gruppe. Senere i skjema skal brukeren velge elementer fra denne gruppen når man skal legge til en mistenkelig transaksjon. Ved utfylling av den mistenkelige transaksjonen kommer sluttbruker på at man har glemt å legge til et betalingskort, men ønsker ikke da å navigere seg helt tilbake til den opprinnelige betalingskort gruppen.\nHer kommer groupReference parameteren inn i bildet på panel. Dette vil åpne opp for å kunne legge til et element i en repeterende gruppe fra konteksen hvor man benytter denne listen fra.\nEt bilde for å illustrere usecasen:\nI dette fiktive caset ligger gruppene rett over hverandre, men se for deg at disse fylles ut på ulike sider i skjema. For å få til dette oppsettet legges en gruppe element til i den repeterende gruppen som er satt opp med transaksjoner (gruppe-2) med en referanse til den første gruppen med betalingskort (gruppe-1). Følgende gruppe-komponent ligger som et barn av gruppe-2:\n{ \u0026#34;id\u0026#34;: \u0026#34;input-panel-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Legg til nytt betalingskort\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Kortet du registrer vil bli lagret og tilgjengelig i resten av tjenesten.\u0026#34;, \u0026#34;add_label\u0026#34;: \u0026#34;Legg til nytt betalingskort\u0026#34; }, \u0026#34;panel\u0026#34;: { \u0026#34;showIcon\u0026#34;: true, \u0026#34;iconUrl\u0026#34;: \u0026#34;kort.svg\u0026#34;, \u0026#34;variant\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;groupReference\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;first-group\u0026#34; } } }, Tekstressursene som kan settes er:\ntitle - panel tittel body - panel body. Plassert over gruppe elementene. add_label - tekst for \u0026ldquo;legg til\u0026rdquo;-knappen. Om ikke children er satt på gruppen vil barna til den refererte gruppen bli rendret. Ved å legge til children kan man fritt definere at det kun skal vises et subset av alle barn av den refererte gruppen.\nDemonstrasjon:\nSe eksempel app for fullstendig oppsett i fom layout.\nFlere sider innad i gruppe-visning Denne funksjonaliteten er p.t. kun tilgjengelig for repeterende grupper. Visning av gruppe over flere sider inne i redigerings-flaten til gruppen støttes KUN for grupper på øverste nivå, og støttes ikke for grupper i grupper.\rNår man skal legge inn data i en gruppe, kan det være tilfeller der hvert element i gruppen inneholder mange felter, og at det dermed blir mye scrolling og uoversiktlig for sluttbruker. For å løse dette er det innført en mulighet til å dele opp utfyllingen over flere visninger, som bruker kan navigere frem/tilbake mellom mens de fyller ut gruppe-elementet. Navigeringen her skjer innad i en layout, og oppdaterer kun visningen inne i redigeringsflaten for gruppen.\nFor å ta i bruk denne funksjonaliteten, må man prefikse komponentene i children listen med et tall som tilsier hvilken \u0026ldquo;side\u0026rdquo; av utfyllingen komponenten skal vises på, etterfulgt av :. Vi starter tellingen på 0, dvs. at komponenter som skal vises på den første \u0026ldquo;siden\u0026rdquo; må prefikses med 0:. Komponenter som skal vises på den andre siden prefikses med 1:. Osv. I tillegg må man sette \u0026quot;multiPage\u0026quot;: true på den nye edit-parameteren (se over). Se eksempel under:\n{ \u0026#34;id\u0026#34;: \u0026#34;Some-group-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;0:fnr\u0026#34;, \u0026#34;1:fornavn\u0026#34;, \u0026#34;1:mellomnavn\u0026#34;, \u0026#34;1:etternavn\u0026#34; ], \u0026#34;maxCount\u0026#34;: 10, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;familie.barn\u0026#34; }, \u0026#34;edit\u0026#34;: { \u0026#34;multiPage\u0026#34;: true, \u0026#34;mode\u0026#34;: \u0026#34;hideTable\u0026#34;, } } Her har man også lagt inn en mode som skjuler tabellen under redigering. Resultatet blir som vist under.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/prototype/",
	"title": "Prototype",
	"tags": [],
	"description": "Ved hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.",
	"content": "\nAltinn Prototype-kit er en samling av sidemaler og komponenter du kan bruke til å lage en prototype i Figma av Altinn-skjemaet ditt.\nMed Altinns Prototype-Kit for Figma kan du:\nSe hvordan Altinn-skjemaer ser ut og oppleves for brukeren Gjør deg kjent med designelementer i Altinn 3 Definere flyt og innhold for ditt eget skjema Lage klikkbare skisser som kan brukertestes Bruke prototypen som en spesifikasjon/referanse når appen utvikles Kom i gang med Figma Det er en fordel hvis du har en designer i prosjektet som har brukt Figma eller liknende verktøy tidligere. Dersom du ikke har tilgang på en slik ressurs anbefaler vi å gå gjennom en introduksjon til Figma først.\nOpprett en bruker på https://www.figma.com/. Figma kan installeres lokalt eller brukes i din nettleser. Åpne Altinn prototype-kit og følg stegene som er beskrevet i introduksjonen på første side i filen: Altinn Prototype-kit\rNår designeren/fagpersonen har designet ferdig skjemaet, og det er brukertestet, kan det videre brukes som spesifikasjon til det utviklerne skal lage i Altinn Studio.\nNB: Skal du lage tjenester i egen løsning, der Altinn er usynlig for brukeren, bør du heller bruke etatens eget designsystem for å prototype tjenesten.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/events/",
	"title": "App Events",
	"tags": ["translate-to-norwegian"],
	"description": "Overview on app events - what it is and how to use it",
	"content": "Introduction App Events is the support for Altinn Events within the application template, providing standard event functionality for the application developers.\nThe functionality provided within the template is:\nPushing events Enabling of standard events through configuration Pushing custom events through code Receiving events Subscribing to events Validate subscription Run custom code when receiving events Subscribing to events Subscring to events is descibed here\nValidate subscriptions Once the application succesfully have created a subscription, the Event Service will sende a ping event. It\u0026rsquo;s a regular event with a specific type platform.events.validatesubscription. There is already a handler for this type registered and the validation should be done without further action required.\nRun custom code when receiving events All inbound events are received through the EventsReceiverController on the route /{org}/{app}/api/v1/eventsreceiver. The controller uses IEventHandlerResolver interface to resolve the the class that should handle the event based on mapping the incoming event type to the EventType property on registered implementations of IEventHandler.\nIn order to handle an inbound event, all you have to do is two things:\nCreate an implementation of IEventHandler Register your implementation in Program.cs Create an implementation of IEventHandler In order to run your code when you receive an event, you need to create a class implementing the IEventHandler interface. IEventHandler is an interface that can have multiple implementations registered. The key to resolving the correct implementation is the event type which means you need to set the EventType property equal to the event type you want to handle. This is then matched against the event type of the incoming events, and the ProcessEvent method is invoked.\nYour implementation can of course have a constructor that takes in any registred service from the dependency injection container needed to handle the event.\nusing Altinn.App.Core.Features; using Altinn.App.Core.Models; namespace Altinn.App.Core.Internal.Events { /// \u0026lt;summary\u0026gt; /// Implementation used to handled events that the Event system used to validate /// the events receiver endpoint. /// \u0026lt;/summary\u0026gt; public class SubscriptionValidationHandler : IEventHandler { /// \u0026lt;inheritdoc/\u0026gt; public string EventType =\u0026gt; \u0026#34;platform.events.validatesubscription\u0026#34;; /// \u0026lt;inheritdoc/\u0026gt; public Task\u0026lt;bool\u0026gt; ProcessEvent(CloudEvent cloudEvent) { return Task.FromResult(true); } } } Register your implementation in Program.cs Add your implementation of the IEventHandler interface in Program.cs to allow the resolver to find it.\nservices.AddTransient\u0026lt;IEventHandler, SubscriptionValidationHandler\u0026gt;(); "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/",
	"title": "Endringslogg for app frontend",
	"tags": [],
	"description": "Oversikt over endringer introdusert i app frontend.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av app frontend.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/app-datamodels/",
	"title": "Datamodeller for applikasjoner",
	"tags": ["translate-to-english"],
	"description": "Informasjon om datamodeller for applikasjoner",
	"content": "Datamodeller for applikasjoner ligger i samme mappestruktur som resten av applikasjonsfilene. Disse ligger lagret i Gitea, under App/models i filstrukturen til appen. En applikasjon har 4 modellfiler:\n\u0026lt;model\u0026gt;.cs: Denne brukes av applikasjonen sine API\u0026rsquo;er til å behandle/validere data \u0026lt;model\u0026gt;.schema.json: Denne brukes av applikasjonen på klientsiden (nettleseren) til å validere data fortløpende. Det er også denne filen man jobber med i datamodelleringsverktøyet. \u0026lt;model\u0026gt;.xsd: Denne brukes ikke direkte av applikasjonen, men kan lastes ned ved behov til f.eks. mottakssystemer. \u0026lt;model\u0026gt;.metadata.json: Denne brukes kun til generering av \u0026lt;model\u0026gt;.cs-filen. På sikt vil vi slutte å lagre denne filen i appen, og kun generere den ved behov. Datamodeller for en applikasjon kan bygges fra bunn av, eller lastes opp, i verktøyet Altinn Studio Datamodellering.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/usertest/",
	"title": "Brukertest",
	"tags": [],
	"description": "Det er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.",
	"content": "Å brukerteste trenger ikke være veldig avansert, hverken med tanke på oppsett eller antall testpersoner. En tommelfingerregel er at hvis du har testet på fem personer har du funnet 80 % av brukervennlighetsfeilene (Jacob Nielsen).\nEtter en brukertest vil det være ting å justere på. Det kan være større ting som navigasjon og flyt, men også små justeringer som språk eller mindre endringer i interaksjonsdesignet. Hvis det er behov for å gjøre større endringer kan det være lurt å ta en ny brukertest for å sjekke om justeringene har ønsket effekt.\nEt tegn på om du har lykkes å lage en løsning som treffer brukernes behov er hvis de fleste brukerne i brukertesten klarer å gjennomføre det de skal ha gjort på nettstedet eller løsningen din uten hjelp, og innenfor en fornuftig tidsramme.\nBrukertesting i Figma Har du satt opp en prototype i Figma ved hjelp av vårt Prototype-Kit? Flott! Da kan du benytte denne til brukertesting!\nDersom du har lagt til flere steg i ditt skjema, må du huske å lenke mellom disse stegene. Dette gjør du ved å velge \u0026ldquo;Prototype\u0026rdquo; oppe til høyre i Figma. Marker en ramme eller en knapp og legg merke til den lille hvite dotten som vises til høyre på det du markerte. Denne dotten kan du ta tak i og dra til rammen du ønsker å gå til.\nDet finnes en flyt for hvert startalternativ, samt en flyt for mobilskissene. Trykk på Play-knappen på prototypen du vil starte. Etter at den er startet kan du bytte mellom de ulike flytene i venstremargen.\nFor å dele filen med testerne velger du “Share” oppe til høyre i vinduet. Du kan enten velge at filen skal være åpen for alle som har lenken, eller at kun inviterte (via epost) skal få tilgang.\nGode råd for brukertesting Test tidlig med reelle brukere Brukervennligheten kan kun måles om den blir testet på målgruppen til løsningen. Å teste tidlig gjør det billigere å fikse eventuelle problemer som avdekkes. Ufarliggjøre testen Forklar testdeltageren at hensikten ikke er å teste hvor flinke de er, men at hovedfokuset er på å avdekke eventuelle feil med tjenesten, slik at den kan bli enda bedre. Be testpersonen om å tenke høyt. For noen vil det å «tenke høyt» komme av seg selv, mens andre trenger et par påminnelser innimellom. Ikke still ledende spørsmål, men vis at du ønsker å høre testpersonens tanker og tilbakemeldinger. Vær lyttende Husk å gi testpersonen rom for tenkepauser og ha først og fremst en lyttende posisjon. Avsett god tid, så du unngår stressende stemning. Minn deg selv på formålet med testen Tilbakemeldinger fra testdeltager kan fort oppfattes som kritikk mot eget arbeid, minn deg selv på at du ønsker jo tross alt at tjenesten skal bli så bra som mulig. Uforme testoppgaver Bruk god tid på å formulere oppgavene til brukertesten, og gjør gjerne en pilottest i forkant for å avdekke feil med selve testen.\nSett et klart mål for hva deltakeren skal prøve å oppnå. Velg oppgaver som er relevante og troverdige Ikke gi bort svaret eller gi for mange hint Hos gov.uk finner du flere gode råd for å gjennomføre testen på best mulig måte.\nEtter testen Når du har vært gjennom et par brukertester har du sannsynligvis funnet ting du bør forbedre i utformingen av skjemaet eller formuleringen av innholdet. Vurder å kjøre en ekstra runde brukertesting etter du har gjort endringene.\nNå er du snart klar for utvikling! Husk også å se våre retningslinjer for design og innhold i skjemaene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/case/",
	"title": "Casebeskrivelse",
	"tags": ["apps", "case", "training"],
	"description": "Beskrivelse av kommunens krav og ønsker til tjenesten.",
	"content": "Sogndal kommune trenger sårt flere unge mennesker og ønsker å bli en attraktiv kommune for unge voksne og andre i etableringsfasen.\nI den sammenheng ønsker de å opprette en tjeneste i Altinn beregnet på personer som skal flytte til Sogndal i løpet av de neste 6 månedene.\nVed å samle inn data om tilflyttere på et tidlig tidspunkt kan kommunen legge til rette og spisse tilbudene til tilflytterne allerede før første flytteeske er pakket.\nDe har en del krav til tjenesten som er beskrevet i seksjonene nedenfor.\nKrav fra kommunen Navngivning Vis/skjul innhold\rKrav\rApplikasjonen må ha et fornuftig navn som gjør det enkelt å finne den igjen blant det store antallet repositories Sogndal kommune har i Altinn Studio.\nDet er ingen foreløpige planer om årlige revisjoner av appen, så man trenger ikke ta hensyn til årstall i navnet.\nDet er et ønske om at et eller flere av ordene \u0026ldquo;tilflytter\u0026rdquo; og \u0026ldquo;Sogndal\u0026rdquo; er med i navnet.\nFørste side med datainnsamling Vis/skjul innhold\rKrav\rVil ha navn og alder på personen som er tilflytter Fornavn Mellomnavn (valgfritt) Etternavn Alder Vil ha adressen på personen som er tilflytter Gateadresse Postnummer Poststed Vil ha kontaktinformasjon på personen som er tilflytter Epost Telefon Tekster Vis/skjul innhold\rKrav\rAlle inputfelter skal ha forklarende ledetekster (labels) som beskriver hva som skal fylles inn. Applikasjonen må være tilgjengelig både på bokmål, nynorsk og engelsk.\nI en første versjon er det tilstrekkelig at kun ett av disse språkene støttes. Det er viktig at applikasjonens visningsnavn klinger godt og er beskrivende for tjenesten. Infoside Vis/skjul innhold\rKrav\rNoen i kommunen har opprettet en skisse av informasjonssiden.\nFølgende er det ønskelig at reflekteres i applikasjonen:\nPlassering av bilder Tekststørrelser Formatering av tekst Skisse på informasjonsside\nAlternativ arbeidsflyt (sporvalg) Vis/skjul innhold\rKrav\rEn bruker som ikke oppfyller kravene for skjemaet skal stoppes så tidlig som mulig i arbeidsflyten.\nPå infosiden er det ønskelig at brukerne skal oppgi om skjemaet gjelder dem eller ikke.\nHvordan dette gjøres er fritt fram, og feltet Innflytter.KanBrukeSkjema i datamodellen er mulig å benytte til dette formålet.\nBasert på svaret skal brukeren sendes videre til Spor 1 eller Spor 2.\nSpor 1 Brukeren har ikke svart bekreftende på at skjemaet gjelder vedkommendes situasjon. Bruker skal sendes til en side med følgende tekst: Dette skjemaet er ikke for deg. Se en oversikt over andre tilbud i kommunen her. Linje 2 i teksten skal være en hyperlenke som peker på https://www.sogndal.kommune.no/. Spor 2 Brukeren har svart bekreftende på at skjemaet gjelder vedkommendes situasjon. Brukeren sendes videre til datainnsamlingssidene. Forhåndsutfylling av personopplysninger Vis/skjul innhold\rKrav\rFølgende verdier skal forhåndsutfylles for brukeren: Fornavn: Innflytter.Fornavn Mellomnavn: Innflytter.Mellomnavn Etternavn: Innflytter.Etternavn E-post: Innflytter.Kontaktinformasjon.Epost Telefonnummer: Innflytter.Kontaktinformasjon.Telefonnummer Alder: Innflytter.Alder Det skal ikke være mulig å endre forhåndsutfylt navn og alder Det skal være mulig å endre forhåndsutfylt e-post og telefonnummer Differensiert datagrunnlag for offentlig og privat sektor Vis/skjul innhold\rKrav\rVi ønsker at brukerne skal ha et ulikt sett med svaralternativer for bransjevalget basert på hvilken sektor de har krysset av for.\nPrivat sektor: Standardlisten med bransjer Offentlig sektor: Stat og Kommune Skreddersydd tilbud for IT-kompetanse Vis/skjul innhold\rKrav\rVi ønsker at dersom brukeren velger IKT (data/it) under bransje at det vises en tekst med en lenke til en av våre stillingsutlysninger.\nUnder bransjevalget skal følgende tekst presenteres: Vi ser at du besitter kompetanse vi trenger i kommunen. Se en oversikt over våre ledige stillinger her. Linje 2 i teksten skal være en hyperlenke som peker på https://sogndal.easycruit.com/index.html. Tekst og lenke skal kun vises om man har valgt IKT (data/it). I alle andre tilfeller skal dette være skjult.\nBekreftelse før innsending Vis/skjul innhold\rKrav\rVi ønsker at brukeren før innsending presenteres for hva dataen skal benyttes til og samtykker (indirekte) til dette ved å sende inn skjemaet.\nMulige operasjoner På dette punktet i arbeidsflyten skal brukeren kunne:\nSe over dataen som er utfylt Avslutte arbeidsflyten uten å sende inn skjemaet Avslutte arbeidsflyten og sende inn skjemaet Autorisasjon Det skal være samme rollekrav for å fylle ut og bekrefte en instans. Validering Det skal kun være mulig for brukeren som eier instansen å sende inn skjemaet, selv om andre måtte inneha de nødendigve rollene. Tekster Vi ønsker at brukeren skal presenteres med følgende tekst før innsending:\nDu er nå klar for å sende inn melding om tilflytting til Sogndal kommune. Ved å sende inn dette skjemaet samtykker du til at dataen du har fylt ut kan lagres og benyttes til å tilpasse kommunens tilbud til deg de neste 18 månedene. Før du sender inn vil vi anbefale å se over svarene dine. Du kan ikke endre svarene etter at du har sendt inn. Innhenting av tidligere bosteder Vis/skjul innhold\rKrav\rFor å kunne skreddersy et best mulig tilbud til nye innflyttere, ønsker vi oss en oversikt over tidligere bosteder til innflytteren.\nPå datasiden ønsker vi at det legges opp til at brukeren kan fylle inn tidligere bosteder. Tidligere bosteder skal inneholde følgende felter:\nGateadresse Postnummer Poststed Det skal være mulig å legge inn opptill 10 tidligere bosteder.\nValidering av tidligere bosteder Vis/skjul innhold\rKrav\rGrunnet en personlig vendetta blant en av Sogndal kommunes ansatte, ønsker vi at om innflytter fyller inn postnummer 4619 som en av tidligere bosteder, skal vedkommende IKKE få lov til å flytte inn i Sogndal.\nHer ønsker vi at det skal dukke opp en feilmelding på det aktuelle feltet med følgende tekst:\nDu er ikke velkommen til vår kommune. Beklager! Dataprossessering av ugyldig gateadresse Vis/skjul innhold\rKrav\rEn av kommunens databehandlere har sett seg lei av å manuelt rette opp i en gateadresse som ofte blir skrevet feil av innflyttere. Vi ønsker derfor å programmatisk fikse opp i dette under utfyllingen av appen.\nOm sluttbruker fyller inn Sesame Street 1 i feltet Innflytter.Adresse.Gateadresse, skal dette automatisk rettes til Sesamsgate 1. I alle andre tilfeller skal feltet forbli urørt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/",
	"title": "Data",
	"tags": [],
	"description": "Konfigurering av datamodell, preutfylling og andre ting relatert til data i en app.",
	"content": "\rPreutfylling\rPreutfylling av en instans med data\nDatamodell i Altinn Studio\rInformasjon om datamodeller og datamodellering i Altinn Studio\nKodelister (options)\rHvordan konfigurere options/kodelister for en app.\nVedlegg\rI en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/design-principles/",
	"title": "Designprinsipper",
	"tags": ["translate-to-english"],
	"description": "Når vi utvikler nye eller forbedrer eksisterende produkter følger vi et sett med prinsipper for å kunne sikre oss at vi leverer brukervennlige løsninger til alle. Vi anbefaler å følge disse prinsippene når du jobber med utvikling av nye tjenester.",
	"content": " Vi setter brukerbehov først Vi bruker innsikt om brukernes behov aktivt i utviklingen av produktene våre. Alle løsninger skal fokusere på å løse reelle problemer for brukerne og vi bruker undersøkelser og brukerinnsikt til å ta beslutninger. Skjule kompleksitet Vi lager fokuserte og forenklede løsninger og skreller vekk unødvendig kompleksitet for brukerne. Løsningene er ofte komplekse på baksiden, men fremstår enkle og brukervennlige for folk som bruker dem. Helhetlige brukeropplevelser Produktene våre skal henge sammen slik at folk får en helhetlig brukeropplevelse. Vi bruker konsistent språk og samme komponenter i alle digitale løsninger. Brukerne skal kjenne seg igjen uansett hvilken del av produktet man bruker. Visuelt design som motiverer Det visuelle designet skal bidra til å gjøre brukerne trygge i dialogen med det offentlige. Vi bruker en vennlig fargepalett, et enklere grensesnitt, tydelige interaksjonselementer og fargesterke illustrasjoner til å skal skape en god atmosfære. Alle visuelle beslutninger skal ha et klart formål om å skape en spesifikk effekt. Tilgjengelighet for alle Vi strekker oss langt for å lage digitale løsninger som skal være tilgjengelige for alle. Vi gjenbruker komponenter som en måte å optimalisere tilgjengelighet på - teknisk så vel som interaksjonsdesign og visuelt design. "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/generic/",
	"title": "Generelt",
	"tags": [],
	"description": "Oversikt over logikkfiler og hvordan de kan brukes.",
	"content": "Introduksjon De forskjellige filene som brukes til å definere logikk på frontend, finner man i logikk-menyen, som er tilgjengelig i UI-editoren via f(x)-ikonet øverst til høyre.\n⚠️ Dynamikk er et område under aktiv utvikling. Logikk-filer skrevet i JavaScript fases etterhvert ut og blir erstattet av dynamiske uttrykk.\nFor backend så håndteres logikk gjennom forskjellige grensesnitt. Disse er beskrevet på de forskjellige sidene under dette området som f. eks. data prosessering. Et komplett prosjekt med eksempler på serverside applikasjonslogikk ligger i vår kursapplikasjon.\nMERK: Måten man refererer til elementer i datamodellen er ulik mellom OR og SERES typer XSDer. For OR XSDer er .value et nødvendig suffiks i referansen. Eksempelkoden under bruker en blanding av de to typene datamodeller.\nAuto-complete/intellisense Ved å redigere kildekoden i appene lokalt, i f.eks. Visual Studio Code, får man intellisense og autocomplete med på kjøpet. For C#-filene er det enkleste å jobbe med disse lokalt.\nFor javascript-filene er det også intellisense/autocomplete tilgjengelig om man ønsker å redigere filene direkte i Altinn Studio. Dette kommer automatisk mens man skriver, og man kan også tvinge det frem ved å trykke CTRL + SPACE\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/link-to-app/",
	"title": "Inngang til skjema",
	"tags": [],
	"description": "For å gjøre opplevelsen til brukeren best mulig bør du tenke over hvordan du lenker til Altinn-appen fra din etat.",
	"content": "Brukertester har vist at når brukerne starter på etaten/kommunens sider for å fylle ut et skjema og så blir sendt videre til Altinn, får de ofte opplevelsen av at «plutselig var jeg i altinn». Innganger til skjema bør derfor presenteres slik at det er tydelig at man går til Altinn, men samtidig slipper å gå innom unødvendige mellomledd. \u0026ldquo;Start innsending\u0026rdquo; bør lenke direkte til skjemaet. Opplevelsen til bruker vil da også i større grad bli at man får løst oppgaven i konteksten man er i, men at Altinn er brukt som løsning for innsending og historikk.\nIntegrerte komponenter\nI tett samarbeid med sentrale tjenesteeiere planlegger vi på sikt å kunne tilby komponenter som kan benyttes på etatens nettsider, slik at brukerne kan løse oppgaven i den konteksten de er i.\nAltinns brukere ønsker både løsning der de er og en samlet oversikt. Og de bør få begge deler. Men behovene dekkes best på litt forskjellige måter.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/content/",
	"title": "Innhold i skjema",
	"tags": ["translate-to-english"],
	"description": "Forklar brukeren hva som skal til for å fylle ut skjemaet riktig og fordel innholdet i flere steg.",
	"content": "Brukeren skal ikke trenge å få feilmelding for å forstå hva som skal til for å fylle ut skjemaet riktig. Dette bør tydelig komme frem i informasjonstekst i begynnelsen av skjemaet og i labels som tilhører hvert enkelt skjemafelt.\nSom hovedregel bør man kun spørre om informasjon som er helt nødvendig å innhente. Du kan derfor opplyse i starten av skjemaet om at alle felt er påkrevde og må fylles ut (for å slippe å markere alle som påkrevde). Frivillige felt kan eventuelt markeres med \u0026ldquo;frivillig\u0026rdquo; i selve labelen til feltet.\nFordel innholdet i flere steg og bruk sporvalg En side med mye informasjon og flere oppgaver kan fort bli overveldende for en bruker. Prøv å del opp tjenesten slik at brukeren bare har en oppgave per side. Dette kan for eksempel være et spørsmål brukeren må svare på eller viktig informasjon som må leses. Dette kan gjøre det lettere for brukeren å fokusere på og forstå det du ber dem om.\nDesignet vi tilbyr nå er laget med utgangspunkt i dette konseptet. Et større antall komponenter kan føre til mye scrolling og en mer uoversiktlig opplevelse for brukeren. Se eksempel: Starte enkeltpersonforetak.\nBrukeren skal slippe å svare på mer enn nødvendig. Dersom brukeren har svart nei på et spørsmål og du dermed kan skjule flere oppfølgingsspørsmål (eller hele sider), kan du gjøre dette med dynamiske uttrykk.\nDisabled Ved å vise skjemafelt som disabled forventer man at brukeren skal vite hvorfor de ikke kan bruke elementet, men dette er ikke alltid tilfellet. Noen brukerer forstår heller ikke at feltet er deaktivert, som igjen kan føre til forvirring. Bruk av disabled bør derfor unngås. Dersom en handlingen av en eller annen grunn ikke er tillatt, kan dette i stedet forklares i en informasjonstekst.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/intro/",
	"title": "Introduksjon til Altinn Studio",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.",
	"content": "Prosessen for å lage skjemaer og meldinger vil være forskjellig alt etter som hvor stor eller liten målgruppen er, hvor mye data som skal behandles eller hvor mye jobb det er å legge til rette for at egne systemer kan snakke med Altinn.\nSlik går du frem:\nStart alltid med å definere brukerbehov\nTenk nøye gjennom hele prosessen fra et brukerperspektiv. Hva er utfordringen og hvem skal den løses for? Hva er databehovet? Lag gjerne en skisse til kommunikasjon med brukeren og test skissen på folk i målgruppen.\nPlanlegg og design din app\rFå tilgang til systemer\nHvis du ikke har utviklet tjenester i Altinn Studio før trenger du å opprette en bruker. Har du ikke allerede en ferdig datamodell/XSD så trenger du i tillegg tilgang til SERES-domeneklient.\nTilrettelegge egne systemer for sending og mottak av data\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI ​viser disse mønstrene og kan brukes for å komme i gang.\nUtvikle tjenestene\nAltinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større avanserte applikasjoner som digitaliserer komplekse prosesser. Det er viktig å tenke på at brukeren skal oppleve prosessene som sammenhengende og oversiktlige. Prosessene kan startes av det offentlige eller av brukeren selv, eller automatisk som en reaksjon på en hendelse.\nTeste tjenestene\nAltinn har et eget testmiljø hvor du kan teste om apper og opp-/nedlasting av data virker som det skal. I testmiljøet bruker du fiktive testpersoner og organisasjoner. Når du har kommet så langt i utviklingen er det også viktig å brukerteste den endelige løsningen på reelle folk i målgruppen. Dette for å sikre at det ikke er noen hinder for de som skal bruke tjenestene. Det er også mulig å teste app lokalt på egen maskin.\nProduksjonssette tjenestene\nTjenesteeier kan selv produksjonssette sine applikasjoner og gjøre vedlikehold av kode og avhengigheter.\nMelding av feil\nFeil meldes til Altinn fra den enkelte tjenesteeier sitt dashboard på Altinn Digitalisering (krever innlogging).\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/",
	"title": "Kom i gang",
	"tags": [],
	"description": "Kom i gang slik at du kan utvikle apper i Altinn Studio.",
	"content": "\rIntroduksjon til Altinn Studio\rAltinn Studio er vårt nye verktøy for å utvikle offentlige digitale tjenester. Dette kan være alt fra helt enkle skjema til avanserte applikasjoner.\nOpprette bruker i Altinn Studio\rKonfigurer brukeren din i Altinn Studio for første gang.\nDashboard i Altinn Studio\rHvordan bruke dashboardet i Altinn Studio\nKopier app i Altinn Studio\rSlik oppretter man en kopi av applikasjon i Altinn Studio.\nOpprette app i Altinn Studio\rSlik oppretter man en ny applikasjon i Altinn Studio.\nMigrere tjenester\rFra Altinn 2 til Altinn 3.\nNavigasjon i Altinn Studio\rSlik navigerer du mellom de ulike delene av Altinn Studio.\nTilganger\rHvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.\nLokal utvikling\rHvordan komme i gang med lokal utvikling\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/",
	"title": "Komponenter",
	"tags": [],
	"description": "",
	"content": "\rMultipleSelect\rPanel\rPrintButton\rLikert\rHvordan ta i bruk en likert komponent\nListekomponent\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/consistency/",
	"title": "Konsistens på tvers av tjenester",
	"tags": [],
	"description": "For å være lett å bruke og unngå forvirring, bør samme interaksjonsmønstre følges på tvers av tjenester.",
	"content": "Når brukere møter en ny tjeneste, har de med seg forventninger fra tidligere opplevelser. Når disse forventningene møtes, kreves det mindre av brukeren for å samhandle med komponentene, og det bygges selvtillit. Ved å ikke trenge å lære nye interaksjoner, vil brukerens fokus i større grad være på innholdet.\nVi anbefaler ikke å endre CSS for individuelle tjenester som bruker Altinn-designet. Dersom vi åpner opp for designendringer og fargeendringer, vil dette skade konsistensen mellom tjenestene. Konsekvent design mellom tjenesteeiere er noe vi bør strekke oss mot. For å få det til kreves et godt samarbeid mellom fagmiljøet i Altinn og hos de ulike tjenesteeierene. Vi ønsker oss en god felles løsning som kan brukes og forbedres av alle, fremfor mange forskjellige løsninger gjennom ulike CSS-endringer. Dette vil også gjøre det lettere å kontrollere tilgjengeligheten på tvers av apper på plattformen vår. Velger du likevel å gå bort fra designet, er du selv ansvarlig for å følge alle WCAG-krav.\nHar du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nOpprett en sak i github\rSkriv til oss på Slack\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/",
	"title": "Lage apper",
	"tags": [],
	"description": "Altinn Studio er vårt nye verktøy for å utvikle digitale tjenester (apps). Dette kan være alt fra helt enkle skjema til veldig avanserte applikasjoner.",
	"content": "\rHvem kan ta i bruk Altinn Studio?\nDu må være tjenesteeier i Altinn samt godta bruksvilkår for Altinn i skyen for å kunne produksjonssette apper, men alle kan logge inn i altinn.studio og teste ut mulighetene.\nHvis du lurer på noe så er det bare å ta kontakt med oss på Slack eller GitHub, eller lese denne dokumentasjonen.\nKom i gang\rKom i gang slik at du kan utvikle apper i Altinn Studio.\nIntrokurs\rEt kursopplegg for å lære seg apputvikling med Altinn Studio og lokale verktøy.\nDesign og planlegging\rFor at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.\nUtvikling\rHvordan opprette og redigere apper i Altinn Studio.\nTesting av apper\rApplikasjoner (apper) kan testes i testmiljø, eller lokalt.\nProduksjonssetting av apper\rTjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.\nVedlikehold av app i produksjon\rApplikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.\nLanserte tjenester\rNoen av tjenestene som allerede er i produksjon, til informasjon og inspirasjon.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/multipleselect/",
	"title": "MultipleSelect",
	"tags": [],
	"description": "",
	"content": "MultipleSelect kan benyttes når brukeren kan velge blant flere valg. Tilbyr filtrering ut av boksen.\nFormLayout.json eksempel\n{ \u0026#34;id\u0026#34;: \u0026#34;multiple-select-component-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;MultipleSelect\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;some.title\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;some.field\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;someOptionId\u0026#34;, }, Som Checkbox-komponenten vil MultipleSelect lagre valgene som en komma-separert liste.\nMultipleSelect komponenten kan bli konfigurert med kodelister direkte ved bruk at options parameteret:\n{ \u0026#34;id\u0026#34;: \u0026#34;multiple-select-component-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;MultipleSelect\u0026#34;, ... \u0026#34;options\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;Label 1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value1\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;Label 2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;value2\u0026#34; }, ], }, eller ved bruk av api-baserte kodelister som beskrevet her.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/navigation/",
	"title": "Navigasjon mellom sider",
	"tags": [],
	"description": "Hvordan sette opp navigasjon mellom sider.",
	"content": "Navigering videre til neste side skjer via en navigerings-knapp. Denne må legges til manuelt i hver layout-fil hvor man ønsker navigering fremover. Navigering tilbake til forrige side gjøres via tilbake-pil i venstre hjørnet. Denne knappen vises alltid så lenge det er en side å gå tilbake til, og er ikke en del av layout-filen. Se bilde under.\nLegge til knapp for navigering Knapp for navigering legges inn i alle layout-filer der det er behov. Om man ønsker at den skal dukke opp nederst på siden, må den legges inn nederst i layout-filen. Eksempel vises under\n{ \u0026#34;id\u0026#34;: \u0026#34;nav-page2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;next\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;back\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} } Det er også mulighet for å vise en tilbake-knapp sammen med neste-knappen, ved å legge til parameteren \u0026quot;showBackButton\u0026quot;: true på komponenten.\nParameter Beskrivelse id Unik ID, tilsvarende som for alle andre skjemakomponenter. type Må være \u0026quot;NavigationButtons\u0026quot; textResourceBindings Setter man parametre next (og evt. back) her, vil man kunne overstyre med egne tekster som vises på knappen(e). Se eksempel over. showBackButton Valgfri. Gjør at 2 knapper (tilbake/neste) vises i stedet for bare en (neste). Navigasjonsbar Navigasjonsbar gir enkel tilgang til alle sider i en applikasjon.\nNavigasjonsbar lister opp alle sider i appen, og egner seg derfor ikke til bruk ved sporvalg.\rPå store skjermer vil alle sider listes opp. Dersom det ikke er plass på en linje, vil listen brytes og fortsette på neste linje. På mindre skjermer vil alle sider være skjult i en meny. Den siden som er aktiv vil vises i menyen. Når menyen klikkes på, vil en liste over alle sider vises.\nNavigasjonsbar legges inn i alle layoutfiler der den skal brukes. Eksempel på konfigurasjon:\n{ \u0026#34;id\u0026#34;: \u0026#34;navbar-page-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationBar\u0026#34; } Endre tekster på navigasjonsbarknapper Teksten på navigasjonsbarknappene vil som standard bruke filnavnet på siden uten filendelsen. F.eks om man har side1.json og side2.json vil navigasjonsknappene hete side1 og side2. For å overstyre disse tekstene, kan du legge til tekster i resources.XX.json, hvor id er navnet på filen uten filendelse. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;side1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Første side\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;side2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Siste side\u0026#34; }, Rekkefølge Standard rekkefølge for sidene er alfabetisk. Utover det kan man navngi hver side som man ønsker, det er da filnavnet som gjelder her. For å sikre at sidene kommer i ønsket rekkefølge kan man f.eks. sette en prefix med tall foran sidenavnet i filnavn. F.eks:\n|- App/\r|- ui/\r|- layouts/\r|- 1.firstPage.json\r|- 2.secondPage.json\r|- 3.aFinalPage.json Det er også mulig å styre rekkefølgen på sidene ved hjelp av Settings.json under App/ui/. Dette gjøres på følgende vis:\n{ \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [\u0026#34;side2\u0026#34;, \u0026#34;side1\u0026#34;] } } Her vil sidene da vises i rekkefølgen spesifisert i pages.order. Om denne array\u0026rsquo;en ikke settes i repo så vil man bruke alfabetisk rekkefølge som utgangspunkt for rekkefølgen på sidene.\nOm du ønsker å dynamisk endre på rekkefølgen på sidene kan dette gjøres med sporvalg.\nValidering ved sidebytte Det er mulig å trigge validering i det brukeren prøver å bevege seg til neste side. Dette kan gjøres ved å legge til strengen validatePage i triggers på navigasjons-knapp komponenten. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;7cbc1c00-4c8c-42b6-bcef-12b3c4c45373\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;componentType\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;Neste\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;Tilbake\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;validatePage\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;showBackButton\u0026#34;: true } Ved å legge til validatePage i triggers vil app-frontend kjøre valideringene på den aktuelle siden i det brukeren navigerer til neste side. Om det er feilmeldinger på siden vil brukeren bli hindret i å gå videre før dette er rettet opp. Om validatePage er lagt til som en trigger vil også id\u0026rsquo;en på siden som trigger valideringen sendes ved som en header LayoutId til valideringene som kjøres på serversiden. Dette muliggjør å skreddersy backend-valideringene basert på hvilken side brukeren trigger valideringen fra.\nDet er også mulig å trigge validering på alle sider ved å legge til validateAllPages i triggers.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/org-datamodels/",
	"title": "Datamodeller for organisasjoner",
	"tags": ["translate-to-english"],
	"description": "Informasjon om datamodeller for organisasjoner i Altinn Studio",
	"content": "Datamodeller for organisasjoner ligger i Altinn Studio sin repos-løsning. For å få tilgang til disse må man logge inn med Altinn Studio bruker. Om det er første gang du bruker Altinn Studio må du lage en bruker.\nDatamodellene ligger i \u0026lt;org\u0026gt;-datamodels-repo, hvor \u0026lt;org\u0026gt; er den organisasjonen du tilhører. F.eks. ligger datamodellene til organisasjonen Testdepartementet (ttd) under https://altinn.studio/repos/ttd/ttd-datamodels.\nLenke til dette repoet finner man på førstesiden i Altinn Studio. Velg Rediger (blått penn-ikon) for å komme til Altinn Studio Datamodellering verktøet. Velg Gitea (grønt kopp-ikon) for å se filene direkte i repo.\nTilgang til datamodellene Alle kan se på datamodellene til en organisasjon som standard. For å få tilgang til å redigere datamodellene må brukeren være del av Datamodels-teamet i organisasjonen. Les mer om tilgangsstyring for mer informasjon. Ta kontakt med de som styrer tilganger i Altinn Studio i din organisasjon om du mangler tilganger.\nLaste opp XSD XSD kan lastes opp direkte i verktøyet Altinn Studio Datamodellering. Det vil da genereres en .schema.json fil for modellen i tillegg til XSD\u0026rsquo;en som lastes opp - det er denne filen man jobber med i verktøyet.\nOm man kun har behov for å laste opp XSD for lagring, og ikke skal bruke verktøyet for å redigere modellen, må man også laste opp XSD-filer direkte til filstrukturen til datamodeller for organisasjonen. Naviger da til ønsket mappe og velg \u0026ldquo;Add file\u0026rdquo; -\u0026gt; \u0026ldquo;Upload file\u0026rdquo;. I tekstfeltet som dukker opp øverst kan man skrive inn ev. mappenavn man ønsker å benytte. Last opp ønsket fil, scroll ned, skriv ev. in en melding om hva slags fil det er, og trykk på \u0026ldquo;commit changes\u0026rdquo; for å bekrefte.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/panel/",
	"title": "Panel",
	"tags": [],
	"description": "",
	"content": "Panelkomponenten kan brukes til å vise viktig informasjon til brukeren.\nFormLayout.json eksempel\n{ \u0026#34;id\u0026#34;: \u0026#34;panelinfo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Panel\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Infotekst\u0026#34;, \u0026#34;body\u0026#34;: \u0026#34;Her kommer litt viktig informasjon\u0026#34; }, \u0026#34;variant\u0026#34;: \u0026#34;info\u0026#34;, \u0026#34;showIcon\u0026#34;: false } variant kan være en av følgende:\ninfo success warning showIcon kan brukes til å skjule/vise ikonet. Ikonet vil vises som standard.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/",
	"title": "Preutfylling",
	"tags": [],
	"description": "Preutfylling av en instans med data",
	"content": "Altinn tilbyr i dag tre fremgangsmåter for å preutfylle data i en app for en sluttbruker. Disse metodene kan kombineres fritt for å oppnå ønsket resultat\nPreutfylling av data med konfigurasjon\rHvordan konfigurere prefill for en app.\nPreutfylling av data med egendefinert kode\rHvordan kode egendefinert preutfylling i applikasjonen.\nPreutfylling med http post\rHvordan konfigurere prefill for en app ved bruk av http post requests.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/printbutton/",
	"title": "PrintButton",
	"tags": [],
	"description": "",
	"content": "PrintButton-komponenten kan legges til i form layout der du vil gi en mulighet til å åpne utskriftsdialogen til nettleseren. I det knappen blir klikket på vil utskriftsdialogen åpne seg. Vanligvis er det en mulighet til å \u0026ldquo;Skrive ut som PDF\u0026rdquo; om ønskelig.\nFormLayout.json eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;printButtonInfo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;PrintButton\u0026#34; } Standardteksten på PrintButton er \u0026ldquo;Print / Lagre PDF\u0026rdquo;. Teksten kan bli overstyrt ved å endre tekstresurs-nøkkelen:\n{ \u0026#34;id\u0026#34;: \u0026#34;general.print_button_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Skriv ut\u0026#34; } PrintButton-komponenten støtter også grid-tilpassning om ønskelig.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/",
	"title": "Sider",
	"tags": [],
	"description": "Hvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.",
	"content": "Oppsett av flere sider kan gjøres enten manuelt (som beskrevet under) eller direkte i skjema-editoren i Altinn Studio. Merk at siste side sluttbruker var innom nå caches slik at man kommer tilbake til denne siden når appen lastes inn på nytt.\rOppsett For å få funksjonalitet for flere sider i skjema, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 1.2.0-alpha eller nyere. Se instrukser for hvordan det gjøres her.\nFlere sider i skjema (innenfor samme prosess-task) støttes ved å dele opp dagens layout-fil App/ui/FormLayout.json i en fil per side. Filene må legges i en mappe App/ui/layouts. Hver layout-fil må bruke samme format som den eksisterende FormLayout.json filen. F.eks.:\n|- App/\r|- ui/\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json Anbefalt fremgangsmåte så lenge det er behov for å sette det opp manuelt, er å bruke ui-editoren i Altinn Studio for å legge inn alle komponentene inn i FormLayout.json, for å så kopiere de ut i sine respektive layout-filer, en for hver side man ønsker. FormLayout.json kan enten få nytt navn under layouts-mappen, eller slettes.\nMerk: FormLayout.json må enten flyttes (evt med nytt navn) inn i layouts-mappen, eller slettes. Dersom man har den gamle FormLayout.json-filen under App/ui-mappen som tidligere, vil kun denne brukes og alle filer under App/ui/layouts-mappen ignoreres.\nNavigasjon mellom sider\rHvordan sette opp navigasjon mellom sider.\nSporvalg\rHvordan legge til dynamisk sporvalg i app\nOppsummeringsvisning\rHvordan sette opp visning av oppsummering av utfylt skjema.\nFlere skjema i samme app (layout-sets)\rHvordan sette opp en app som inneholder flere ulike skjema.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/events/subscribing/",
	"title": "Subscribing",
	"tags": ["translate-to-norwegian"],
	"description": "How to set up event subscription in an app",
	"content": "Subscribing to events In order to receive events in the application you need create a subscription. While you can create a subscription authenticated as a user, most scenarios will probably be to authenticate as the organization owning the application, and to create the subscription as part of the startup process of the application. This example covers authenticating as an organization through maskinporten.\nYou should first make sure you have a client definition registered in Maskinporten for your application. See Authenticating with Maskinporten on how register a client.\rConfiguring Maskinporten integration Even though we are authenticating through maskinporten, we can\u0026rsquo;t use the received token directly since Altinn Events only supports an Altinn token. To solve this we need to exchange the Maskinporten token into an Altinn token. The example below adds a message handler to the EventsSubscriptionClient used to communicate with Maskinporten. This handler automatically requests a token from Maskinporten, exchanges it to an Altinn token and adds the token to the request to the Event System when creating a subscription.\nThis code should be added to Program.cs.\nservices.AddMaskinportenHttpClient\u0026lt;MaskinportenClientDefinition, EventsSubscriptionClient\u0026gt;( config.GetSection(\u0026#34;MaskinportenSettings\u0026#34;), clientDefinition =\u0026gt; { clientDefinition.ClientSettings.Scope = \u0026#34;altinn:serviceowner/instances.read\u0026#34;; clientDefinition.ClientSettings.ExhangeToAltinnToken = true; }).AddTypedClient\u0026lt;IEventsSubscription, EventsSubscriptionClient\u0026gt;(); Scope and ExchangeToAltinnToken need to be configured in code and not in AppSettings.json if you have multiple external dependencies that requires the use of Maskinporten. This is to avoid scopes belonging to one external api being sent to another api. Some api\u0026rsquo;s accept this while others will reject the request due to unknown scopes. It\u0026rsquo;s also best practice not to leak unnecessary scopes to other api\u0026rsquo;s that don\u0026rsquo;t require it to avoid token misuse.\nThe MaskinportenClientDefinition in the example above is a custom implementation of IClientDefinition from the nuget package Altinn.ApiClients.Maskinporten which is included as a part of the Altinn.App.Core package. If you don\u0026rsquo;t need a custom implementation you can use one of the built in client definitions.\rDepending on what type of ClientDefintion you use you typically need to specify either a certificate file and password, encoded jwk, encoded x509 certificate or enterprise username/password in order to authenticate with Maskinporten in addition to the environment and client id. These can be shared between the various integrations.\n\u0026#34;MaskinportenSettings\u0026#34;: { \u0026#34;Environment\u0026#34;: \u0026#34;ver2\u0026#34;, \u0026#34;ClientId\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CertificatePkcs12Path\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;CertificatePkcs12Password\u0026#34;: \u0026#34;\u0026#34; } Here is a C# class of the settings available for reference.\nProtecting the event endpoint with a secret Receving events in the application is based on exposing a webhook endpoint to which the Event Service posts the event. Upon receiving an event, the application validates if a secret is provided before accepting the event. The secret is provided by implementing the IEventSecretCodeProvider interface. By default there is an example implementation in place using a key from the key vault using a key with the name EventSubscription--SecretCode in the key vault the value of that key is used. You should hover not use the same key/value for multiple applications so it\u0026rsquo;s recomended to create your own implementation.\nNote that the return url and the secret code is part of the subscription definition. This means that if you rotate the key, you should remove the existing subscription first, or else you will have two active subscriptions for the same events.\rCreate subscription Once you have your client registered with Maskinporten, your config setup, your ClientDefinition in place and your webhook secret defined - you are ready to add the code required to make a subscription.\nThe example below is using the IHostedService from Microsoft which, in this case, run once after the services are registered in the container, but before the application is configured.\nusing Altinn.App.Core.Infrastructure.Clients.Events; using Altinn.App.Core.Internal.Events; using Altinn.App.Core.Models; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; namespace Altinn.App.Core.EFormidling { /// \u0026lt;summary\u0026gt; /// Hosted service to set up prequisites for Eformidling integration. /// \u0026lt;/summary\u0026gt; public class EformidlingStartup : IHostedService { private readonly AppIdentifier _appIdentifier; private readonly IEventsSubscription _eventsSubscriptionClient; private readonly ILogger\u0026lt;EformidlingStartup\u0026gt; _logger; /// \u0026lt;summary\u0026gt; /// Initializes a new instance of the \u0026lt;see cref=\u0026#34;EformidlingStartup\u0026#34;/\u0026gt; class. /// \u0026lt;/summary\u0026gt; public EformidlingStartup(AppIdentifier appId, IEventsSubscription eventsSubscriptionClient, ILogger\u0026lt;EformidlingStartup\u0026gt; logger) { _appIdentifier = appId; _eventsSubscriptionClient = eventsSubscriptionClient; _logger = logger; } ///\u0026lt;inheritDoc/\u0026gt; public async Task StartAsync(CancellationToken cancellationToken) { var eventType = \u0026#34;app.eformidling.reminder.checkinstancestatus\u0026#34;; try { Subscription subscription = await _eventsSubscriptionClient.AddSubscription(_appIdentifier.Org, _appIdentifier.App, eventType); _logger.LogInformation(\u0026#34;Successfully subscribed to event {eventType} for app {appIdentifier}. Subscription {subscriptionId} is being used.\u0026#34;, eventType, _appIdentifier, subscription.Id); } catch (Exception ex) { _logger.LogError(\u0026#34;Unable to subscribe to event {eventType} for app {appIdentifier}. Received exception {exceptionMessage} with {stackTrace}\u0026#34;, eventType, _appIdentifier, ex.Message, ex.StackTrace); throw; } } /// \u0026lt;inheritdoc/\u0026gt; public Task StopAsync(CancellationToken cancellationToken) { return Task.CompletedTask; } } } If the hosted service fail to run succesfully, ie. throws an exception, the application will fail to start. If you don\u0026rsquo;t won\u0026rsquo;t this behavior you shold catch any exception and don\u0026rsquo;t rethrow it.\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/title-and-paragraph/",
	"title": "Tittel og avsnitt",
	"tags": [],
	"description": "Det bør som hovedregel alltid være en header (H2) og et avsnitt i starten på en skjamaside for å oppsummere brukerens oppgave.",
	"content": "Retningslinjer: Tekstlengde på avsnitt strekkes ikke ut 100% i modalboksen, ettersom lange linjer tekst forstyrrer flyten i lesingen. Avsnitt er derfor begrenset til maks 696px i bredden, selv om modalen fyller ut 1056px. Teksten skal alltid være venstrestilt. Ha riktig rekkefølge på overskriftsnivåene. Ikke hopp over nivåer, men gå nedover et nivå om gangen. For eksempel er H2 - H2 og H2 - H3 lov, men H1 - H3 er ikke lov. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/",
	"title": "UI-komponenter",
	"tags": [],
	"description": "De ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.",
	"content": "\rHar du behov for en ny komponent?\nVi ønsker at alle er med på å videreutvikle biblioteket av komponenter med både design og kode. I praksis vil dette si at Altinn ønsker å ta imot forslag til nye komponenter etter hvert som tjenesteeierne ser behovet for det.\nSjekk gjerne nedenunder at ikke komponenten du trenger allerede eksisterer.\nOpprett en sak i github\rSkriv til oss på Slack\rTittel og avsnitt\rDet bør som hovedregel alltid være en header (H2) og et avsnitt i starten på en skjamaside for å oppsummere brukerens oppgave.\nKnapp og lenke\rHovedknapp (blå) brukes for å sende brukeren til neste steg.\nInput\rInputfelt brukes når brukeren skal føre inn tekst eller tall.\nDato\rDatovelger benyttes i forbindelse med planlegging eller for datoer i nærliggende tid. For datoer lengre tilbake i tid brukes datofelt.\nAvkrysningsboks\rAvkrysningsbokser brukes i tilfeller der brukeren kan huke av ett eller flere alternativer fra en liste.\nRadioknapp\rRadioknapper brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder nedtrekksliste, så vær bevisst på når du bruker hvilken.\nNedtrekksliste\rNedtrekksliste brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder radioknapper, så vær bevisst på når du bruker hvilken.\nHjelpetekst\rHjelpetekster er små tekstsnutter som kan benyttes for å gi brukeren ekstra veiledning i utfylling av skjemafelter.\nFeilmeldinger\rFeilmeldinger forklarer brukeren hva som gikk galt og hvordan det kan rettes opp i.\nFilopplasting\rFilopplasting tillater brukere å laste opp en eller flere filer.\nBilde\rBruk bilder og illustrasjoner for å fremheve poenger eller illustrere konsepter som er vanskelig å beskrive med tekst\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/",
	"title": "Introkurs",
	"tags": ["apps", "build", "deploy", "training"],
	"description": "Et kursopplegg for å lære seg apputvikling med Altinn Studio og lokale verktøy.",
	"content": "Dette intro-kurset er delt opp i seks moduler og dekker et fiktivt case for Sogndal kommune. I løpet av disse seks modulene vil du ha vært innom den mest sentrale funksjonaliteten for en Altinn-app, samt testing av applikasjonen lokalt og i testmiljø.\nTre ting må være på plass før du går i gang med dette kurset.\nEn bruker i Altinn Studio Ditt lokale utviklingsmiljø er satt opp med støtte for utvikling og testing av apps Tilgang til en organisasjon med et testmiljø* * En forutsetning for modul 3. Resterende moduler kan fullføres med fullt læringsutbytte uten at dette er på plass.\nNå kjører vi i gang! Les gjennom caset til Sogndal kommune, og jobb deg gjennom modul for modul. Casebeskrivelse\rBeskrivelse av kommunens krav og ønsker til tjenesten.\nModul 1\rOpprette app i Studio, sette opp lokalt utviklingsmiljø og lokal test\nModul 2\rLegge til flere sider, sporvalg og forhåndsutfylling\nModul 3\rBygg og deploy applikasjon til testmiljø\nModul 4\rLegge til kodelister manuelt, programatisk og dynamisk\nModul 5\rLegge til bekreftelsessteg\nModul 6\rUtvidelse av skjema med repeterende gruppe\nModul 7\rFrittstående utvidelser av appen\nLøsningsforslag\rLøsningsforslag og forklaring på forståelsessjekker\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/",
	"title": "Altinn 3 API",
	"tags": ["translate-to-norwegian"],
	"description": "Beskrivelse av Altinn API for sluttbrukere og applikasjonseiere.",
	"content": "De to primære datastrukturene Dette vil være en oversikt over primærmodellene som brukes i Altinn 3. Hovedhensikten med dette er å danne en grunnleggende forståelse av modellene før introduksjon av API\u0026rsquo;ene.\nInstans (Forekomst) Instansmodellen er hovedmetadatadokumentet i Altinn 3. Den brukes av Altinn for å holde styr på tilstanden til en interaksjon mellom en sluttbruker og eieren av en app. En instans må være knyttet til en app og en rapportør som instans-eier.\nInstanser er også litt som beholdere for alle andre dokumenter; skjemaer og ustrukturert data samlet inn under en interaksjon mellom en sluttbruker og applikasjonseieren. Antall dokumenter og filer som produseres vil avhenge av appen.\nI en enkel app vil en sluttbruker fylle ut et skjema og sende det til applikasjonseieren. Dette vil typisk produsere en enveis interaksjon der bare ett eller to dokumenter samles inn i instansen. I mer avanserte apper vil antallet dokumenter og filer utvides til flere skjemaer, vedlegg og tilbakemeldinger eller valideringsmeldinger fra applikasjonseieren.\nEn instans kan ikke referere til data direkte, men vil inneholde en liste over dataelementer med mer informasjon om innsamlede data.\nDataElement DataElement-modellen er et metadatadokument for et spesifikt skjema eller binær fil. De viktigste aspektene ved dette dokumentet er at det inneholder informasjon om hvor de faktiske dataene blir lagret, og hvordan dataene brukes av applikasjonen.\nDe fleste apper vil automatisk opprette et dataelement for å representere skjemaet som fylles ut av brukeren. Mer avanserte apper vil også kreve at brukeren laster opp vedlegg eller fyller ut flere skjemaer.\nEn instans kan ha mange dataelementer, men hvert dataelement kan ikke referere til mer enn én datafil.\nAPI\u0026rsquo;ene Altinn 3-løsningen har flere API\u0026rsquo;er, men de kan deles i to grupper: App-API\u0026rsquo;ene og plattform-API\u0026rsquo;ene.\nApp API Applikasjons-API er et API som gir tilgang til spesifikke forekomster av en spesifikk app. API-en gir funksjoner for å jobbe med dataelementer mens metadatadokumentet for forekomsten og dens dataelementer holdes oppdatert. Instansnivå-endepunktene dreier seg om å flytte en instans gjennom dens definerte prosess og kontrollere noen instansnivå-innstillinger.\nMetadata for en app er den andre jobben til app-API-en. Det finnes endepunkter som gir tilgang til metadataene til selve appen, dens datatyper og prosessbeskrivelse.\nHver app vil avsløre nesten identiske endepunkter og funksjonalitet. Eksterne parter skal bare trenge én klientimplementering på tvers av alle app-API-er, men det er mulig for applikasjonseieren å utvide app-API-en med flere endepunkter og til og med gjøre endringer i standardfunksjonaliteten. Dokumentasjon for appspesifikk API og funksjoner må hentes direkte fra appen eller fra appeieren.\nhttps://{org}.apps.altinn.no/{org}/{appname} URL-en identifiserer appeierens spesifikke vertsnavn ved å bruke det korte navnet org, og identifikatoren til appen som består av både appeierens korte navn og navnet på appen. Å kombinere organisasjonen og appnavnet resulterer i det vi kaller app-ID-en org/appnavn.\nPlattform API Plattform-API\u0026rsquo;ene er primært laget for å støtte applikasjonene som er vert på plattformen, men mange endepunkter kan brukes direkte av både applikasjonseiere og brukere. Primært på API-ene for autentisering, hendelser og lagring.\nStorage API gir tilgang til alle instanser på tvers av alle applikasjoner. Den kan brukes til å få tilgang til metadata om applikasjoner, instanser, dataelementer og instansaktivitetslogg (hendelser), samt det faktiske datainnholdet. Denne API-en bør være den foretrukne metoden for appeiere for å laste ned data knyttet til instanser som er opprettet basert på deres apper. Applikasjonsbrukere kan bruke den hvis de trenger en form for meldingsboks eller ønsker å hente arkiverte instanser og deres data.\nAutentiserings-API\u0026rsquo;et gir metoder for autentisering.\nEvents API gir tilgang til Events-komponentens endepunkt for oppføring av hendelser. Dette kan brukes sporadisk for å spørre Altinn etter hendelser som har oppstått i løsningen.\nhttps://platform.altinn.no API Brukergrupper Det er primært to grupper brukere av Altinn API\u0026rsquo;er. Den første gruppen består av applikasjoner og systemer som brukes av eierne av appene som er vert for Altinn. Denne gruppen kalles Application Owners. Den andre gruppen består av organisasjoner og personer som bruker appene til å kommunisere med appeierne. Denne gruppen kalles Applikasjonsbrukere.\nDe to gruppene har mange like behov, men det er noen forskjeller i hva slags type oppgaver de skal utføre. Alle nye API-er er teknisk tilgjengelige for begge gruppene, men noen endepunkter har autorisasjon til å tillate bare én av gruppene.\nApp-eiere En liste over vanlige oppgaver for en app-eier:\nSøk instanser for en gitt applikasjon i henhold til status eller forekomsteiere. Opprett en applikasjons-instans. Last opp skjemadata og vedlegg. Last ned skjemadata. Endre prosesstilstand (arbeidsflyt). Bekreft instansen som komplett. Applikasjonsbrukere En liste over vanlige oppgaver for en applikasjonsbruker:\nSøk instanser for seg selv eller en part de kan representere (instanseier). Opprett en applikasjons-instans. Last opp skjemadata og vedlegg. Last ned skjemadata. Endre prosesstilstand (arbeidsflyt). Se status for en instans. App API\rStandard API\u0026#39;er eksponert av apper i Altinn 3.\nAuthentication API\rBeskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.\nEvents API\rPlatform API for hendelser.\nModeller\rDette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.\nScenarier\rForskjellige API-bruksscenarier.\nStorage API\rBeskrivelse av API\u0026#39;et til Storage komponenten i Altinn 3 platformen.\nAltinn Studio Repository API\rOpenAPI (swagger) spesifikasjon for Altinn Studio.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/app-metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "The application metadata document holds technical information about the app and the data type requirements.",
	"content": "Application The Application model is the main model for metadata for the application.\nName Description id A gobally unique id for the application. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name of the application owner and the second part is the name of the app. versionId The current version of the application. (Currently not in use.) org The short name of the application owner. title A collection of the application title in different languages. validFrom The date and time from when the application can be used to create instances. validTo The data and time for when the application will expire and can no longer be used to create new instances. processId The id of the process model being used by the application. (Currently not in use.) dataTypes A list of all the data types associated with the application. See DataType. partyTypesAllowed A collection of flags that controls what type of instance owners new instances can be created for. See PartyTypesAllowed autoDeleteOnProcessEnd A value indicating whether an instance will be automatically deleted once the process ends. This can be used by highly sensitive applications to force an instance delete instead of sending the instance to the archive. presentationFields A collection of presentation fields. See PresentationField. Currently not in use. dataFields A collection of data fields. See DataField. eFormidling The configuration for the eFormidling integration for the application. See eFormidlingContract. messageBoxConfig A collection of configurations related to the Altinn Message box DataType Data type represents the requirements for data elements. Data types representing a form will have model validation in addition to the requirements defined here.\nName Description id The id of the data type. Unique for the app. description A collection of data type descriptions in different languages. allowedContentTypes A list of Content-Types allowed by the data type. allowedContributers A list of allowed contributors. This can be used to restrict who it is that can work with the data type. appLogic A complex object with information on how a data type is connected to a model. See ApplicationLogic. taskId A reference to a task from the application process. The value indicate that the data type requirements must be fulfilled before the process can move on from the given step in the process. maxSize The maximum allowed size of the data element. maxCount The maximum number of data elements of this type. minCount The minimum required number of elements of this type. grouping The name of a group. This can be used to logically associate a data type to a group. E.g Photos or a text resource key. ApplicationLogic ApplicationLogic holds information about how a data type representing a form is connected to a model.\nName Description autoCreate A value indicating whether a data element will be automatically created once an instance moves into the process step indicated by taskId. classRef The name of the C# class used to represent the form as a model in application logic. schemaRef A reference to the original schema used to define the model. PartyTypesAllowed PartyTypesAllowed contains a set of values indicating the type of owners an instance can have.\nName Description bankruptcyEstate A value indicating that the instance owner can be a bancruptcy estate. organisation A value indicating that the instance owner can be any organisation. person A value indicating that the instance owner can be a person. subUnit A value indicating that the instance owner can be a sub unit. PresentationField PresentationField represents a form field extraction rule. Every time a form is being saved the presentation field rules will be applied and any values from the form will be stored directly on the instance. This can later be used to present instance specific data in places like the portal message box. The purpose is to make it easier to identify a specific instance in a list with many almost identical instances.\nName Description id An id or key to identify the specific rule. path A path to a specific field or property in the form model. dataTypeId The name of the datatype. See DataType. DataField DataField represents a form field extraction rule. Every time a form is being saved the data field rules will be applied and any values from the form will be stored directly on the instance. While PresentationField will have logic applied to it with regards to where and how it\u0026rsquo;s used, the use of data fields is entirely up to the application developer and the application owner. One usage scenario is to provide data fields which can be used for routing to the correct backend system.\nName Description id An id or key to identify the specific rule. path A path to a specific field or property in the form model. dataTypeId The name of the datatype. See DataType. eFormidlingContract This type is used by a feature still in development.\neFormidlingContract holds the configuration of the eFormidling integration for the application. An application configured to enable eFormidling integration in combination with the eFormidiling contract will send a shipment to eFormidling for every instance that is created.\nName Description serviceId The service identifier of the process process The process type to be set on the shipment receiver The receiver of the eFormidling shipment. sendAfterTaskId The id of the last task to be completed before the shipment is sent type The document type of the shipment e.g. arkivmelding typeVersion The version of the document type standard The document standard e.g. urn:no:difi:arkivmelding:xsd::arkivmelding securityLevel The security level to be set on the standard business document dataTypes A list of the dataTypes to be included in the shipment. Data type for both form data and attachments should be listed to be included in the shipment messageBoxConfig MessageBoxConfig holds configurations related to the presentation of instances in the Altinn MessageBox.\nName Description hideSettings The settings related to hiding an instance from the message box hideSettings Only one of the two settings should be used at a time.\nName Description hideAlways A boolean indicating that the instance should always be hidden hideOnTask A list of tasks where the instance should be hidden from the message box Complete example This is a complete app metadata document with data types.\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;versionId\u0026#34;: null, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Bli applikasjonseier\u0026#34; }, \u0026#34;validFrom\u0026#34;: null, \u0026#34;validTo\u0026#34;: null, \u0026#34;processId\u0026#34;: null, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.BliTjenesteeier_M\u0026#34;, \u0026#34;schemaRef\u0026#34;: null }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;grouping\u0026#34;: null }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;description\u0026#34;: null, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;allowedContributers\u0026#34;: null, \u0026#34;appLogic\u0026#34;: null, \u0026#34;taskId\u0026#34;: null, \u0026#34;maxSize\u0026#34;: null, \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0, \u0026#34;grouping\u0026#34;: null } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: true, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: true, \u0026#34;subUnit\u0026#34;: true }, \u0026#34;messageBoxConfig\u0026#34;:{ \u0026#34;hideSettings\u0026#34;:{ \u0026#34;hideOnTask\u0026#34;:[\u0026#34;Task_3\u0026#34;] } }, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: false, \u0026#34;created\u0026#34;: \u0026#34;2020-07-17T08:26:21.5707559Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;sandgrainone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-07-17T08:26:21.5708691Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;sandgrainone\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/",
	"title": "Endringslogg for app nuget pakker",
	"tags": [],
	"description": "Oversikt over endringer introdusert i App Nuget-pakker.",
	"content": "\rv7\rOversikt over endringer introdusert i v7 av Altinn.App.* pakkene og applikasjonsmalen.\nv6\rOversikt over endringer introdusert i v6 av Altinn.App.* pakkene.\nv5\rOversikt over endringer introdusert i v5 av Altinn.App.* pakkene.\nv4\rOversikt over endringer introdusert i v4 av Altinn.App.* pakkene.\nv3\rOversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/",
	"title": "Bidra til utviklingen av Altinn",
	"tags": [],
	"description": "Samarbeid, del og lær. Alt vi gjør er åpen kildekode på GitHub. Vi setter stor pris på dine kommentarer og bidrag!",
	"content": "Du kan bidra til at Altinn blir en så bra løsning som mulig ved å:\nFølge Altinn 3 på Github Du kan følge med på utviklingen i Github og løfte frem oppgaver som interesserer deg ved å gi de en tommel opp (👍). Har du innspill til oppgaven oppfordrer vi til å legge igjen en kommentar. Rapportere eller fikse feil Har du oppdaget en feil som ikke allerede er rapportert setter vi pris på at du oppretter en sak i github. Dersom du har fikset en feil kan du opprette en Pull Request. Ny komponent/funksjonalitet Trenger du en ny komponent eller funksjonalitet i forbindelse med en app du utvikler? Vi setter pris på at behovet først meldes inn til oss, slik at vi kan vurdere om forslaget er i tråd med eksisterende interaksjonsmønster. Vi ser også på om det bør lages en ny felleskomponent, eller om vi kan utvide funksjonaliteten til en eksisterende komponent. Start derfor gjerne med å foreslå en ny komponent så finner vi ut sammen hvem som utvikler komponenten. Foreslå en ny komponent\rOm dere har behov for en komponent eller funksjonalitet som vi ikke tilbyr ønsker vi at behovet blir meldt som en feature request før utviklingen starter.\nUtvikle en komponent\rStart gjerne utviklingen av ny funksjonalitet eller nye komponenter som er godkjent av Altinn. Vi setter pris på om du planlegger arbeidet ditt med oss før du begynner.\nIntro for utviklere\rIntroduksjon\nUtviklingshåndbok\rUtviklingshåndbok for bidrag til kodebasen i Altinn.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/",
	"title": "App brukergrensesnitt",
	"tags": [],
	"description": "Konfigurering av komponenter, layouts, sider, grid, etc.",
	"content": "\rKomponenter\rSider\rHvordan sette opp en app med flere sider, sporvalg, oppsummering eller flere skjema.\nFelter\rHvordan sette opp felter og gruppering.\nStyling\rHvordan styre styling, formatering og grid-layout for en app.\nBilder\rHvordan legge til og endre referanser til bilder.\nTekster\rHvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.\nPDF\rHvordan konfigurere generering av PDF.\nWidgets\rHvordan bruke sammensatte komponenter (widgets).\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/",
	"title": "Design og planlegging",
	"tags": [],
	"description": "For at tjenesten din skal bli best mulig for de som skal bruke den, er det viktig å starte med å fokusere på brukerne og forstå deres brukerbehov i møte med tjenesten din.",
	"content": "Før du begynner utviklingen av tjenesten/applikasjonen din, anbefaler vi å gjennomføre en innsiktsfase, lage en prototype og utføre en brukertest.\nInnsiktsfase\rFørst av alt bør du samle prosjektgruppen og starte med å definere problemet. Hva er det dere skal løse og hvem skal det løses for?\nPrototype\rVed hjelp av Altinns Prototype-kit kan du lage en klikkbar prototype for å definere flyt og innhold i din tjeneste.\nBrukertest\rDet er alltid lurt å brukerteste i flere faser av prosjektet. Gjennom brukertester måler du om det du lager treffer brukernes behov. Det er en god investering å gjøre dette tidlig i prosjektet, slik at du ikke bruker penger på å utvikle en løsning som ikke løser utfordringene.\nRetningslinjer\rVi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/",
	"title": "Felter",
	"tags": [],
	"description": "Hvordan sette opp felter og gruppering.",
	"content": "\rGruppering av felter\rHvordan gruppere felter i skjema.\nInnstillinger for felt\rInnstillinger for tekster knyttet til et felt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/button/",
	"title": "Knapp og lenke",
	"tags": [],
	"description": "Hovedknapp (blå) brukes for å sende brukeren til neste steg.",
	"content": "Retningslinjer: Det skal kun være en hovedknapp per side. Sekundærvalg kan legges til som knapper stylet som lenker. Teksten på knappen skal være tydelig. Som regel fungerer \u0026ldquo;Neste\u0026rdquo; bra, men knappen kan også formuleres som svar på et spørsmål (se eksempel under). På siste steg i skjemaet (innsending) skal hovedknappen være grønn. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul1/",
	"title": "Modul 1",
	"tags": ["apps", "training", "datamodel", "localtest", "texts"],
	"description": "Opprette app i Studio, sette opp lokalt utviklingsmiljø og lokal test",
	"content": "I denne modulen skal du basert på kravene fra Sogndal kommune sette opp førstesiden til applikasjonen for tilflyttere og verifisere at ting ser ut som forventet lokalt.\nTemaer som dekkes i denne modulen:\nOpprette ny applikasjon Legge til datamodell og knytte felter Utvikle en app i lokalt utviklingsmiljø Redigering av tekstressurser Teste applikasjon i lokalt utviklingsmiljø (LocalTest) Oppgaver Vis/skjul innhold\rOpprette ny applikasjon\rOpprett applikasjonen i Altinn Studio med organisasjonen du har tilgang til som eier. Alternativt kan du opprette applikasjonen med deg selv som eier dersom du ikke skal teste den i et testmiljø.\nKrav fra kommunen Applikasjonen må ha et fornuftig navn som gjør det enkelt å finne den igjen blant det store antallet repositories Sogndal kommune har i Altinn Studio.\nDet er ingen foreløpige planer om årlige revisjoner av appen, så man trenger ikke ta hensyn til årstall i navnet.\nDet er et ønske om at et eller flere av ordene \u0026ldquo;tilflytter\u0026rdquo; og \u0026ldquo;Sogndal\u0026rdquo; er med i navnet.\nNyttig dokumentasjon Opprette app i Altinn Studio Vis/skjul innhold\rLaste opp datamodell\rSogndal kommune har opprettet en datamodell som representerer data de ønsker å samle inn fra fremtidige innbyggere.\nSom applikasjonsutvikler vil man i noen tilfeller måtte opprette datamodell for en tjeneste selv. Da vil man kunne benytte seg av datamodelleringsverktøyet i Altinn Studio (lanseres våren 2022), eller ta utgangspunkt i en eksisterende datamodell og redigere den i f.eks. Visual Studio eller et selvvalgt tekstredigeringsprogram.\rLast ned xsd-filen, åpne den i et tekstredigeringsprogram og ta en nærmere titt på innholdet. Last opp datamodellen i Altinn Studio Push endringene master og ta en nærmere titt på filene i mappen App/models Forståelsessjekk Hvilken data er det tjenesteeier ønsker å samle inn her? Hvilken effekt har \u0026lt;minOccurs\u0026gt; i datamodellen? Du vil se at feltet har ulik verdi for Innflytter.Fornavn og Innflytter.Mellomnavn. Hvilke andre egenskaper er satt på feltet Innflytter.Mellomnavn? Det er blitt generert en .C#, .metadata.json og .schema.json fil i tillegg til .xsd filen som du lastet opp. Hva er sammenhengen mellom disse filene? Enkelte restriksjoner fra datamodellen overføres ikke til C#-filen, hvilke? Det er og lagt til nye egenskaper, hvilke? Nyttig dokumentasjon Laste opp datamodell i Altinn Studio Beskrivelse av indikatorer i XSD Vis/skjul innhold\rRedigere tekster\rFor at tjenesten skal være brukervennlig og mulig å benytte for de som sitter med synshemninger er det viktig at alle komponenter har gode og beskrivende overskrifter og beskrivelser. Vi ønsker nå at dere legger til tekster som skal brukes for hvert datafelt.\nDet er mulig å koble tekster til komponenter både i Altinn Studio og lokalt.\nMERK: Visningsnavn for applikasjonen må endres både i App/config/applicationMetadata.json og i tekstressursene.\rKrav fra kommunen Alle inputfelter skal ha forklarende labels som beskriver hva som skal fylles inn. Applikasjonen må være tilgjengelig både på bokmål, nynorsk og engelsk. I en første versjon er det tilstrekkelig at kun ett av disse språkene støttes. Det er viktig at applikasjonens visningsnavn klinger godt og er beskrivende for tjenesten. Nyttig dokumentasjon Redigere applikasjonstekster Formatering av tekster ISO 639-1 standard Forståelsessjekk I Altinn i dag støtter vi tre skriftspråk: Bokmål, nynorsk og engelsk.\nHvordan får du inn engelsk språkstøtte i applikasjonen? Hvis vi en dag skal støtte ukrainsk, hvilken språkkode vil du da måtte annotere filen med? Hvis en tekstnøkkel refert til i FormLayout.json ikke finnes i tekstressursene, hva vil vises da? Vis/skjul innhold\rSette opp komponenter\rFeltene som skal fylles ut på en skjemaside kan settes opp ved hjelp av \u0026ldquo;drag and drop\u0026rdquo; i Altinn Studio eller manuelt i json-filen som beskriver utseendet til en skjemaside FormLayout.json.\nBasert på kravene fra kommunen klarer du å sette opp den første skjemasiden i Altinn Studio?\nKrav fra kommunen Vil ha navn og alder på personen som er tilflytter Fornavn Mellomnavn (valgfritt) Etternavn Alder Vil ha adressen på personen som er tilflytter Gateadresse Postnummer Poststed Vil ha kontaktinformasjon på personen som er tilflytter Epost Telefon Nyttig dokumentasjon Hvordan bygge et skjema med UI editor i Altinn Studio Tilgjengelige komponenter i Altinn Studio Retningslinjer for bruk av komponenter Forståelsessjekk I applikasjonsrepoet ditt finner du FormLayout.json i mappen App/ui/layouts. JSON-filen beskriver skjemasiden du har satt opp i Altinn Studio, gitt at du har pushet endringene dine til master.\nFinner du igjen komponenten som er koblet til e-post-feltet? Hvilken endring kreves i denne filen dersom e-post-feltet ikke lenger skal være påkrevd? Ved å endre én linje i FormLayout.json er det mulig å endre komponenten knyttet til mellomnavn til et inndatafelt for et langt svar. Hvilken endring kreves? Vis/skjul innhold\rLaste ned applikasjonen lokalt\rEnkelte applikasjonsfunksjoner er det ikke støtte for å utvikle i Altinn Studio. Disse må utvikles i et lokalt utviklingsmiljø.\nSelve utviklingen kan gjøres i ditt foretrukne utviklerverktøy, men trenger du en anbefaling, er Visual Studio Code et godt alternativ.\nNyttig dokumentasjon Hvordan klone applikasjon til lokalt utviklingsmiljø Hvordan synkronisere endringer i lokalt utviklingsmiljø Vis/skjul innhold\rKjøre appen i localtest\rVed hjelp av en mock som kan spinnes opp lokalt av Altinn Plattform er det mulig å gjøre enkel testing og verifikasjon av applikasjonen i det lokale utviklingsmiljøet.\nI denne oppgaven skal du få kjørt opp applikasjonen lokalt med støtte fra LocalTest. Når du har fått appen opp og kjøre og logget inn med en testbruker, bør du ha et resultat som likner dette:\nVidere vil du ønske å teste endringene dine fortløpende i localtest.\nVed endringer knyttet til formLayout og andre json-filer holder det med en refresh (F5) i nettleser. Ved endringer i forhåndsutfylling vil man måtte instansiere applikasjonen på nytt. Ved endringer i cs-filer må applikasjonen stoppes og startes på nytt. Alternativt kan du benytte deg av dotnet run watch når du starter applikasjonen for hot reload. Nyttig dokumentasjon Hvordan sette opp LocalTest Debugging av applikasjon Tilgjengelig testbrukere i LocalTest Oppsummering I denne modulen har du opprettet en applikasjon i Altinn Studio, lastet opp en datamodell og satt opp en skjemaside som kobler komponenter til noen av feltene i datamodellen. Videre har du klonet repoet lokalt for å kunne videre applikasjonen i ditt lokale utvilkingsmiljø.\nTjenesten skal kunne kjøres opp på din lokale maskin med local test og du skal kunne fylle inn feltene.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelige i Altinn Studio når du er fornøyd.\nLøsningsforslag Dersom du ikke har fått til alle stegene, har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul2/",
	"title": "Modul 2",
	"tags": ["apps", "training", "prefill", "sporvalg"],
	"description": "Legge til flere sider, sporvalg og forhåndsutfylling",
	"content": "I denne modulen skal du videreutvikle applikasjonen du laget i modul 1 for å oppfylle flere av kravene fra Sogndal kommune.\nTemaer som dekkes i denne modulen:\nFlere sider Bildekomponent Sporvalg Forhåndsutfylling Oppgaver Vis/skjul innhold\rLegge til infoside\rFor skjemaer der det samles inn eller gis mye informasjon vil det forbedre brukeropplevelsen dersom man deler applikasjonen opp i flere sider.\nLa oss se nærmere på hvordan man kan opprette en ny side i applikasjonen som vises før brukeren kommer til første datainnsamlingsside som ble laget i modul 1.\nFor å redigere ulike skjemasider i Altinn Studio må du:\nLogge inn i Altinn Studio Finne applikasjonen din på dashboardet og trykke Rediger app Navigere til Lage-fanen Til høyre finner du området for administrasjon av skjemasider. Opprettelse og administrasjon av flere sider kan enkelt gjøres i Altinn Studio, men dersom du ønsker å gjøre det manuelt kan dokumentasjonen her være til hjelp.\rDa er det eneste som gjenstår å sette seg inn i kommunens krav til infosiden og komme i gang med utviklingen. Lykke til!\nKrav fra kommunen I og med at det skal samles inn en god del data i denne tjenesten, er det viktig for Sogndal kommune at det tydelig kommuniseres hvem skjemaet er ment for og hva som vil gjøres med dataen som samles inn. Noen i kommunen har opprettet en skisse av informasjonssiden.\nFølgende er ønskelig at reflekteres i applikasjonen:\nplassering av bilder tekststørrelser formatering av tekst Skisse på informasjonsside\nNyttig dokumentasjon Formatering av tekst i en applikasjon Hvordan legge til bilder i en applikasjon Sidestilte komponenter Filoppsett ved flere sider Administrere rekkefølge på flere sider Forståelsessjekk Hvilken fil i applikasjonsrepoet er det som må justeres på dersom du manuelt ønsker å endre siderekkefølgen på eksisterende sider? Hvis du ønsker å gi en side et annet navn, men ikke har Altinn Studio tilgjengelig, hvilke filer må oppdateres med det nye filnavnet? Hvordan oppnår du at teksten bryter dersom tekststrengen ikke er lang nok til å naturlig brytes? Vis/skjul innhold\rAlternativ arbeidsflyt\rI mange tilfeller er det ikke aktuelt å svare på alle spørsmål i et skjema, kanskje fordi svaret sier seg selv, eller fordi det ikke er relevant basert på noe man har svart tidligere i skjemaet. Da kan sporvalg være en god løsning.\nVed hjelp av sporvalg kan man styre hvilke sider i en applikasjon som er synlige for brukeren.\nI denne oppgaven skal du sette opp sporvalg i applikasjonen basert på kravene fra Sogndal kommune.\nKrav fra kommunen En bruker som ikke oppfyller kravene for skjemaet skal stoppes så tidlig som mulig i arbeidsflyten.\nPå infosiden er det ønskelig at brukeren skal oppgi om skjemaet gjelder dem eller ikke.\nHvordan dette gjøres er fritt fram, og feltet Innflytter.KanBrukeSkjema i datamodellen er mulig å benytte til dette formålet.\nBasert på svaret skal brukeren sendes videre til Spor 1 eller Spor 2.\nSpor 1 Brukeren har ikke svart bekreftende på at skjemaet gjelder deres situasjon\nBruker skal sendes til en side med følgende tekst:\nDette skjemaet er ikke for deg.\rSe en oversikt over andre tilbud i kommunen her. Linje 2 i teksten skal være en hyperlenke som peker på https://www.sogndal.kommune.no/\nSpor 2 Brukeren har svart bekreftende på at skjemaet gjelder deres situasjon.\nBrukeren sendes videre til datainnsamlingssidene.\nNyttig dokumentasjon Dynamiske uttrykk Hvordan vise/skjule hele sider Formatering av tekst Forståelsessjekk Hvis en bruker går tilbake og endrer svaret sitt på infosiden, får den da opp datainnsamlingssidene? Dersom man har sporvalg på et senere tidspunkt i en arbeidsflyt og en sluttbruker endrer et valg, hva skjer med skjemdataen man tidligere har fylt ut, dersom siden skjules for sluttbrukeren? Vis/skjul innhold\rForhåndsutfylling av personopplysninger\rEn av fordelene til Altinn er at man allerede har metadata om både personer og virksomheter tilgjengelig. Ved hjelp av forhåndsutfylling kan man hente ned data om brukerne og presentere den i utfylte felter, slik at de slipper å fylle dem ut selv. Typiske forhåndsutfyllingsverdier vil være navn, adresse, e-post osv.\nDersom dataen er tilgjengelig i en av Altinns forhåndsutfyllingskilder, kan dette konfigureres mot et felt i datamodellen og automatisk populeres når skjemaet opprettes. Dersom man har andre behov for forhåndsutfylling, kan dette løses med kode i applikasjonen.\nI denne oppgaven flyttes fokus tilbake til den første datainnsamlingssiden, og målet er å forhåndsutfylle personopplysninger om sluttbrukeren for å spare brukeren for tid.\nKrav fra kommunen Følgende verdier skal forhåndsutfylles for brukeren:\nFornavn: Innflytter.Fornavn Mellomnavn: Innflytter.Mellomnavn Etternavn: Innflytter.Etternavn E-post: Innflytter.Kontaktinformasjon.Epost Telefonnummer: Innflytter.Kontaktinformasjon.Telefonnummer Alder: Innflytter.Alder Det skal ikke være mulig å endre forhåndsutfylt navn og alder\nDet skal være mulig å endre forhåndsutfylt e-post og telefonnummer\nNyttig dokumentasjon Tilgjengelige forhåndsutfyllingskilder Forhåndsutfylling fra nasjonale registre og brukerprofil Egendefinert forhåndsutfylling Beskrivelse av InstanceOwner-objektet - Her finner man personnummeret. Vær oppmerksom på at egenskapene refereres til med store forbokstaver i koden, ikke med små som i denne oversikten. Kodehjelp: Beregning av alder fra personnummer Denne funksjonen kan brukes til å beregne alder fra personnummeret. Det er viktig å legge til using System; øverst i filen for at den skal fungere.\nprivate static int CalculateAge(string sosialSecNumber) { int MAX_D_NUMBER = 71; int MIN_D_NUMBER = 41; int MAX_TEST_NUMBER = 92; int MIN_TEST_NUMBER = 81; int START_D_NUMBER = 40; int START_TEST_NUMBER = 80; string stringDay = sosialSecNumber.Substring(0, 2); string stringMonth = sosialSecNumber.Substring(2, 2); string stringYear = sosialSecNumber.Substring(4, 2); string stringIndivid = sosialSecNumber.Substring(6, 3); int day = int.Parse(stringDay); int month = int.Parse(stringMonth); int year = int.Parse(stringYear); int individ = int.Parse(stringIndivid); // Get day if D-number if (MAX_D_NUMBER \u0026gt;= day \u0026amp;\u0026amp; MIN_D_NUMBER \u0026lt;= day) { day -= START_D_NUMBER; } // Get month if TestUser-number if (MAX_TEST_NUMBER \u0026gt;= month \u0026amp;\u0026amp; MIN_TEST_NUMBER \u0026lt;= month) { month -= START_TEST_NUMBER; } // find century if (year \u0026gt; 54 \u0026amp;\u0026amp; (individ \u0026gt;= 500 \u0026amp;\u0026amp; individ \u0026lt; 750)) { // 1855-1899 year += 1800; } else if (year \u0026gt; 39 \u0026amp;\u0026amp; (individ \u0026gt;= 900 \u0026amp;\u0026amp; individ \u0026lt; 1000)) { // 1940-1999 year += 1900; } else if (year \u0026lt; 40 \u0026amp;\u0026amp; (individ \u0026gt;= 500 \u0026amp;\u0026amp; individ \u0026lt; 1000)) { // 2000-2039 year += 2000; } else { year += 1900; } // calculate age int age = DateTime.Now.Year - year; if (DateTime.Now.Month \u0026lt; month) { age -= 1; } else if (DateTime.Now.Month == month) { if (DateTime.Now.Day \u0026lt; day) { age -= 1; } } return age; } Forståelsessjekk Er det mulig å endre en forhåndsutfylt verdi når den først er satt? Hvordan kan man hindre at en forhåndsutfylt verdi endres av sluttbrukeren? Ikke alle norske innbyggere har et fødselsnummer, noen får tildelt et D-nummer. Hvordan må koden din justeres for å ta hensyn til dette dersom alder skal baseres på et fødselsnummer eller D-nummer som sluttbruker selv taster inn? Oppsummering I denne modulen har du utvidet applikasjonen din med mer funksjonalitet i form av å legge til flere sider, sette opp sporvalg for å styre brukerflyten og sette opp forhåndsutfylling av skjemafelter både med tilgjengelige datakilder i Altinn og egendefinert kode.\nTjenesten skal kunne kjøres opp på din lokale maskin med lokal test og du skal kunne teste begge brukerflytene og bekrefte at riktige felter blir forhåndsutfylt.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelige i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul3/",
	"title": "Modul 3",
	"tags": ["apps", "training", "build", "deploy", "test"],
	"description": "Bygg og deploy applikasjon til testmiljø",
	"content": "Denne modulen krever at du er medlem av en organisasjon som har et etablert testmiljø for Altinn Apps. Dersom dette ikke er tilfellet, går du bare videre til neste modul.\rI denne modulen skal du bygge og deploye applikasjonen til Altinns testmiljø (TT02) og verifisere at alt fungerer som forventet også der.\nTemaer som dekkes i denne modulen:\nSette egendefinerte krav for ressursbruk Bygg av applikasjon Deploy av applikasjon Oppgaver Vis/skjul innhold\rSette egendefinerte krav for ressursbruk\rAlle applikasjoner kommer med et standardoppsett for ressursbruk og skalering i applikasjonsclusteret. Det oppsettet er det mulig å overstyre dersom applikasjonen din skulle ha andre behov.\nMan kan endre antall replikas (instanser av applikasjonen som kjører samtidig) Man kan endre reglene for hvor tidlig eller sent applikasjonen skal skalere antall instanser ut ifra CPU eller minnebruk Man kan endre hvor mye ressurser som skal dedikeres til applikasjonens instanser i clusteret Ved å overstyre disse verdiene kan man for mindre applikasjoner spare kostnader, og for større applikasjoner sørge for at de har en optimal ytelse med alle nødvendige ressurser tilgjengelig.\nFor denne testapplikasjonen ønsker vi at du skal skalere ned resursbruken til det minimale.\nSkalering: replicaCount: 1\nRessursbruk: Sett requests til cpu: 50m og memory: 128Mi\nAlle endringer knyttet til skalering og ressursbruk gjøres i deployment/values.yaml-filen\rNyttig dokumentasjon Sette egendefinerte regler for skalering Sette egendefinerte grenser for ressursbruk Vis/skjul innhold\rBygge applikasjon\rNår man refererer til å bygge en applikasjon i Altinn Studio, betyr dette å opprette en versjon av applikasjonens nåværende tilstand som kan deployes til ett eller flere miljø.\nOpprett et nytt bygg for applikasjonen med versjonsnr 0.0.1 og legg til en beskrivende kommentar om hva versjonen inneholder.\nNyttig dokumentasjon Bygge app i Altinn Studio Vis/skjul innhold\rDeploye applikasjon\rVed å deploye en applikasjon til testmiljø vil man kunne teste alle integrasjoner. I tillegg benyttes TT02 ofte til å verifisere at en applikasjon oppfører seg som forventet før man deployer til produksjon.\nFor å kunne deploye en applikasjon til TT02, må organisasjonen som eier applikasjonen ha et apps-cluster i testmiljøet. I tillegg trenger utvikleren som skal deplopye applikasjonen rollen Deploy-TT02 for organisasjonen i Altinn Studio.\rDeploy applikasjonen din til TT02.\nNyttig dokumentasjon Deploye app til testmiljø Tilgangsstyring for organisasjon i Altinn Studio Forståelsessjekk Er det mulig å ha to versjoner av en applikasjon i TT02 samtidig? Hva skjer hvis man deployer samme versjon av applikasjonen til miljøet en gang til? Vil applikasjonen være tilgjengelig umiddelbart etter deploy? Er det mulig å fjerne en applikasjon fra miljøet hvis den først er blitt deployet? Vis/skjul innhold\rTeste applikasjonen i TT02\rPå deploysiden finner du direktelenken til applikasjonen din. Den er på formatet {org}.apps.tt02.altinn.no/{org}/{app}.\nMed mindre du er logget inn med en bruker fra før av, vil denne lenken ta deg til innloggingssiden til Altinn. Organisasjonen din bør ha tilgang på et sett med testbrukere, benytt en av disse for å logge inn.\nFor interne personer i Digdir: Benytt deg av en av testbruker som du finner i testdatasettet og logg inn.\nTest de ulike sporvalgene og skjemasidene for å bekrefte at de oppfører seg som forventet.\nOppsummering I denne boken har du bygget og deployet applikasjonen din til TT02, logget inn i Altinn med en testbruker, og testet applikasjonen din.\nLøsningsforslag Dersom du ikke har fått til alle stegene har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul4/",
	"title": "Modul 4",
	"tags": ["apps", "training", "options", "kodelister", "dynamikk"],
	"description": "Legge til kodelister manuelt, programatisk og dynamisk",
	"content": "I denne modulen skal du utvide applikasjonen du har laget i foregående moduler for å støtte enda fler av kravene til Sogndal kommune.\nTemaer som dekkes i denne modulen:\nKodelister/Options Dynamikk Oppgaver Vis/skjul innhold\rInnsamling av arbeidsopplysninger\rI mange applikasjoner er det behov for å gi brukeren et sett med svaralternativer for et datafelt. Svaralternativene refereres til som kodelister eller options.\nI Altinn Studio er dette støttet i form av radioknapper, avkrysningsbokser og nedtrekkslister.\nDet er tre måter å sette opp kodelister i Altinn i dag\nDirekte på komponenten via Altinn Studio eller manuelt i FormLayout.json* I en statisk json-fil som referes til i komponenten Programmatisk i applikasjonslogikken * kun tilgjengelig på radioknapp og avkrysningsboks\nI denne oppgaven skal du få prøve deg på alle tre måtene å sette opp en kodeliste på.\nSogndal kommune ønsker å samle inn opplysninger om tilflytterens arbeidsituasjon. Blant dataen de ønsker å samle inn er hvilken sektor og bransje tilflytter jobber i, og hvor mange år tilflytter har vært yrkesaktiv.\nI Altinn Studio Opprett en ny skjemaside for å samle inn data om arbeidsforhold\nSett opp en radioknapp-komponent for Sektor opprett svaralternativene Offentlig og Privat manuelt.\nSett opp en avkrysningsboks for Bransje. Velg Kodeliste som metode for å legge til avkrysningsboker og legg inn Kodeliste ID industry.\nResten av oppsettet for denne komponenten gjøres lokalt.\nSett opp en nedrekksliste for År i arbeidslivet. Legg inn Kodeliste ID years-in-work-force.\nResten av oppsettet for denne komponenten gjøres lokalt.\nCommit og Push endringene dine til master, og Pull endringene i ditt lokale utviklingsmiljø.\nI lokalt utviklingsmiljø Sogndal kommune har opprettet en kodeliste for bransjer. Last ned filen og plasser denne på rett sted i repoet.\nSett opp verdiene i kodelisten for År i arbeidslivet direkte i en ny C#-klasse.\nSvaralternativer:\nLabel Dataverdi 0 - 5 år 0-5 5 - 10 år 5-10 10 - 20 år 10-20 20+ år 20+ Verifiser at alle kodelister fungerer som forventet.\nNyttig dokumentasjon Hvordan sette opp statiske kodelister Sikrede dynamiske kodelister Forståelsessjekk Hva er forskjellen på statiske og dynamiske svaralternativer? Hva vil være et bruksområde for sikrede, dynamiske svaralternativer? Vis/skjul innhold\rDifferensiert datagrunnlag for offentlig og privat sektor\rI noen tilfeller kan verdiene som skal vises fram i en kodeliste være knyttet til et annet felt i skjemaet.\nSogndal kommune ønsker at listen av bransjer å velge mellom skal spisses til hvilken sektor man jobber i.\nLes gjennom kravene til kommunen for å se om du kan hjelpe dem.\nKrav fra kommunen Vi ønsker at brukerne skal ha et ulikt sett med svaralternativer for bransjevalget basert på hvilken sektor de har krysset av for.\nPrivat sektor: Standardlisten med bransjer Offentlig sektor: Stat og Kommune Nyttig dokumentasjon Hvordan sende med spørringsparametre ved henting av kodelister Hvordan sette opp dynamiske kodelister Forståelsessjekk Om en kodeliste er satt opp med en mapping mot datamodellen, hva skjer når det aktuelle feltet endrer verdi? Hva skjer med valgt verdi på et felt som er koblet til en kodeliste som hentes på nytt fra serversiden? Vis/skjul innhold\rSkreddersydd tilbud for IT-kompetanse\rKrav fra kommunen Vi ønsker at dersom brukeren velger IKT (data/it) under bransje at det vises en tekst med en lenke til en av våre stillingsutlysninger.\nUnder bransje-valget skal følgende tekst presenteres:\nVi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her. Linje 2 i teksten skal være en hyperlenke som peker på https://sogndal.easycruit.com/index.html.\nTekst og lenke skal kun vises om man har valgt IKT (data/it). I alle andre tilfeller skal dette være skjult.\nNyttig dokumentasjon Legge til funksjoner for regler eller dynamikk Eksempler på bruk av dynamikk i skjema Forståelsessjekk Hvis du legger til en ny funksjon i RuleHandlerHelper, hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Hvis du legger til en ny funksjon i RuleHandlerObject, hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Hva er sammenhengen mellom funksjoner definert i RuleHandlerObject og filen RuleConfiguration.json? Oppsummering I denne modulen har du satt opp nedtrekksliste, radioknapp og avkrysningsbokser og lagt inn verdier for disse komponentene manuelt, programmatisk og dynamisk.\nTjenesten skal kunne kjøres opp på din lokale maskin med lokal test og du skal kunne validere at komponentene presenterer forventede dataverdier.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelig i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene, har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul5/",
	"title": "Modul 5",
	"tags": ["apps", "training", "process", "policy", "autorisasjon", "confirmation", "bekreftelsessteg", "validering"],
	"description": "Legge til bekreftelsessteg",
	"content": "I denne modulen skal du legge til et prosessteg i applikasjonen.\nTemaer som dekkes i denne modulen:\nProsess Bekreftelsessteg Autorisasjonsregler Validering Overstyre standardtekster Oppgaver Vis/skjul innhold\rUtvide prosess med et bekreftelsessteg\rEn Altinn-app har en prosessflyt som beskriver de ulike stegene i flyten. Standardflyten for en nyopprettet applikasjon består av én oppgave og ett utfyllingssteg.\nDin oppgave er å utvide standardprosessflyten med et bekreftelsessteg som illustrert nedenfor. Bekreftelsessiden blir lagt til automatisk når man legger til dette i BPMN-filen.\nStandard prosessflyter er tilgjengelige på GitHub. Finner du den som passer til flyten vi ønsker å oppnå her?\nHar du lyst på en ekstra utfordring, kan du redigere prosessflyten manuelt eller i et BPMN-redigeringsverktøy, og heller bruke malen på prosessflyt med data og bekreftelsessteg som fasit.\nKrav fra kommunen På dette punktet i arbeidsflyten skal brukeren kunne:\nSe over dataen som er utfylt Avslutte arbeidsflyten uten å sende inn skjemaet Avslutte arbeidsflyten og sende inn skjemaet Nyttig dokumentasjon Tilgjengelige prosessteg i en Altinn App Hvordan endre prosessflyten til en applikasjon Online BPMN editor BPMN standard Forståelsessjekk Hvilke Altinn-spesifikke egenskaper er satt på hver prosessoppgave? Hvilke begrensninger vil et eksternt BPMN-redigeringsverktøy ha når man skal redigere prosessbeskrivelsen til en Altinn-app? Vil prosessflyten kunne gå begge veier? Fra utfylling til bekreftelse og fra bekreftelse til utfylling? Vis/skjul innhold\rLegge til autorisasjonsregler for bekreftelsessteget\rPolicy-filen til applikasjonen din er tilpasset standard prosessflyt. Oppdater policyfilen så den har autorisasjonsregler som dekker det nye prosessteget.\nKrav fra kommunen Det skal være samme rollekrav for å fylle ut og bekrefte en instans. Nyttig dokumentasjon Regelbibliotek Alle roller i Altinn Forståelsessjekk Hva vil skje når prosessflyten går videre til bekreftelsessteget uten at autoriasjonsreglene er blitt oppdatert? Hva skjer dersom du ikke spesifiserer hvilke roller som har lov til å utføre en aksjon i en autorisasjonsregel? Vis/skjul innhold\rValidering av innsender\rKrav fra kommunen Det skal kun være mulig for brukeren som eier instansen å sende inn skjemaet, selv om andre måtte inneha de nødendige rollene Nyttig dokumentasjon Egendefinert validering Forståelsessjekk Hvilken endring ville du foreslått for kunden for å kunne oppfylle dette kravet uten å legge inn den egendefinerte valideringen på dette steget? Vis/skjul innhold\rOverstyre standardtekster for bekreftelsesside\rKrav fra kommunen Vi ønsker at brukeren skal presenteres med følgende tekst før innsending:\nDu er nå klar for å sende inn melding om tilflytting til Sogndal kommune.\rVed å sende inn dette skjemaet samtykker du til at dataen du har fylt ut kan lagres og benyttes til å tilpasse kommunens tilbud til deg de neste 18 månedene.\rFør du sender inn vil vi anbefale å se over svarene dine. Du kan ikke endre svarene etter at du har sendt inn. Nyttig dokumentasjon Tilpasning av bekreftelsessiden Oppsummering I denne modulen har du utvidet applikasjonen din med et bekreftelsessteg, tilpasset visningen, og lagt til validering og autorisasjonsregler knyttet til prosessteget.\nTjenesten skal kunne kjøres opp på din lokale maskin med lokal test og du skal kunne teste det nye prosessteget og bekrefte at visningen ser ut som ønsket.\nHusk å pushe de lokale endringene dine, så de blir tilgjengelige i Altinn Studio når du er fornøyd\nLøsningsforslag Dersom du ikke har fått til alle stegene, har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul6/",
	"title": "Modul 6",
	"tags": ["apps", "training", "repeterende grupper", "validering", "dataprosessering", "konsumere API"],
	"description": "Utvidelse av skjema med repeterende gruppe",
	"content": "I denne modulen skal du utvide applikasjonen du har laget i foregående moduler for å støtte mer av funksjonaliteten som Sogndal kommune ønsker.\nTemaer som dekkes i denne modulen:\nRepeterende grupper Validering Dataprosessering Oppgaver Vis/skjul innhold\rRepeterende grupper\rKrav fra kommunen For å kunne skreddersy et best mulig tilbud til nye innflyttere ønsker vi oss en oversikt over tidligere bosteder til innflytteren.\nPå datasiden ønsker vi at det legges opp til at brukeren kan fylle inn tidligere bosteder. Tidligere bosteder skal inneholde følgende felter:\nGateadresse Postnummer Poststed Det skal være mulig å legge inn opptill 10 tidligere bosteder.\nNyttig dokumentasjon Oppsett for gruppering av felter Oppsett for repeterende grupper Forståelsessjekk Hvilket felt i datamodellen er det som bestemmer om et element er repeterende? Hvor mange repetisjoner er tillatt for feltet TidligereBosteder? Vis/skjul innhold\rValidering\rKrav fra kommunen Grunnet en personlig vendetta blant en av Sogndal kommunes ansatte ønsker vi at om innflytter fyller inn postnummer 4619 som et av tidligere bosteder, skal denne IKKE få lov til å flytte inn i Sogndal. Her ønsker vi at det skal dukke opp en feilmelding på det aktuelle feltet med følgende tekst:\nDu er ikke velkommen til vår kommune. Beklager! Nyttig dokumentasjon Serverside valideringer Hvordan legge til egendefinert validering Enkeltfeltvalideringer Forståelsessjekk Når kjøres valideringer serverside? Hvorfor burde valideringer som legges til på klientsiden også dupliseres på serversiden? Vis/skjul innhold\rDataprosessering\rKrav fra kommunen En av kommunens databehandlere har sett seg lei av å manuelt rette opp i en gateadresse som ofte blir skrevet feil av innflyttere. Vi ønsker derfor å programmatisk fikse opp i dette under utfyllingen av appen.\nOm sluttbruker fyller inn Sesame Street 1 i feltet Innflytter.Adresse.Gateadresse skal dette automatisk rettes til Sesamsgate 1. I alle andre tilfeller skal feltet forbli urørt.\nNyttig dokumentasjon Dataprosessering Kalkulering Forståelsessjekk Når blir dataprosessering kjørt? Hva skiller ProcessDataWrite og ProcessDataRead? Hva er forskjellen på DataProcessing og Calculations? Oppsummering I denne modulen har du sett på repeterende grupper og hvordan dette konfigureres som en del av brukergrensesnittet. Vi har også sett på hvordan man setter opp custom valideringer i backend for caser som ikke lar seg definere som en del av restriksjoner i datamodellen. Til slutt har vi sett på hvordan man kan sette opp dataprosessering som muliggjør manipulering av data runtime.\nLøsningsforslag Dersom du ikke har fått til alle stegene, har vi et løsningsforslag som du kan hente inspirasjon fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/modul7/",
	"title": "Modul 7",
	"tags": ["apps", "training"],
	"description": "Frittstående utvidelser av appen",
	"content": "MERK: Denne modulen er fortsatt under utvikling. Ta en titt innom på et senere tidspunkt så er den nok blitt enda bedre!\rI denne modulen er det en samling med frittstående utvidelser av applikasjonen. De trenger ikke å løses i gitt rekkefølge.\nTemaer som dekkes i denne modulen:\nOppsummmeringsside Stateless applikasjon Variabler i tekst Bruk av eksternt API Konfigurasjon av meldingsboks Presentasjonstekster Oppgaver Vis/skjul innhold\rOppsummeringsside\rKrav fra kommunen Sogndal kommune opplever at enkelte innsendinger inneholder feilopplysninger og skrivefeil som skaper unødig arbeid for saksbehandlere. For å unngå at personer sender inn feil informasjon, ønsker kommunen at brukeren presenteres for en oppsummmeringsside med informasjonen som vedkommende har oppgitt.\nSogndal kommune ønsker at man benytter kategoriene Personalia om brukerens personinformasjon, og Arbeid om svarene gitt på brukerens arbeidshistorikk.\nNyttig dokumentasjon Hvordan sette opp visning av oppsummering av utfylt skjema Kategorier i oppsummering Forståelsessjekk Hvorfor burde oppsummeringssiden ignoreres fra PDF-genereringen? Vis/skjul innhold\rStateless førsteside\rKrav fra kommunen Sogndal kommune har oppdaget at det er en del trafikk fra personer som ikke møter kriteriene i applikasjonen. For hver av disse brukerne blir det lagret en instans i databasen. Dette skaper unødige utgifter.\nSogndal kommune ønsker derfor at informasjonssiden vises som en \u0026ldquo;stateless\u0026rdquo;-del av applikasjonen, og at man derfra kan velge å starte en instans om man møter kriteriene.\nNyttig dokumentasjon Introduksjon til stateless applikasjoner Konfigurasjon av stateless applikasjoner Starte instans fra stateless skjema Forståelsessjekk Hva lagres av data for stateless applikasjoner? Vis/skjul innhold\rVariabler i tekst\rKrav fra kommunen IT-kompetanse er svært ettertraktet. I Modul 4 satt vi opp et skreddersydd tilbud til de med IT-kompetanse.\nSogndal kommune har sett på tallene og ser at det genererer for lite trafikk til stillingsutlysningene. For å prøve å forbedre dette ønsker vi at tilbudet blir enda litt mer skreddersydd.\nVi ønsker at den originale teksten;\nVi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her. nå skal bli mer personlig med brukerens navn. Teksten vi nå ønsker oss er:\nHei, {innsenders navn}! Vi ser at du besitter kompetanse vi trenger i kommunen.\rSe en oversikt over våre ledige stillinger her. Siste linje i teksten skal fortsatt være en lenke til stillingsutlysningene.\nNyttig dokumentasjon Variabler i tekster Forståelsessjekk Hva vises som en del av teksten om den aktuelle variabelen ikke har noen verdi i datamodellen? Vis/skjul innhold\rEksternt API\rI noen tilfeller vil man måtte ta i bruk eksterne APIer for å dekke alle behovene til en applikasjon. Dette kan være for å berike nedtrekkslister eller å presentere data til brukeren basert på oppgitt informasjon.\nI denne oppgaven skal du implementere en klient som integrerer seg mot Bring sine APIer for å berike adressen som sluttbruker oppgir med et poststed basert på postnummer.\nAPIet som skal benyttes er et postnummeroppslag tilgjengeliggjort av Bring. Test det gjerne i en nettleser med ulike postnumre.\nGET\rhttps://fraktguide.bring.no/fraktguide/api/postalCode.json?country=no\u0026amp;pnr={postnummer} Krav fra kommunen Adresseinformasjonen skal samles inn via standard inndatakomponenter og ikke Altinns adressekomponent Poststed skal automatisk fylles ut for sluttbruker når postnummer er oppgitt Poststed skal det ikke være mulig å redigere Antall kall til Bring sitt API skal begrenses til maksimalt én gang om dagen per postnummer Nyttig dokumentasjon Konsumering av eksterne API\nForståelsessjekk Med en memorycache, hvor mange ganger vil man maksimalt gjøre et API-kall i løpet av et døgn dersom applikasjonen kjører med tre replikas? Vis/skjul innhold\rVise og skjule elementer i meldingsboks\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk Vis/skjul innhold\rPresentasjonstekst\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk Vis/skjul innhold\rEvents\rKrav fra kommunen Nyttig dokumentasjon Forståelsessjekk "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/tracks/",
	"title": "Sporvalg",
	"tags": [],
	"description": "Hvordan legge til dynamisk sporvalg i app",
	"content": "Dynamisk sporvalg i en applikasjon kan være nyttig dersom man ønsker å vise og/eller skjule enkelte sider basert input fra sluttbruker på forutgående deler av skjemaet.\n⚠️ Sporvalg støttes fortsatt, men på sikt blir funksjonaliteten fjernet. Skjuling av hele sider støttes nå fortrinnsvis med dynamiske uttrykk (se hvordan sider vises/skjules her).\nTrigge kalkulering av sporvalg fra frontend Appen vil gjøre et initielt kall for å kalkulere rekkefølgen ved innlasting. For å trigge kalkuleringingen av sporvalg på sidebytte må man legge inn dette som en trigger på den aktuelle navigasjons-komponenten man ønsker. Dette gjøres ved å legge til calculatePageOrder som en del av triggers. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;navigation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;NavigationButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;next\u0026#34;: \u0026#34;Neste\u0026#34;, \u0026#34;back\u0026#34;: \u0026#34;Tilbake\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;showBackButton\u0026#34;: true } Her vil frontend da gjøre kallet mot apiet definert i appen og benytte listen som returneres til å avgjøre hvilke side den går til i det brukeren trykker neste. Denne rekkefølgen blir også lagret i staten frontend slik at navigering vil fungere både frem og tilbake på den gitte rekkefølgen man returnerer fra backend.\nOm man ønsker å trigge kalkulering på hvert eneste sidebytte kan dette gjøres ved å enten legge inn calculatePageOrder som en del av triggers for alle navigasjonskomponentene man har i applikasjonen, eller legge til en trigger i Settings.json under pages-seksjonen. Eksempel:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [ \u0026#34;Side1\u0026#34;, \u0026#34;Side2\u0026#34;, \u0026#34;Side3\u0026#34; ], \u0026#34;triggers\u0026#34;: [\u0026#34;calculatePageOrder\u0026#34;] } } Om triggers er satt på navigasjonskomponenten vil denne overstyre triggers som settes i Settings.json, på denne måten er det mulig å styre default-oppførsel på komponentnivå om ønskelig.\nMåten dette implementeres på varierer litt avhengig av hvilken versjon av applikasjonsmalen og Nuget pakkene du bruker.\nv4, v5\rSette opp sporvalg backend (nuget versjon \u0026lt; 5.0.0) For at sporvalg skal fungere for statless applikasjoner må nuget oppgraderes til 5.0.0 eller senere\rI App.cs må man overstyre metoden som henter ut den standardrekkefølgen av sider som er definert i Settings.json Dette gjøres ved å legge til funksjonen nedenfor i App.cs. Forventet output fra denne metoden er en stortert liste som inneholder navnet på de relevante sidene i applikasjonen.\n/// \u0026lt;inheritdoc /\u0026gt; public override async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(string org, string app, int instanceOwnerId, Guid instanceGuid, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); // Implement your own logic here return pageOrder; } Funksjonen får inn en rekke parametere som kan være nyttig dersom man skal benytte skjemadata eller annen informasjon om sluttbruker til å kalkulere sporvalget.\nlayoutSetId Dersom appen din definerer flere layout set vil id på det gjeldende layout settet sendes inn. Dersom applikasjonen ikke har layout set vil denne strengen være tom. Basert på denne parameteren kan man hente ut standard siderekkefølge som er definert i applikasjonen: List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } Dette forutsetter at servicen IAppResources gjøres tilgjengelig i App.cs. Da servicen allerede dependency injectes inn i klasen er det kun to steg som kreves.\nOpprett en privat variabel i staten av klassen. private readonly IAppResources _appResourcesService; Definer den nye private variabelen lik servicen som sendes med i konstruktøren til App.cs _appResourcesService = appResourcesService; CurrentPage Siden man ønsker å navigere fra vil være spesifisert i denne parameteren. FormData inneholder skjemadataen. Den kan enkelt jobbes med som et objekt ved å caste den til riktig type Skjema skjema = (Skjema)formData;. Her heter C# modellen til skjemadataen Skjema for din applikasjon kan det være et annet navn. Dette kan du sjekke ved å finne klassenavnet på C# filen i App/models-mappen. v6, v7\rFor å overstyre standard sporvalg må det gjøres to endringer.\nOpprett en klasse som implementerer IPageOrder grensesnittet som ligger i Altinn.App.Core.Features.PageOrder navnerommet.\nDu kan navngi og plassere filene i den mappestrukturen du selv ønsker i prosjektet ditt. Men vi anbefaler at du benytter meningsfulle navnerom som i et hvilket som helst annet .Net prosjekt. using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Core.Features.PageOrder; using Altinn.App.Core.Models; using Altinn.App.Models; namespace Altinn.App.AppLogic.Custom; { public class CustomOrder : IPageOrder { /// \u0026lt;inheritdoc /\u0026gt; public async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(AppIdentifier appIdentifier, InstanceIdentifier instanceIdentifier, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); // Implement your logic here. return await Task.FromResult(pageOrder); } } } Registrer din implementering i Startup.cs eller Program.cs klassen (.Net 6) services.AddTransient\u0026lt;IPageOrder, PageOrder\u0026gt;(); Dette sørger for at din kode er kjent for applikasjonen og at koden blir kjørt når den skal. Interfacet inneholder en metode med navn GetPageOrder. Forventet output fra denne er en sortert liste over navnene på de relevante sidene i applikasjonen.\nFunksjonen får inn en rekke parametere som kan være nyttig dersom man skal benytte skjemadata eller annen informasjon om sluttbruker til å kalkulere sporvalget.\nappIdentifier Inneholder org og app navn for applikasjonen\ninstanceIdentifier Inneholder InstanceOwnerPartyId og InstanceGuid. Hvis applikasjonen er stateless vil dette objektet være blankt (InstanceIdentifier.NoInstance) Dersom GetInstanceId kalles på en InstanceIdentifier.NoInstance vil det kastes en Exception.\nlayoutSetId Dersom appen din definerer flere layout set vil id på det gjeldende layout settet sendes inn. Dersom applikasjonen ikke har layout set vil denne strengen være tom. Basert på denne parameteren kan man hente ut standard siderekkefølge som er definert i applikasjonen:\nList\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } Dette forutsetter at servicen IAppResources gjøres tilgjengelig i klassen. Da servicen allerede er tilgjengelig via dependency injectes inn i klasen er det kun to steg som kreves.\nOpprett en privat variabel i staten av klassen. private readonly IAppResources _appResourcesService; Definer en konstruktør som tar inn IAppResources og setter private variabelen som ble opprettet i steg 1. public CustomOrder(IAppResources appResourcesService) { _appResourcesService = appResourcesService; } CurrentPage Siden man ønsker å navigere fra vil være spesifisert i denne parameteren.\nFormData inneholder skjemadataen. Den kan enkelt jobbes med som et objekt ved å caste den til riktig type Skjema skjema = (Skjema)formData;. Her heter C# modellen til skjemadataen Skjema for din applikasjon kan det være et annet navn. Dette kan du sjekke ved å finne klassenavnet på C# filen i App/models-mappen.\nReflektere sporvalg i kvittering (PDF) Som applikasjonsutvikler må man selv sørge for å reflektere de sporvalgene som gjøres i PDFen som opprettes i slutten av hver task. I App.cs finnes funksjonen FormatPdf:\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } Som input til metoden får man layoutSettings som inneholder default siderekkefølge under propertyen layoutSettings.Pages.Order. I tillegg får man skjemadataen som er knyttet til steget som skal avsluttes. Denne kan parses til en C# modell som beskrevet lengere oppe på denne siden.\nVed å manipulere layoutSettings.Pages.Order i denne metoden vil man kunne duplisere de sporvalgene som er gjort for sluttbruker. MERK! Kallet til PDF handler, vist nedenfor, må ikke fjernes fra FormatPDF metoden dersom du har implementert ytterlig logikk for kvitteringen i PDFHandler.cs.\nreturn await _pdfHandler.FormatPdf(layoutSettings, data); For å unngå å duplisere logikk vil vi anbefale å lage en metode som manipulerer siderekkefølgen basert på skjemadata og kalle denne både fra FormatPdfog GetPageOrder. Et kodeeksempel på en slik implementasjon følger. Denne kan for eksempel legges i samme klasse som implementerer interfacet IPageOrder for å holde alle logikk for rekkefølge på samme sted.\nI klassen som implementerer logikk for siderekkefølge:\npublic async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(AppIdentifier appIdentifier, InstanceIdentifier instanceIdentifier, string layoutSetId, string currentPage, string dataTypeId, object formData) { List\u0026lt;string\u0026gt; pageOrder = new List\u0026lt;string\u0026gt;(); if (string.IsNullOrEmpty(layoutSetId)) { pageOrder = _appResourcesService.GetLayoutSettings().Pages.Order; } else { pageOrder = _appResourcesService.GetLayoutSettingsForSet(layoutSetId).Pages.Order; } UpdatePageOrder(pageOrder, (FavorittArtist)formData); return pageOrder; } public void UpdatePageOrder(List\u0026lt;string\u0026gt; pageOrder, FavorittArtist formdata) { if (formdata.EnGodNrTo.Contains(\u0026#34;Tix\u0026#34;)) { pageOrder.Remove(\u0026#34;Prince\u0026#34;); } else { pageOrder.Remove(\u0026#34;Tix\u0026#34;); } } Metoden kalles i sin tur fra metoden FormatPdf i App.cs\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { UpdatePageOrder(layoutSettings.Pages.Order, (FavorittArtist)data); return await _pdfHandler.FormatPdf(layoutSettings, data); } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/tone-of-voice/",
	"title": "Språk",
	"tags": [],
	"description": "Retningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.",
	"content": "Som hovedregel bør du bruke retningslinjene fra Språkrådet når du skriver. I tillegg har vi definert noen mer spesifikke regler for Altinn som vi anbefaler at du følger.\nVi oppfordrer til at du skriver innholdet i tjenestene dine på både bokmål, nynorsk og engelsk.\nGenerelle anbefalinger Bruk et muntlig og lett språk Skriv direkte til brukeren (bruk «du») Forklar hva som er neste steg Skriv kort, klart og klikkbart Skriv tekster som kan skummes Vær spesifikk om innholdet, men sørg samtidig for å bruke ord som alle kan forstå Unngå: lange ord lange setninger kryptiske eller lyriske overskrifter flere poenger i samme setning flere poenger i samme avsnitt VERSALER (store bokstaver) Lengde på tekst: overskrifter: maks. 8 ord setninger: 15-20 ord avsnitt: 40-80 ord Skriv rett frem Formelt språk er ofte skrudd sammen slik at utsagnet (verbet) kommer sent i setningen. Det gjør at man må lese mange ord før man får verbet. Det krever mer av leseren som må huske hva som stod tidlig i setningen. Verbet bør stå så tidlig som mulig i setningen og bør stå så nært subjektet som mulig.\nEksempel:\nArbeidstaker har en del plikter som må oppfylles →\nArbeidstaker må oppfylle en del plikter\nUnngå verbalsubstantiver Verbalsubstantiver gjør teksten unødvendig tung å lese. Et verbalsubstantiv er et substantiv dannet av et verb, for eksempel at «å utrede» blir til «å foreta en utredning», der utredning er selve verbalsubstantivet. De fleste verbalsubstantiv slutter på «-ing» og «-else».\nEn tekst med mange verbalsubstantiver blir abstrakt fordi den fjerner seg fra de konkrete handlingene den egentlig beskriver. Teksten blir mer konkret når vi bruker verbene i stedet.\nEksempler:\nVed avtaleinngåelsen → Da avtalen ble inngått Ny henvendelse → Kontakt oss Innmelding av feil → Meld inn feil Skriv aktivt, ikke passivt: I lovspråk blir det ofte skrevet at noe skal gjøres og det er ikke ønskelig å si noe om hvem som skal gjøre det. I Altinn sine løsninger vil det gjerne være flere enn en person som skal gjøre noe, men vi kan skrive direkte til brukeren likevel.\nEksempel:\nForberedelser og planleggingsaktiviteter må gjennomføres før utviklingen av tjenesten(e) kan og bør starte →\nGjør forberedelser og planlegg godt før du utvikler tjenesten.\nOppdeling av tall Riktig og konsekvent oppdeling av tallene hjelper brukeren å lese og skille forskjellige typer nummer. Ingen av nummerne skal skilles med punktum, kun mellomrom. I felt hvor brukeren skal skrive inn lengre nummer er det hjelpsomt å indikere antall siffer.\nOrganisasjonsnummer deles opp i tre og tre: 123 456 789 Bankkonto deles opp i fire, to og fem: 1234 56 78901 Personnummer deles opp i seks og fem: 123456 78901 Mobilnummer deles opp i tre, to og tre: 987 65 432 Fasttelefon og faks deles opp i to og to: 98 76 54 32 Tid og dato Klokkeslett skriver vi kun med timer og minutter, aldri sekunder. Klokkeslett skrives slik: 13:45 Dato skal som hovedregel skrives slik: 05.06.2017 Unntaksvis kan datoer skrives slik i løpende tekst: 5. juni 2017 "
},
{
	"uri": "https://docs.altinn.studio/nb/community/",
	"title": "Community",
	"tags": [],
	"description": "Vi bygger Altinn i lag med mange andre, helt åpent.",
	"content": "\rOm Altinn 3\rAltinn 3 er tredje generasjon plattform for å utvikle og kjøre digitale tjenester.\nBidra til utviklingen av Altinn\rSamarbeid, del og lær. Alt vi gjør er åpen kildekode på GitHub. Vi setter stor pris på dine kommentarer og bidrag!\nEndringslogg\rOversikt over endringer introdusert i Altinn 3.\nRoadmap for Altinn\rHøynivå roadmap og funksjonell beskrivelse for Altinn.\nDevOps\rHvordan vi gjør DevOps.\nPresentasjoner og Altinn kaffe\rThe Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we\u0026#39;re doing in Altinn 3. It\u0026#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/",
	"title": "Endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn 3.",
	"content": "\rEndringslogg for app frontend\rOversikt over endringer introdusert i app frontend.\nEndringslogg for app nuget pakker\rOversikt over endringer introdusert i App Nuget-pakker.\nEndringslogg for deployment\rOversikt over endringer introdusert i helm-chart for deployment.\nStorage Interface endringslogg\rOversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/propose-component/",
	"title": "Foreslå en ny komponent",
	"tags": [],
	"description": "Om dere har behov for en komponent eller funksjonalitet som vi ikke tilbyr ønsker vi at behovet blir meldt som en feature request før utviklingen starter.",
	"content": " Opprett en Feature request in github.\nBeskriv komponenten, forklar hvorfor den vil være nyttig og i hvilken sammenheng den trengs. Review av forslag\nAltinn går gjennom forslaget for å kontrollere at en eventuell ny komponent oppfyller visse kriterier. Etter gjennomgangen vil Altinn gi deg beskjed om beslutningen og anbefalingene. Planlegg utviklingen\nEt medlem av teamet vil kontakte deg for å finne ut i samarbeid hvem som skal fortsette utviklingen. Kriterier Når et nytt forslag tas inn til vurdering ser vi først og fremst på hva som faktisk er behovet og hva komponenten skal løse. Er det en ny komponent som trengs eller har vi eksisterende funksjonalitet som kan endres eller utvides?\nDersom løsningen er en ny komponent, ønsker vi å sikre best mulig kvalitet på denne ved å imøtekomme følgende kriterier:\nBrukbar - Forslaget skal tilfredsstille brukernes behov, være forståelig, gjenkjennelig og forhindre at det oppstår problemer. Tilgjengelig - Forslaget skal følge standarden i WCAG 2.1. Konsekvent - Forslaget skal gjenbruke eksisterende stiler og komponenter i designsystemet der det er relevant. Brukere skal ikke trenge å lure på om forskjellige ord, situasjoner eller handlinger betyr det samme. Allsidig - En ny komponent bør utformes slik at den kan brukes i andre tilsvarende scenarioer og tjenester. "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/input/",
	"title": "Input",
	"tags": [],
	"description": "Inputfelt brukes når brukeren skal føre inn tekst eller tall.",
	"content": "Vanlig inputfelt Retningslinjer: Et inputfelt skal alltid ha en tilhørende label med forklarende tekst. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet. To inputfelt kan plasseres ved siden av hverandre dersom de på et eller annet vis hører sammen. Se eksempel under. Deaktivert felt bør unngås. Dersom et felt ikke kan redigeres bør informasjonen heller presenteres i tekst. Eksempel på bruk: Bredde på inputfelt Bredden på inputfeltet burde reflektere det som forventes av input fra brukeren. Vi har laget tre standard størrelser som burde dekke de fleste scenarioer og som skal fungere på forskjellige skjermstørrelser. Les om hvordan du endrer størrelsen her\nLite input Brukes til for eksempel telefonnummer, postnummer og årstall\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;xs\u0026#34;:5, \u0026#34;sm\u0026#34;:3, \u0026#34;md\u0026#34;:2 } } Medium input Brukes til for eksempel kommune og land\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;xs\u0026#34;:8, \u0026#34;sm\u0026#34;:6, \u0026#34;md\u0026#34;:6 } } Stor input Brukes til for eksempel navn, e-post adresse og en URL\n\u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innergrid\u0026#34;: { \u0026#34;sm\u0026#34;:10 } } Stort tekstfelt Stort tekstfelt benyttes når brukeren skal fylle inn en lengre beskrivelse. De samme retningslinjene som inputfelt gjelder.\nEksempel på bruk: Adresse For adresse finnes det et fast oppsett der postnr og poststed er sidestilt under datofeltet. Postfelt fylles ut automatisk basert på postnr-input.\nEksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/",
	"title": "Logikk",
	"tags": [],
	"description": "Hvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering, dynamikk m.m.",
	"content": "\rApp Events\rOverview on app events - what it is and how to use it\nGenerelt\rOversikt over logikkfiler og hvordan de kan brukes.\nTjenester\rHvordan benytte enkelte bortgjemte tjenester og klienter i app template bibliotekene.\nDataprosessering\rHvordan legge til kalkuleringer og annen dataprosessering?\nDynamikk\rHvordan legge til dynamikk?\nInstansiering\rHvordan legge til logikk som skal kjøres ved instansiering?\nKalkuleringer\rHvordan legge til kalkuleringer?\nDynamiske uttrykk\rOversikt over dynamiske uttrykk definert i JSON\nValidering\rHvordan legge til logikk for å validere skjemadata?\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/app-dev-course/losningsforslag/",
	"title": "Løsningsforslag",
	"tags": ["apps", "training", "solution", "losningsforslag"],
	"description": "Løsningsforslag og forklaring på forståelsessjekker",
	"content": "Løsingsforslag - Applikasjonskode Modul 1 Modul 2 Modul 3 Modul 4 Modul 5 Modul 6 Modul 1 - Forståelsessjekk: Laste opp datamodell Hvilken data er det tjenesteeier ønsker å samle inn her? Datamodellen består av ett hovedelement: innflytter. Dette elementet består igjen av en del underobjekter som_Fornavn_, Etternavn, og Mellomnavn. I tillegg er det noen sammensatte elementer som Adresse, Kontaktinformasjon og Arbeidsinformasjon.\nHvilken effekt har \u0026lt;minOccurs\u0026gt; i datamodellen? Du vil se at feltet har ulik verdi for Inflytter.Fornavn og Inflytter.Mellomnavn minOccurs_ sier noe om hvor mange ganger objektet minst må være nevnt.\nminOccurs=0 vil si at feltet ikke er påkrevd, minOccurs=1 vil si at man forventer at det dukker opp minumum én gang i modellen.\nHvilke andre egenskaper er satt på feltet Innflytter.Mellomnavn? nillable=true er definert på mellomnavn-feltet. Det vil si at det er tillatt med en nullverdi på mellomnavn.\nDet er blitt generert en .C#, .metadata.json og .schema.json fil i tillegg til .xsd filen som du lastet opp. Hva er sammenhengen mellom disse filene? De nevnte filene er alle generert ut ifra xsd-beskrivelsen av datamodellen. De beskriver all dataen og datafeltenes egenskaper. Alle egenskaper er ikke nødvendigvis overført i alle filene, men summen av dem skal opprettholde det som er beskrevet i xsd-filen.\nC#-modellen benyttes av app backend til å deserialisere dataen og gjøre den tilgjengelig for prosessering og validering. .metadata.json benyttes i Altinn Studio for å enkelt kunne koble komponenter og dynamikk til datafeltene. .schema.json-filen benyttes av altinn-app-frontend for skjemavalidering på klientsiden. Enkelte restriksjoner fra datamodellen overføres ikke til C#-filen, hvilke? Det er og lagt til nye egenskaper, hvilke? minOccurs, maxOccurs er ikke overført til modellen. nillable er kun overført på enkelte typer som f.eks. decimal. XmlElement.Order er innført som en dekorasjon på hver egenskap. Dette sørger for at rekkefølgen på elementene alltid vil bli den samme når dataen serialiseres til xml. Modul 1 - Forståelsessjekk: Sette opp komponenter Finner du igjen komponenten som er koblet til e-post-feltet? Det er flere måter å finne igjen et felt i FormLayout.json på. Raskeste veien til mål er ofte å søke etter navnet på feltet som komponenten er koblet til. Dette finner du under dataModelBindings.\nHvilken endring kreves i denne filen dersom e-post-feltet ikke lenger skal være påkrevd? For å gjøre et felt valgfritt, kan man endre required=true til required=false.\nVed å endre én linje i FormLayout.json er det mulig å endre komponenten knyttet til mellomnavn til et inndatafelt for et langt svar. Hvilken endring kreves? Løsningen er å endre type-feltet fra Input til TextArea som vist nedenfor.\n{ \u0026#34;id\u0026#34;: \u0026#34;mellomnavn\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;innflytter.mellomnavn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Innflytter.Mellomnavn\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: false } Modul 1 - Forståelsessjekk: Redigere tekster Hvordan får du inn engelsk språkstøtte i applikasjonen? For alle nye repoer vil resources.nb.json autogenereres i mappen config/texts. For å få støtte for engelsk i en applikasjon, må file_resources.en.json_ opprettes. Merk at language-egenskapen øverst i filen må settes til en.\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [] } Hvis vi en dag skal støtte ukrainsk, hvilken språkkode vil du da måtte annotere filen med? Ifølge listen over ISO 639-1 koder så er koden for ukrainsk uk.\nHvis en tekstnøkkel refert til i FormLayour.json ikke finnes i tekstressursene, hva vil vises da? Hvis nevnte tekstnøkkel ikke finnes i tekstressursfilen, vil tekstnøkkelen vises i stedet.\nModul 2 - Forståelsessjekk: Legge til infoside Hvilken fil i applikasjonsrepoet er det som må justeres på dersom du manuelt ønsker å endre siderekkefølgen på eksisterende sider? I App/ui/Settings.json ligger siderekkefølgen beskrevet. For å justere på siderekkefølgen, må listen beskrevet under pages.order endres til å representere ønsket siderekkefølge.\nHvis du ønsker å gi en side et annet navn, men ikke har Altinn Studio tilgjengelig, hvilke filer må oppdateres med det nye filnavnet? Settings.json: endre navnet på siden under pages.order App/ui/layouts: endre filnavnet på siden som skal bytte navn Hvordan oppnår du at teksten bryter dersom tekststrengen ikke er lang nok til å naturlig brytes? Alle tekstressurser støtter markdown og dermed html-notasjon, så ved å benytte \u0026lt;br/\u0026gt; vil man kunne tvinge tekstbrytning.\nModul 2 - Forståelsessjekk: Alternativ arbeidsflyt Hvis en bruker går tilbake og endrer svaret sitt på infosiden, får den da opp datainnsamlingssidene? Hvis ikke, hvilke endringer kan du gjøre for å støtte dette i din applikasjon? I App/logic/App.cs finnes metoden GetPageOrder. Denne kalles fra frontend når man forlater en komponent som har konfigurert \u0026quot;triggers\u0026quot;: [\u0026quot;calculatePageOrder\u0026quot;] i layoutfilen.\nSe over løsningsforslaget for modulen for hvordan dette gjøres. Filer av interesse er App/ui/layouts/info.json og App/logic/App.cs.\nDersom man har sporvalg på et senere tidspunkt i en arbeidsflyt og en sluttbruker endrer et valg. Hva skjer med skjemdataen man tidligere har fylt ut, dersom siden skjules for sluttbrukeren? Dersom du har denne typen logikk i en applikasjon der man kan fortsette til innsending for flere spor, bør dataen på siden(e) som nå blir skjult for bruker nullstilles.\nModul 2 - Forståelsessjekk: Forhåndsutfylling av personopplysninger Er det mulig å endre en forhåndsutfylt verdi når den først er satt? Ja, dersom man ikke gjør noen endringer, vil en standardkomponent med forhåndsutfylt data være redigerbar.\nHvordan kan man hindre at en forhåndsutfylt verdi endres av sluttbrukeren? Komponenten kan settes til readonly. Alternativt kan man kjøre valideringer av dataen på serversiden for å verifisere at dataen i feltet matcher dataen fra forhåndsutfyllingskilden. Dette kan gjøres i prosesserings- eller valideringslogikken til applikasjonen.\nIkke alle norske innbyggere har et fødselsnummer, noen får tildelt et D-nummer. Hvordan må koden din justeres for å ta hensyn til dette dersom alder skal baseres på et fødselsnummer eller D-nummer som sluttbruker selv taster inn? Et D-nummer er ellevesifret, som ordinære fødselsnummer, og består av en modifisert sekssifret fødselsdato og et femsifret personnummer. Fødselsdatoen modifiseres ved at det legges til 4 på det første sifferet: En person født 1. januar 1980 får dermed fødselsdato 410180, mens en som er født 31. januar 1980 får 710180. Én måte å gå fra et vilkårlig fødsels- eller d-nummer til en streng for fødselsdato på formatet dd-MM-yy på er:\npublic static string GetDOB(string fOrDNumber){ List\u0026lt;string\u0026gt; firstCharsInDNumber = new(){\u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34; }; var fOrDNumberArray = fOrDNumber.ToCharArray(); char[] dobArray = new char[6]; Array.Copy(fOrDNumberArray, dobArray, 6); char firstChar = dobArray[0]; int firstInt = 0; if(firstCharsInDNumber.Contains(firstChar.ToString())) { firstInt = firstChar - 4; dobArray[0] = (char)firstInt; } string dobString = $\u0026#34;{dobArray[0]}{dobArray[1]}.{dobArray[2]}{dobArray[3]}.{dobArray[4]}{dobArray[5]}\u0026#34;; // verify that it is a valid date DateTime.ParseExact(dobString, \u0026#34;dd.MM.yy\u0026#34;, CultureInfo.InvariantCulture); return dobString; } Modul 3 - Forståelsessjekk: Deploye applikasjon Er det mulig å ha to versjoner av en applikasjon i TT02 samtidig? Nei, det er kun mulig å ha én versjon av applikasjonen ute i et miljø av gangen. Deployer man en annen versjon, vil eksisterende versjon av applikasjonen overskrives.\nHva skjer hvis man deployer samme versjon av applikasjonen til miljøet en gang til? Da vil alle operasjoner i forbindelse med deploy kjøres igjen. Man lagrer ressurstekster og annen metadata i Altinn Plattform, og deploy pipeline for å rulle ut applikasjonen i clusteret vil og kjøre.\nDet vil dog ikke bli spunnet opp nye poder i forbindelse med dette da det ikke er noen reelle endringer på tjenesten som kjører i miljøet.\nVil applikasjonen være tilgjengelig umiddelbart etter deploy? Ja, tjenesten vil være tilgjengelig umiddelbart etter deploy. Dersom status er grønn i Altinn Studio skal du kunne nå applikasjonen.\nEr det mulig å fjerne en applikasjon fra miljøet hvis den først er blitt deployet? Per mars 2022 er det ikke mulig for en tjenesteeier å selv fjerne en applikasjon fra et miljø når den først er deployet. Da må man kontakte support. Det vil i løpet av året bli tilgjengeliggjort funksjonalitet for at tjenesteeier selv kan gjøre denne operasjonen.\nModul 4 - Forståelsesssjekk: Innsamling av arbeidsopplysninger Hva er forskjellen på statiske og dynamiske svaralternativer? Statiske svaralternativer er definert build time, og vil, som navnet tilsier, være statiske under hele sin levetid. Dynamiske svaralternativer hentes ut runtime og kan dermed hente verdi basert på tiden på døgnet eller andre dynamiske verdier.\nHva vil være et bruksområde for sikrede dynamiske svaralternativer? Svaralternativer er som standard åpent tilgjengelige og API\u0026rsquo;et vil være mulig å nå for personer som ikke er logget inn i appen. Det er heller ingen restriksjoner på roller eller annet. For enkelte tilfeller så kan det tenkes at man ønsker å eksponere svaralternativer som er sensitive. Her kommer sikrede dynamiske svaralternativer til sin rett ved at man får automatisk verifisering på at den som gjør kallet har Instance.Read-rettigheter.\nModul 4 - Forståelsesssjekk: Differensiert datagrunnlag for offentlig og privat sektor Om en kodeliste er satt opp med en mapping mot datamodellen, hva skjer når det aktuelle feltet endrer verdi? Om et felt i mappingen oppdateres, så vil app-frontend gjøre et nytt kall for å hente ut kodelisten. Dette muliggjør å dynamisk vise valg som er skreddersydd til brukerens tidligere utfylte data.\nHva skjer med valgt verdi på et felt som er koblet til en kodeliste som hentes på nytt fra serversiden? Om brukeren f.eks. har valgt kommune fra en nedtrekksliste over kommuner som er satt opp med en mapping på Fylke, går tilbake og endrer feltet Fylke, så vil det valgte svaret i kommunelisten bli fjernet.\nModul 4 - Forståelsessjekk: Skreddersydd tilbud for IT-kompetanse Om du legger til en ny funksjon i RuleHandlerHelper, hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Funksjoner definert i RuleHandlerHelper.js kjøres som støttefunksjoner når man kobler opp dynamikken i Altinn Studio. Dynamikk kan settes opp uten disse definert og vil fortsatt fungere om man har satt opp funksjonene i RuleHanlderObject.js, og definisjonene ligger i RuleConfiguration.json.\nOm du legger til en ny funksjon i RuleHandlerObject, hvor kjøres disse funksjonene? Vil dynamikk fungere uten denne definert? Funksjoner definert i RuleHandlerObject.js er faktisk dynamikk som lastes av app-frontend runtime og kjøres som en del av applikasjonsflyten som treffer sluttbruker. Dynamikk vil ikke fungere uten denne definert.\nHva er sammenhengen mellom funksjoner definert i RuleHandlerObject og filen RuleConfiguration.json? RuleConfiguration.json er en konfigurasjon som forteller noe om hvilke felter den aktuelle regelen i RuleHandlerObject skal treffe og eventuell effekt funksjonen skal ha. En funksjon definert i RuleHandlerObject kan settes opp flere ganger i RuleConfiguration.json. Man kan nesten tenke på det som \u0026ldquo;instanser\u0026rdquo; av funksjonen.\nModul 5 - Forståelsessjekk: Utvide prosess med et bekreftelsessteg Hvilke Altinn-spesifikke egenskaper er satt på hver prosesstask? altinn:tasktype er definert for hver task.\nHvilke begrensninger vil et eksternt BPMN-redigeringsverktøy ha når man skal redigere prosessbeskrivelsen til en Altinn-app? Altinn-spesifikke egenskaper vil trolig ikke bli importert eller eksportert når man jobber med modellen.\nVil prosessflyten kunne gå begge veier? Fra utfylling til bekreftelse og fra bekreftelse til utfylling? SequenceFlow i bpmn-filen beskriver kun at flyten går én vei, fra utfylling og til bekreftelse. Flyten vil dermed ikke kunne gå begge veier.\nModul 5 - Forståelsessjekk: Legge til autorisasjonsregler for bekreftelsessteget Hva vil skje når prosessflyten går videre til bekreftelsessteget uten at autoriasjonsreglene er blitt oppdatert? Applikasjonen vil vise \u0026ldquo;Ukjent feil\u0026rdquo; når brukeren trykker på \u0026ldquo;send inn\u0026rdquo;-knappen.\nHva skjer dersom du ikke spesifiserer hvilke roller som har lov til å utføre en aksjon i en autorisasjonsregel? Da vil alle brukere, både med og uten roller, ha tilattelse til å utføre confirm-operasjonen for applikasjonen.\nModul 5 - Forståelsessjekk: Validering av innsender Hvilken endring ville du foreslått for kunden for å kunne oppfylle dette kravet uten å legge inn den egendefinerte valideringen på dette steget? Ved å heller endre policy til at kun rollen PRIV – som kun delegeres til en privatperson på vegne av en selv – har tilattelse til aksjonen confirm, vil autorisasjonsreglene gjøre sjekken som nå er lagt inn som egen validering automatisk.\nModul 6 - Forståelsessjekk: Repeterende grupper Hvilket felt i datamodellen er det som bestemmer om et element er repeterende? Feltet maxOccurs i xsd-modellen sier noe om hvorvidt et felt er repeterende. Om maxOccurs \u0026gt; 1 vil man i praksis se på dette elementet som en liste.\nHvor mange repetisjoner er tillatt for feltet TidligereBosteder? Det er tillatt 10 repetisjoner for TidligereBosteder.\nModul 6 - Forståelsessjekk: Validering Når kjøres valideringer serverside? Valideringer på serversiden kjøres som standard kun i det brukeren velger å bevege seg videre fra et steg. Denne oppførselen kan overstyres, og det er mulig å trigge valideringer både på enkelte felter og f.eks. ved sidebytte mellom ulike sider.\nHvorfor burde valideringer som legges til på klientsiden også dupliseres serverside? Klientside-valideringer bør anses som et hjelpemiddel for bedre bruksopplevelse og ikke som en garanti på at data leveres på riktig format. Ondsinnede kan komme seg forbi disse valideringene, og klientsidevalideringer vil ikke bli kjørt om man f.eks. benytter seg av api\u0026rsquo;ene direkte. Derfor bør valideringer som legges på frontend alltid gjenspeiles i logikken backend.\nModul 6 - Forståelsessjekk: Dataprosessering Når blir dataprosessering kjørt? Dataprosessering blir kjørt hver gang brukeren enten leser eller skriver data. Det vil si at hver gang brukeren endrer et gitt felt så vil logikken kjøres. Dette stiller derfor krav til at apputvikler optimaliserer koden som kjøres og unngår tunge og komplekse operasjoner på hver kalkulering.\nHva skiller ProcessDataWrite og ProcessDataRead? ProcessDataWrite kjøres i det brukeren skriver data, altså når brukeren har fylt inn et felt eller oppdaterer en eksisterende verdi. ProcessDataRead kjøres i det brukeren leser data fra databasen, f.eks. når man navigerer seg til en tidligere instans av applikasjonen og henter opp tildigere utfylt data.\nHva er forskjellen på DataProcessing og Calculations? Kjært barn har mange navn - også i dette tilfellet. DataProcessing og calculations er samme navn på samme konsept. I nugetpakkene før 4.7.0 gikk dette under navnet calculations eller kalkuleringer, mens dette nå omtales som DataProcessing.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/metadata/",
	"title": "App metadata",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API for å få metadata informasjon for appen.",
	"content": "Overview The endpoints documented here are all for accessing metadata on the app itself and the data types that are allowed in an instance of the app. Additional endpoints provides access to text resources.\nGet app metadata Endpoint for downloading a copy of the application metadata document.\nGET {basePath}/api/v1/applicationmetadata Get Application texts Get text resources for the application for a specific language code. If the requested language isn\u0026rsquo;t available, norsk bokmål (nb) will be returned as default. The langaugeCode URL path element should follow the ISO 639-1 standard\nGET {basePath}/api/v1/texts/{languageCode} Note that the texts are cached in Platform Storage for 60 minutes before being retrieved from the database again.\nGet model JSON schema Download the JSON schema for a specific model. The id parameter must have the name of a JSON Schema in the app. This is usually a generated name based on values in the original XSD uploaded on the app. E.g: Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\nGET {basePath}/api/jsonschema/{id} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/summary/",
	"title": "Oppsummeringsvisning",
	"tags": [],
	"description": "Hvordan sette opp visning av oppsummering av utfylt skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer på et senere tidspunkt.\nMERK: PDF-genereringen har per nå ikke støtte for oppsummerings-komponenten. For at PDF-generering skal fungere må enten alle oppsummerings-komponentene, eller hele oppsummerings-siden(e) ekskluderes fra PDF. Dette gjøres i Settings.json-filen knyttet til layout-filene.\nOppsett Visning av oppsummering settes opp på samme måte som øvrige skjema-komponenter i et skjema. Man kan velge å ha oppsummeringen på en egen side, eller på samme side som andre skjema-komponenter.\nOppsummerings-komponenten er meget enkel, og refererer til komponent som skal oppsummeres, og siden denne ligger på. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;\u0026lt;komponent-id\u0026gt;\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;\u0026lt;side komponenten er definert på\u0026gt;\u0026#34; }, Komponenten viser oppsummering av data fra den spesifiserte komponenten. I tillegg får sluttbruker mulighet til å gå tilbake til den aktuelle komponenten/siden for å gjøre endringer.\nVisningen er litt forskjellig avhengig av hva slags skjemakomponent oppsummeringen refererer til.\nMerk: PDF-generering støtter ikke oppsummering side, så må den ekskluderes ved å endre ui/Settings.json\n\u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [ \u0026#34;navn-til-oppsummering-side\u0026#34; ] } Enkel skjemakomponent Dette er skjemakomponenter som kun er knyttet til 1 felt i datamodellen. F.eks. Input, Dropdown, Checkbox/Radio, osv.\nOppsummeringen viser ledeteksten til skjemakomponenten, og tilknyttet data. Dersom det er en aktiv feilmelding knyttet til skjemakomponenten, vil dette også vises.\nAdressekomponent Denne komponenten har flere felter som inngår. Visningen er lik som for en enkel skjemakomponent, slik at feltene blir slått sammen til en enkel tekst.\nFilvedlegg Oppsummeringsvisningen for filvedlegg viser en liste over de vedleggene som er lastet opp for den aktuelle komponenten.\nRepeterende grupper Grupper i grupper Oppsummering støttes også for repeterende grupper inne i repeterende grupper. Vi støtter kun ett nivå av grupper i grupper. I dette tilfellet vises oppsummeringen av hvert innslag av gruppen på øverst nivå som en egen kategori, og gruppen på nederste nivå vises på samme måte som vanlige repeterende grupper.\nFor å støtte oppsummeringsvisning av gruppe i gruppe må gjøre følgende oppsett i layout-filen:\nReferere til hovedgruppen i componentRef i Summary-komponenten Sette \u0026quot;largeGroup\u0026quot;: true på Summary-komponenten Eksempel Med følgende oppsett av gruppe i gruppe i layout:\n{ \u0026#34;id\u0026#34;: \u0026#34;main-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hovedgruppe\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;model.mainGroup\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;nested-group-1\u0026#34; ], ... // resterende oppsett av komponent }, { \u0026#34;id\u0026#34;: \u0026#34;nested-group-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Undergruppe\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;model.mainGroup.subGroup\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;input-field-1\u0026#34; ], ... // resterende oppsett av komponent }, { \u0026#34;id\u0026#34;: \u0026#34;input-field-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Skriv inn noe her\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;model.mainGroup.subGroup.field1\u0026#34; }, ... // resterende oppsett av komponent } Setter man opp oppsummering på følgende måte:\n{ \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;main-group\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;FormLayout\u0026#34;, \u0026#34;largeGroup\u0026#34;: true, } Kategorier Det er mulig å gruppere oppsummeringene i forskjellige kategorier, for å gjøre en ev. oppsummeringsside mer oversiktlig. Dette gjøres ved å bruke den eksisterende gruppe-komponenten, uten å sette den opp som en repeterende gruppe.\nFeltene i oppsummeringen vises da med en tittel, som settes i title-feltet for textResourceBindings for gruppe-komponenten. Se eksempel under.\n{ \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, Eksempel på oppsummeringsside Under er et eksempel på en oppsummeringsside, med oppsett i layout-filen. Da oppsummeringen settes opp i layout-filene på samme måte som andre komponenter, kan man også ha med andre skjemakomponenter som tekster ved behov.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;send-in-text\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;componentType\u0026#34;: 1, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;finish\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;personalia-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Personalia\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-1\u0026#34;, \u0026#34;summary-2\u0026#34;, \u0026#34;summary-3\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d566c79c-3e3e-445b-be25-a404508f6607\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;22a60bf0-d5b7-4b45-9ac9-c266b6ad3716\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-3\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;d497737b-67b2-4e03-87a9-43f58579c938\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;personalia\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;drugs-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Rus- og dopingmidler\u0026#34; }, \u0026#34;children\u0026#34;: [ \u0026#34;summary-4\u0026#34;, \u0026#34;summary-5\u0026#34;, \u0026#34;summary-6\u0026#34;, \u0026#34;summary-7\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;summary-4\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;064c0033-8996-4825-85fc-2a19fe654400\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-5\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;7f22e523-3f6d-4371-a5dd-233dc41af824\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-6\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;18a7c709-ae2f-48b3-b6f6-bd631f5d8d56\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-7\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;b7417cf9-f806-4835-a3d1-424c8d094d5f\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;drugs\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-group-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;work\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;summary-8\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Summary\u0026#34;, \u0026#34;componentRef\u0026#34;: \u0026#34;25f720db-5784-4c95-a530-43f0bf523466\u0026#34;, \u0026#34;pageRef\u0026#34;: \u0026#34;attachment\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;312afa87-c2a9-4ef1-a681-26cc47462878\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/",
	"title": "Retningslinjer",
	"tags": [],
	"description": "Vi ønsker å oppnå helhetlige og konsistente brukeropplevelser ved å bruke gjenkjennbare og godt testede komponenter. For å oppnå dette ut i tjenestene, ber vi deg om å benytte retningslinjene på disse sidene.",
	"content": "Altinn har som mål å gjøre det enklere for innbyggere og næringsliv å være i kontakt med det offentlige uavhengig av digital kompetanse. Felles retningslinjer for design hjelper oss å skape konsistens på tvers av tjenester som lages i Altinn Studio.\nDesignprinsipper\rNår vi utvikler nye eller forbedrer eksisterende produkter følger vi et sett med prinsipper for å kunne sikre oss at vi leverer brukervennlige løsninger til alle. Vi anbefaler å følge disse prinsippene når du jobber med utvikling av nye tjenester.\nInngang til skjema\rFor å gjøre opplevelsen til brukeren best mulig bør du tenke over hvordan du lenker til Altinn-appen fra din etat.\nInnhold i skjema\rForklar brukeren hva som skal til for å fylle ut skjemaet riktig og fordel innholdet i flere steg.\nKonsistens på tvers av tjenester\rFor å være lett å bruke og unngå forvirring, bør samme interaksjonsmønstre følges på tvers av tjenester.\nUI-komponenter\rDe ulike komponentene er laget for at de skal passe sammen i en større helhet. Det er derfor viktig å følge retningslinjene for hvordan disse brukes for å oppnå et konsistent og gjenkjennbart uttrykk. UI-komponenter som foreløpig inngår i Altinns bibliotek finner du her.\nSpråk\rRetningslinjene skal sørge for at vi får et ensrettet språk og forståelig innhold i tjenestene som lages i Altinn.\nTilgjengelighet\rGod tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/styling/",
	"title": "Styling",
	"tags": [],
	"description": "Hvordan styre styling, formatering og grid-layout for en app.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\nMERK: for å benytte denne funksjonaliteten må man ha app-frontend versjon 3. Se denne lenken om endringer som må til i appen.\nSidestilte komponenter (grid) Det er mulig å sidestille komponenter i skjema. Denne funksjonaliteten baserer seg på grid systemet til Material-UI, og vil også være kjent om man er kjent med grid-systemet til boostrap. Grid systemet baserer seg på en oppbygning av containere i 12 deler, hvor man så kan tildele barn (items) av en grid-container en gitt andel av denne bredden. Material-UI tilbyr også muligheten til å dynamisk endre hvor stor andel av skjermen man ønsker å oppta basert på hvilken skjermstørrelse sluttbrukeren har. Følgende størrelser med tilhørende breakpoints er definert:\nxs: 0px sm: 600px md: 1024px lg: 1440px xl: 1920px For å sidestille komponenter horisontalt må man gjøre noen små endringer i formlayout. Det er definert en egen property grid som man kan fylle inn bredde ønsket på de ulik størrelsene. Her er et eksempel hvor to input-felt har blitt satt til å ta halve skjermen (enkelte props er fjernet for lesbarhet):\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6, } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } I komponentene over er størrelsen satt til 6 (altså halv bredde) for størrelse xs. Siden xs er den minste størrelsen tilgjengelig vil dette gjelde fra størrelse xs og opp, altså fra xs til xl. Oppsettet over vil gi følgende resultat:\nSiden man har 12 inndelinger tilgjengelig i sidebredden er det opp til apputvikler å tildele hvor stor andel komponenten skal ha. Om man ønsker at en komponent skal ta 2/12, en annen 6/12 og siste 4/12 så er det mulig. Det er viktig å tenke på brukeropplevelsen når man gjør slike endringer, og sidestilling av komponenter bør gjøres med omhu. Komponenter med lengre tekster og beskrivelser blir også fort små og uoversiktelige om disse sidestilles. Skal det benyttes lengre tekster og beskrivelser anbefales det at disse benytter full bredde av skjema.\nOm man i eksempelet over hadde ønsket at komponentene skulle ta hele bredden frem til skjermen ble større enn 960px så kunne man satt opp følgende layout:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } }, { \u0026#34;id\u0026#34;: \u0026#34;input-felt-2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;sm\u0026#34;: 12, \u0026#34;md\u0026#34;: 6 } } } Da ville komponentene først legge seg sidestilt i det sluttbruker faktisk sitter på en skjerm som oppfyller kravet stilt.\ninnerGrid og labelGrid Utover det å sette bredde på grid i komponenten har vi også lagt til mulighet til å styre innerGrid og labelGrid. Dette gir deg mulighet til å påvirke på samme måte hvor stor bredde label og input skal ta. Dette brukes typisk når du vil gjøre input feltet mindre (for å gi en visuell markering av at det forventes kort svar), eller hvis du ønsker å vise label og input på samme linje (som i en tabell).\nDu kan tenke på komponenten på denne måten:\n\u0026lt;Grid id=\u0026#34;grid\u0026#34;\u0026gt; \u0026lt;Grid id=\u0026#34;labelGrid\u0026#34;\u0026gt; Komponentens tekster \u0026lt;/Grid\u0026gt; \u0026lt;Grid id=\u0026#34;innerGrid\u0026#34;\u0026gt; Komponentens input \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; Her vil det da være mulig å styre bredden til både ytterste grid og den innerste griden. Eksempel:\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 12, \u0026#34;innerGrid\u0026#34;: { \u0026#34;xs\u0026#34;: 6 } } } } Her har man satt at komponent griden skal ta hele bredden, mens man begrenser komponentens input til å kun ta halve bredden. InnerGrid vil kunne styres for komponentene:\nKort svar (Input) Langt svar (TextArea) Filopplaster (FileUpload) Nedtrekksliste (Dropdown) Datovelger (Datepicker) Eksempelet over vil gi følgende output:\nEn tabellvisning med sidestilt label vil komme frem hvis du setter labelGrid og innerGrid slik at summen blir 12 (eller mindre). Dette kan være lurt hvis du har en lang liste med relaterte spørsmål. Det er ofte lurt å ikke bruke et slikt layout på de minste skjermene, så bruk gjerne md\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;grid\u0026#34;: { \u0026#34;labelGrid\u0026#34;: { \u0026#34;md\u0026#34;: 8 }, \u0026#34;innerGrid\u0026#34;: { \u0026#34;md\u0026#34;: 4 } } } } Det vil se omtrent slik ut\nTo radioknappalternativer eller avkrysningsbokser under hverandre Som standard kommer radioknapper eller checkboxer som har kun to svaralternativer, på én linje. Dersom man ønsker at svarene skal ligge på hver sin linje slik:\nmå man legge til \u0026ldquo;layout\u0026rdquo;:\u0026ldquo;column\u0026rdquo; for radioknappelementet på siden.\n{ \u0026#34;id\u0026#34;: \u0026#34;radio-under-hverandre\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;RadioButtons\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Vil du har to linjer når det kun er to svaralternativ?\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;someRadiobuttonFieldWith2Options\u0026#34; }, \u0026#34;options\u0026#34;: [ { \u0026#34;value\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Ja\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Nei\u0026#34; } ], \u0026#34;required\u0026#34;: true, \u0026#34;layout\u0026#34;: \u0026#34;column\u0026#34; } Formatering av tall Det er nå implementert støtte for å kunne spesifisere formatering av tall i inputfelt. Dette gjøres ved å legge til en property formatting på Input-komponenten. Formateringsmuligheter er dokumentert i et JSON-schema, og vil dukke opp automatisk i intellisense når man redigerer komponenten i f.eks. VSCode.\nEksempelet under vil resultere i et inputfelt for tall, hvor tallet vil bli formatert med , mellom hver tusen, og $ foran tallet.\nFormateringen er kun for visning i frontend, og tallene som legges inn i et inputfelt med formatering vil lagres uformatert.\r{ \u0026#34;id\u0026#34;: \u0026#34;numberComponent\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;number\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;someNumberField\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: false, \u0026#34;formatting\u0026#34;: { \u0026#34;number\u0026#34;: { \u0026#34;thousandSeparator\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;$\u0026#34; } } }, Justering av tekst i input felter Når skjemaet inneholder en liste med tall som summeres er det vanlig å justere teksten i input feltet til høyre slik som når man summerer på papir og slik det vises i Excel. Dette kan gjøres ved å sette \u0026quot;align\u0026quot;: \u0026quot;right\u0026quot; under formatting på input componenten. Andre gyldige verdier er \u0026quot;center\u0026quot; og \u0026quot;left\u0026quot;.\n{ \u0026#34;id\u0026#34;: \u0026#34;numberComponent\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;formatting\u0026#34;: { \u0026#34;number\u0026#34;: { \u0026#34;thousandSeparator\u0026#34;: \u0026#34; \u0026#34;, \u0026#34;prefix\u0026#34;: \u0026#34;kr \u0026#34; }, \u0026#34;align\u0026#34;:\u0026#34;right\u0026#34; } }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/wcag/",
	"title": "Tilgjengelighet",
	"tags": [],
	"description": "God tilgjengelighet hjelper mennesker med funksjonshemninger å oppfatte innholdet vårt på en meningsfull måte. Ved å bruke Altinn 3 får du mye på kjøpet, men noen ting må du fortsatt huske på selv.",
	"content": "Forskrift om universell utforming av IKT-løsninger stiller krav om at nettsider må oppfylle 35 av 61 suksesskriterier i standarden Retningslinjer for tilgjengelig webinnhold (WCAG) 2.0. Sjekk ut minimumskravene på UU-tilsynet som er omfattet av forskriften.\nSjekkliste Innholdsstruktur Sjekk at du har en logisk struktur på overskrifter (H1 - H4), og at du ikke har noen tomme overskriftselementer. Det er fort gjort å glemme et nivå. For å oppdage feil i innholdstrukturen kan det være nyttig å benytte “Wave” som er et utvidelsesverktøy til chrome. Last ned Wave til Chrome, installer og ikonet vil dukke opp øverst til høyre i nettleseren. Forklarende tekster og hjelpetekst Sjekk at lenker, label og knapper har forklarende tekster. Ta en vurdering på om ekstra beskrivelser og hjelpetekster må kobles til input elementet.\nKnapp vs lenke Det er viktig at man er bevisst på om det blir brukt knapper eller lenker, da skjermlesere kan få problemer med å tolke funksjonaliteten.\nFeilmeldinger Du er selv ansvarlig for at korrekte feilmeldinger blir lagt inn på hvert av skjemafeltene.\nNB: Skal du lage tjenester i egen løsning, der Altinns grensesnitt er usynlig for brukeren, må du selv huske på å ta hensyn til øvrige WCAG-krav.\nHvordan teste Det er viktig at dere tester at tjenesten deres er tilgjengelig for alle. Dette vil ikke bare hjelpe deres tjeneste, men det kan også belyse feil som har oppstått eller blitt oversett hos oss. Her er noen verktøy som kan brukes til å gjøre enkle tester.\nTastaturnavigasjon Sjekk at alle knapper og inputfelter kan nåes ved tastaturnavigasjon.\nSkjermleser Gå gjennom flyten med en skjermleser som hjelpemiddel. Her kan du forsikre deg om at alt blir lest opp riktig og at tekstene er beskrivende nok.\nMac: VoiceOver er forhåndsinstallert på Apples mobiler og PCer. VoiceOver Brukerveiledning\nWindows: NVDA Screenreader er et gratis skjermleser verktøy laget av NV Access Om NVDA Screenreader\nKontrast Følgende fargekombinasjoner som er brukt på Altinn oppfyller kravene til kontrast i liten tekst. AA er minstekravet, mens AAA er anbefalt, særlig for løpende tekst.\nAA\rAAA\rAAA\rAA\rAA\rAAA\rAA\rAAA\rAAA\rAAA\rAA\rAA\rAAA\rAA\rAA\rAAA\rAAA\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/services/",
	"title": "Tjenester",
	"tags": [],
	"description": "Hvordan benytte enkelte bortgjemte tjenester og klienter i app template bibliotekene.",
	"content": "Personoppslag Tjenesten for personoppslag kan brukes til å verifisere et personnummer og til å hente informasjon om den identifiserte personen. Brukeren vil måtte oppgi både et personnummer og etternavnet til personen. Tjenesten vil da gjøre et oppslag på personnummeret og sjekke at etternavnet stemmer. Begge verdiene er obligatoriske og etternavnet brukes til å forhindre vasking av personnummer. Hvis brukeren oppgir feil informasjon for mange ganger vil brukeren bli sperret fra å gjøre flere oppslag i en liten periode.\nDe returnete persondataene kan brukes til å fylle ut andre felter i datamodellen.\nPersonoppslag eksempel Tjenesten kan benyttes fra alle \u0026ldquo;handlers\u0026rdquo; i logikk klassene i en app. Nedenfor har vi laget et eksempel som gjør oppslag i ProcessDataWrite metoden i DataProcessingHandler.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite( Instance instance, Guid? dataId, object data) { if (data is MessageV1 message) { Person person = await _personLookup.GetPerson( message.Personnummer, message.Etternavn, CancellationToken.None); message.Fornavn = person.FirstName; return true; } return false; } For at dette skal fungere må vi gjøre et par andre endringer i DataProcessingHandler.\nLegg til et privat felt _personLookup for tjenesten og oppdater klassens konstruktør til å ta inn en instanse av tjenesten som input. Set det private feltet i konstruktøren.\nprivate readonly IPersonLookup _personLookup; public DataProcessingHandler(IPersonLookup personLookup) { _personLookup = personLookup; } Endringene i DataProcessingHandler konstruktøren medfører at man også må gjøre endringer i konstruktøren til App klassen. Legg til IPersonLookup som input parameter og bruk verdien som input i konstruktøren til DataProcessingHandler.\npublic App( ... IText textService, IPersonLookup personLookup, IHttpContextAccessor httpContextAccessor) : base(...) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); _dataProcessingHandler = new DataProcessingHandler(personLookup); _instantiationHandler = new InstantiationHandler(profileService, registerService); _pdfHandler = new PdfHandler(); } Håndtering av feil Uten flere endringer enn de som er beskrevet over, vil app backend begynne å svare med statuskode 429 - TooManyRequests hvis brukeren har oppgitt feil data for mange ganger. Denne statuskoden er for øyeblikket ikke håndtert av frontend delen av app koden. Dette vil i utganspunktet resultere i \u0026ldquo;ukjent feil\u0026rdquo; som kan unngås ved å legge inn håndtering av exceptions. Det kan legges inn kode som fanger opp PlatformHttpException med en response med statuskode 429, men det er i dag ingen god innebygget mekanisme som kan brukes til å informere brukeren om hvorfor noe gikk galt. Det man eventuelt kan gjøre er å benytte et felt i datamodellen.\ntry { ... return true; } catch (PlatformHttpException phex) { switch (phex.Response.StatusCode) { case HttpStatusCode.TooManyRequests: // Add corrective messures break; case HttpStatusCode.NotFound: // Add corrective messures break; } throw; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/images/",
	"title": "Bilder",
	"tags": [],
	"description": "Hvordan legge til og endre referanser til bilder.",
	"content": "MERK: bildekomponenten er enda ikke støttet i PDF-genereringen og vil derfor bli ignorert i PDF-visningen.\rLegge til bilder i applikasjonen Å legge til bilder gjøres i FormLayout.json ved bruk av bildekomponenten. Alternativ tekst for bildet er nyttig for situasjoner hvor bildet ikke kan lastes, eller for brukere som benytter skjermleser. Dette kan legges til som en tekst ressurs som er definert i resource.[språk].json.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;https://example.com/image_nb.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } Bildet kan også ha ulik kilde i forskjellige språk. Standardkilde er nb, og denne brukes for språk som ikke har oppgitt en egen kilde for bilder. Eksempel med forskjellig kilde for nb og en:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;https://example.com/image_nb.png\u0026#34;, \u0026#34;en\u0026#34;: \u0026#34;https://example.com/image_en.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } Hosting av bilder fra app Dersom bildet skal lastes fra appen, må man sette opp statisk hosting av filer i applikasjonen. Dette er automatisk satt opp for applikasjoner laget etter desember 2021. For eldre applikasjoner, følg beskrivelsen nedenfor. Dette konfigureres i App/Startup.cs, i Configure metoden. Dette vil så hoste alle filer som ligger i /app/wwwroot mappen. Om denne mappen ikke finnes må den opprettes. Ønsker du å referer til filen app/wwwroot/bilde_nb.png så vil denne kunne nås med følgende path: /org/app-name/bilde_nb.png\napplicationId er en variabel deklarert noen linjer opp og inneholder org/app-name fra applicationmetadata.json:\npublic void Configure(IApplicationBuilder app, IWebHostEnvironment env) { // ... app.UseRouting(); app.UseStaticFiles(\u0026#39;/\u0026#39; + applicationId); app.UseAuthentication(); // ... } I FormLayout.json må referansen til bildet være en relativ url som starter med /org/app-name som ble satt opp i static hosting. Du kan også bruke snarveien wwwroot (uten / først), som blir erstattet med /org/app-name før bildet lastes.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;altTextImg\u0026#34;: \u0026#34;imgAltText\u0026#34; }, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;wwwroot/bilde_nb.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;center\u0026#34; } } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/date/",
	"title": "Dato",
	"tags": [],
	"description": "Datovelger benyttes i forbindelse med planlegging eller for datoer i nærliggende tid. For datoer lengre tilbake i tid brukes datofelt.",
	"content": "Datovelger I forbindelse med planlegging, eller for datoer i nærliggende tid kan du bruke datovelgeren.\nRetningslinjer: Dersom du skal hente inn en fødselsdato eller andre datoer lengre tilbake i tid, er ikke datovelgeren et anbefalt alternativ, se studier fra gov.uk I disse tilfellene kan du heller bruke datofeltet. Legg til korrekt validering og gi brukeren informasjon om hva som er gyldige datoer å velge. Skal brukeren kunne velge datoer tilbake i tid? Innenfor en gitt periode? Eksempel på bruk: Datofelt For datoer lengre tilbake i tid, eller datoer brukeren kjenner godt, bør datofelt benyttes. Tre tekstfelt er i disse tilfellene den enkleste måten for brukeren å fylle ut datoen. Dersom det er noe som skal planlegges eller tilfeller der en spesifikk dag er viktig, bruk datovelgeren i stedet.\n⚠️ Denne komponenten er ikke tilgjengelig i Altinn Studio enda.\nRetningslinjer: Bruk alltid label på hver av de tre boksene (dag, måned, år), og ledetekst (legend) for hele input-gruppen. Om datagrunnlaget finnes, kan en spesifikk dato være foreslått i feltet. Ellers kan eksempelinnholdet være dagen i dag. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/",
	"title": "Endringslogg for deployment",
	"tags": [],
	"description": "Oversikt over endringer introdusert i helm-chart for deployment.",
	"content": "\rMigrering til versjonerte charts\rMigrering fra helm template filer til versjonert helm dependency.\nv1\rOversikt over endringer introdusert i v1 av deployment.\nv2\rOversikt over endringer introdusert i v2 av deployment.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pages/layout-sets/",
	"title": "Flere skjema i samme app (layout-sets)",
	"tags": [],
	"description": "Hvordan sette opp en app som inneholder flere ulike skjema.",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\rOppsett For å få funksjonalitet for flere skjema i tjeneste, må nuget-versjon til pakkene app\u0026rsquo;en bruker oppgraderes til versjon 3.1.4 eller nyere. Se instrukser for hvordan det gjøres her.\nSentralt i løsningen er at man har flere layout-sets som består av en eller flere sider og configurasjon. Hvert layout-set består av tilsvarende filer som en skjema tjenester.\n|- App/\r|- ui/\r| - layout-sets.json\r|- skjema-a/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json\r|- skjema-b/\r|- Settings.json\r|- RuleHandler.js\r|- RuleConfiguration.json\r|- layouts/\r|- side1.json\r|- side2.json\r|- side3.json I layout-sets.json defineres det hvilke steg i prosessen (task) hvor et gitt layout-set skal brukes. Merk at id\u0026rsquo;en er case sensitiv, så om du har stor bokstav i mappenavnet må id\u0026rsquo;en reflektere dette. Vi anbefaler små bokstaver i mappenavn.\nEksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;skjema-a\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_4222_160523_forms_212_20160523\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_1\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;skjema-b\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;schema_3161_140411_forms_1549_11554\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_2\u0026#34; ] } ] } "
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/instance/",
	"title": "Instance",
	"tags": ["api", "translate-to-norwegian"],
	"description": "An instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.",
	"content": "Instance The Instance model is the main model of an instance. An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange.\nProperties Name Description id A gobally unique id for the instance. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the internal unique id of the instance owner and the second part is a generated UUID value. instanceOwner A complex type identifying the owner of the instance. See InstanceOwner appId The id for the app the instance is associated with. The value has two parts separated by a \u0026lsquo;/\u0026rsquo; character. The first part is the short name/identifier of the owner of the app and the second part is the app name. org The short name of the app owner. selfLinks A complex type containing a set of named URLs. See ResourceLinks dueBefore This can be use by app owner to indicate a deadline for when the instance must be completed and submitted by a user that can represent the instance owner. visibleAfter This can be used by app owner to have an instance become visible for app users at a given date and time. This way an instance can be created in advance and populated with data before being available to an application user. process A complex type tracking the process state of the instance. See ProcessState status A complex type with more state data. See InstanceStatus completeConfirmations A list of complete confirmations. See CompleteConfirmation data A list of data elements. This include all forms, attachments and other data types being collected. See DataElement presentationTexts A dictionary with text values extracted from forms that are saved on the instance. Values are extracted based on PresentationField values stored in the application metadata document. Also see PresentationField dataValues A dictionary with data values extracted from forms that are saved on the instance. Values are extracted based on configured data fields in the applicationmetadata document. Also see DataField created The date and time when the instance was first initialized. createdBy An idenfificator indicating who it was that created the instance. lastChanged The date and time when the instance was last changed. lastChangedBy An idenfificator indicating who it was that made the last change to the instance. InstanceOwner The InstanceOwner model is a simple definition whose only porpose is to hold a universally known identification value of the instance owner.\nProperties Name Description partyId A value used internally by Altinn to uniquely identify an entity across Organisations, Persons and Self identified users. personNumber If the instance owner is a person this field is populated with a person number from the National Population Register in Norway. organisationNumber If the instance owner is an organisation this field is populated with an organisation number from the National Unit Register in Norway. username If the instance owner is a self identified user this field is populated with a user name. InstanceStatus The InstanceStatus model is used to hold key status related metadata about an instance. All information is also tracked through instance events, but this is an easily accessible summary of the last events.\nProperties Name Description archived The date and time for when an archived instance was archived. softDeleted The date and time for when a deleted instance were moved to the recycle bin. hardDeleted The date and time for when an instance became unrecoverable through any API. A few days later the instance and all its data will be physically deleted from storage and truly unrecoverable. readStatus A field indicating whether an application user has opened the instance at any time. Used internally by the message box to indicate read status of elements. substatus A property with human readable status information that will be displayed by the message box. CompleteConfirmation The CompleteConfirmation model is a simple type for holding information about who and when a given stakeholder has told Altinn that the instance is no longer needed. They have obtained all the information they needed from the instance. The instance can be deleted permanently should an application user decide to to so. At the time of writing an instance can have only one stakeholder and that is the Application Owner.\nDataValues Data values are values either extracted from the instance data or other sources. The values are stored with the instance for easy access and can be used for example in routing logic on the receiving end.\nWhile data fields configured in the app metadata file will be extracted and automatically picked up by the application, there is also the option of adding values manually by using the UpdataDataValues method from the IInstance interface. You can mix and match data fields from configuration and by manually adding. It\u0026rsquo;s the UpdateDataValues method that is called under the hood in both cases. UpdateDataValues merges the incoming collection with what\u0026rsquo;s allready stored. However if yo specify the same id it will be overwritten by one or the other and you have no guaranties on which is stored.\nValues passed in to the UpdataDataValues can have any source and is not restricted to data stored in the application. It can be called from any place but it\u0026rsquo;s recomended to not call it more than strictly required. A good place is to override the RunProcessTaskEnd method from AppBase causing the method to be called when a task is completed.\nProperties Name Description stakeholderId The short name of an application owner. confirmedOn The date and time for when the application owner confirmed that they consider the instance as no longer needed in Altinn. ProcessState The process state model keeps track of the process of a specific instance.\nProperties Name Description started Date and time for when the process was initially started. startEvent The name of the start event triggering the beginning of the process. currentTask A complex model keeping track of current process step. See ProcessElementInfo ended Date and time for when the process was finished. endEvent The name of the end event that the process ended with. ProcessElementInfo The process element info holds information about the current task in the process.\nProperties Name Description flow A step counter that increase every time the process moves forward. started Date and time for when the instance entered the current step. elementId The unique id of current process task. name The name of the task. (Human readable.) altinnTaskType The type of task. validated A date and time for when the instance was validated as well as a value indicating if the task can be completed without additional changes and a new validation. ResourceLinks The resource link model is should have a collection of URLs that can be used to obtain a copy of the instance document through different API. The propose is to make it easy to switch between API. Primarily when the original was obtain from the storage instance query API and you need to use the app API to perform changes on the instance.\nProperties Name Description apps Contains a URL for the endpoint to use to obtain a copy of the current instance document through the app API. platform Contains a URL for the endpoint to use to obtain a copy of the current instance document through the Platform Storage API. Complete example This example was created by instantiating an app running locally on a development machine using LocalTest. The process is at first step, Task_1, and it has a single data element which is the main form of the app.\n{ \u0026#34;id\u0026#34;: \u0026#34;1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;partyId\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;personNumber\u0026#34;: \u0026#34;01039012345\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null, \u0026#34;username\u0026#34;: null }, \u0026#34;appId\u0026#34;: \u0026#34;ttd/bli-applikasjonseier\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://local.altinn.cloud/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://local.altinn.cloud/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34; }, \u0026#34;dueBefore\u0026#34;: null, \u0026#34;visibleAfter\u0026#34;: null, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5662973Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2020-11-18T15:56:41.5664762Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: null, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2020-11-20T13:00:05.1800273+00:00\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } }, \u0026#34;ended\u0026#34;: null, \u0026#34;endEvent\u0026#34;: null }, \u0026#34;status\u0026#34;: null, \u0026#34;completeConfirmations\u0026#34;: null, \u0026#34;data\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://local.altinn.cloud/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://local.altinn.cloud/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } ], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;1337\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:42.1972942Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;1337\u0026#34; } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/runtime-environment/",
	"title": "Kjøremiljø",
	"tags": [],
	"description": "Beskrivelse av kjøremiljøet for en Alttin 3 applikasjoner for en tjenesteeier.",
	"content": "Altinn 3 applikasjoner for en tjenesteeier kjører i Azure Kubernetes Service (AKS) fra Microsoft Azure. Dette er en såkalt Managed Service hvor vi lar Microsoft Azure ta seg av den underliggende driften av Kubernetes clusteret. Altinn står for konfigurering og provisjonering av clusteret, mens tjenesteeier har selv ansvar for utrulling av applikasjonene til clusteret.\nFor detaljert dokumentasjon av hvilke muligheter som finnes må man se på:\nAzure Kubernetes Services Kubernetes, og da spesielt hvordan ressurser administreres - et ansvar som er delt mellom Altinn og tjenesteeier. Alle tjenesteeiere vil ha egne Kubernetes cluster for test og produksjon. Dette sikrer at applikasjoner for en tjenesteeier ikke påvirker applikasjoner for andre tjenesteeiere.\nRessursadministrasjon Selv om man ofte tenker at en skyløsning har ubegrenset kapasitet, så vil også ubegrenset kapasitet gjerne føre til ubegrenset kostnadsbruk. Det er derfor viktig å ha kontroll på hva man forbruker av ressurser, hvor mange applikasjoner man kjører og hvor mye CPU/minne den enkelte applikasjon legger beslag på. Før eller siden vil man gå tom for ressurser (CPU og minne) på clusteret, og det er da viktig å forstå hvilke faktorer som påvirker.\nKomponentene i et cluster Et AKS Cluster kjører på et antall noder (virtuelle maskiner) av en gitt type. Per i dag er dette B2 som har 2 vCPU og 8 GiB minne. Som standard settes det opp minimum 3 noder både i TT02 og produksjon med automatisk skalering opp til 6 noder avhengig av trafikk. Clusteret vil da ha 12 vCPU og 48 GiB minne som da blir den øvre kapasiteten clusteret har til å betjene de applikasjonene som til enhver tid er deployet.\nMerk: Et cluster kan skaleres automatisk opp til 1000 noder, men dette vil også medføre tilsvarende kostnadsøkning. Hva som er det rette \u0026ldquo;taket\u0026rdquo; for den enkelte tjensteeier vil avhenge av antall applikasjoner, hvor mye ressurser disse krever som minimum og trafikken som disse genererer. Ta kontakt med oss i Altinn om dere har behov for mer ressurser enn det som er satt opp som standard.\nFullscreen\nApplikasjoner / Apps Når vi snakker om en Altinn 3 App så snakker vi om den logiske applikasjonen som det bare finnes 1 av. For å sikre at en app hele tiden er oppe så kjører vi som regel med 2 eller flere instanser av applikasjonen. Minne og CPU reservasjoner gjelder per instans.\nDocker Containers En Docker Container, eller bare container, inneholder i vårt tilfelle den kjørende koden for en Altinn 3 App. Men det finnes også andre containere i clusteret som inneholder systemtekniske ting som må kjøre. F. eks. så vil enhver Altinn 3 app container få følge av en Linkerd container som tar seg av kryptering/dekryptering av trafikk inn og ut av Altinn 3 applikasjonen.\nPods En pod er den minste kjørbare enheten i et kubernetes cluster og er det vi allokerer ressurser til. En pod kan bestå av en eller flere containere. En Altinn 3 applikasjon vil typisk bestå av en app container og en såkalt sidecar container som kjører Linkerd. Linkerd er den komponenten som tar seg av kryptering/dekryptering av kommunikasjon mellom pods i et cluster. Grunnen til at vi nevner denne er at denne også vil kreve minne og CPU ressurser.\nDeployments En deployment styrer levetiden til en applikasjon, hvor mange instanser den skal ha samt allokering av minne og CPU. I Altinn 3 spesifiseres dette ved hjelp av såkalte Helm charts,. Dette kan sees på som en innpakking av en applikasjon med fornuftige standard verdier, men standard konfigurasjonen kan overstyres.\nMerk: Noe av ressursene i et Kubernetes cluster vil gå med til systemtekniske prosesser både fra Kubernetes selv og fra Altinn infrastrukturen, så ikke alle ressurser i et cluster vil være tilgjengelig til fordeling til apps.\nRessurserfordeling\rHvilke ressurser fordeles i et cluster og hvordan?\nTips til ressurserfordeling\rHva kan/bør man gjøre utover standard innstillinger?\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/",
	"title": "Konfigurasjon",
	"tags": [],
	"description": "Konfigurering av ulike aspekter av en app.",
	"content": "\rMeldingsboks\rKonfigurasjon av presentasjon av applikasjonsinstanser i meldingsboksen i Altinn.\nDefinere autorisasjonspolicy\rI Altinn Studio designer kan applikasjonsutvikleren definere policyen for applikasjonen som er opprettet\nAktørtyper\rHvordan sørge for at kun bestemte typer aktører kan bruke en app.\nDatafelter på instansobjektet\rKonfigurasjon av datafelter for app.\nDefinere applikasjonsprosess\rHvordan definere prosessen til en app.\nQuery parametere\rTilgjengelige query parametere for en app.\nSecrets\rHow to deal with secrets and sensitive data in an app.\neFormidling\rHvordan konfigurere eFormidling integrasjon for en app.\nEvents\rHvordan lage egendefinerte events for en app.\nSettings og miljøvariabler\rHvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.\nKonfigurer appens oppførsel under oppstart\rHvordan konfigurere applikasjonens oppførsel under oppstart av app-frontend\nStateless applikasjon (innsynstjeneste)\rHvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart\nDeployment\rKonfigurering av deploy og kjøretids oppsett\nKonfigurasjon av autentisering\rNår det gjelder autentisering er det noen konfigurasjoner som kan være aktuell\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/likert/",
	"title": "Likert",
	"tags": [],
	"description": "Hvordan ta i bruk en likert komponent",
	"content": "Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer snart.\nMerk at Likert-komponenten kun kan benyttes som del av en repeterende gruppe.\nDesktop og mobil visning Likert komponenten vises som en liste ved smale skjermer og som en tabell ved brede skjermer. Likert utnytter seg av samme konsept som repeterende grupper.\nEksempel Likert komponenten krever at du har en datamodel med en liste. Denne listen må innholde objekter med spørsmål og svar. Eksempel på oppsett av datamodel i App\\logic\\InstantiationHandler.cs:\npublic async Task DataCreation(Instance instance, object data) { if (data is Survey) { var survey = data as Survey; survey.Questions = new List\u0026lt;Question\u0026gt; { new Question { Id = \u0026#34;question-1\u0026#34;, Answer = \u0026#34;\u0026#34; }, new Question { Id = \u0026#34;question-2\u0026#34;, Answer = \u0026#34;\u0026#34; }, new Question { Id = \u0026#34;question-3\u0026#34;, Answer = \u0026#34;\u0026#34; } } } await Task.CompletedTask; } Eksempel på definisjon av likert komponent i layout.json:\n[ { \u0026#34;id\u0026#34;: \u0026#34;likert-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Skolearbeid\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;På de neste spørsmålene skal du svare i kontekst av klasserommet.\u0026#34; }, \u0026#34;maxCount\u0026#34;: 99, \u0026#34;children\u0026#34;: [ \u0026#34;likert-row\u0026#34; ], \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Questions\u0026#34; }, \u0026#34;edit\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;likert\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;likert-row\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Likert\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;likert-row-title\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Questions.Answer\u0026#34; }, \u0026#34;optionsId\u0026#34;: \u0026#34;likertOptions\u0026#34;, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: false } ] Likert-komponenten fungerer likt som RadioButtons og CheckBoxes.\rOptionsId knyttes opp mot kodeliste-fil (likertOptions.json)\n[ { \u0026#34;label\u0026#34;: \u0026#34;Alltid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;Nesten alltid\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;2\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;Ofte\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;3\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;Noen ganger\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;4\u0026#34; }, { \u0026#34;label\u0026#34;: \u0026#34;Sjelden\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;5\u0026#34; } ] For å binde opp tekst for hver rad må man opprette en binding mellom datamodellen og likerten sin tekstResourcebinding. Dette kan gjøres i tekst-ressursfilene:\n[ { \u0026#34;id\u0026#34;: \u0026#34;question-1\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Gjør du leksene dine?\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;question-2\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Fungerer kalkulatoren din?\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;question-3\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Er pulten din ryddig?\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;likert-row-title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{0}\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;Questions[{0}].Id\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } ] Filtrer ut spørsmål med start og end Du kan velge å filtrere rader du ikke ønsker å inkludere i likerten ved å benytte start og stop:\n{ \u0026#34;edit\u0026#34;: { \u0026#34;mode\u0026#34;: \u0026#34;likert\u0026#34;, \u0026#34;filter\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;start\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;1\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;stop\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;10\u0026#34; } ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/",
	"title": "Meldingsboks",
	"tags": [],
	"description": "Konfigurasjon av presentasjon av applikasjonsinstanser i meldingsboksen i Altinn.",
	"content": "\rPresentasjonsfelter\rKonfigurasjon av presentasjonsfelter for app.\nSkjule instanser\rKonfiurasjon for å skjule instanser fra meldingsboksen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/texts/translation/",
	"title": "Oversettelse av tekster",
	"tags": [],
	"description": "Hvordan oversette tekster i applikasjonen.",
	"content": "Selve logikken rundt oversettelse av tekster benytter seg av tekst-ressursfiler. Se Tekster for mer informasjon om disse filene. Det er mulig å oversette tekster i applikasjonen ved å legge til flere tekst-ressursfiler. Altså én fil per språk. Under kan man se et eksempel på norsk og engelsk:\nresource.nb.json\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;language.selector.label\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Språk\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;language.full_name.nb\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Norsk bokmål\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;language.full_name.en\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Engelsk\u0026#34; } ] } resource.en.json\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;language.selector.label\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Language\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;language.full_name.nb\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Norwegian bokmål\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;language.full_name.en\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;English\u0026#34; } ] } Aktivere oversettelse For å kunne utføre oversettelse av tekster i applikasjonen må komponenten aktiveres. Ved å legge til feltet showLanguageSelector og sette feletet til true i Settings.json vil en nedtreksmeny være tilgjengelig i applikasjonen. I tillegg må tekstene fra eksemplet over være definert for at nedtreksmenyen skal vises.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;components\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [...] }, \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [...], \u0026#34;showLanguageSelector\u0026#34;: true } } Om applikasjonen inneholder flere layout-sets og man ønsker muligheten til å oversette alle sider er det viktig at showLanguageSelector legges til i alle Settings.json.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/runtime-environment/resource-allocation/",
	"title": "Ressurserfordeling",
	"tags": [],
	"description": "Hvilke ressurser fordeles i et cluster og hvordan?",
	"content": "Primært vil det være CPU og minne som fordeles. Man kan sette minimum (requests) og et tak (limit) for en container. Hvis en pod har flere containere vil kubernetes summere opp disse.\nI Altinn 3 benytter vi som default requests, dvs. minimum for hva en applikasjon vil legge beslag på.\nCPU CPU spesifiseres i CPU enheter, hvor 1 CPU enhet = 1 fysisk CPU kjerne eller 1 virtuell kjerne. Man kan spesifisere fraksjoner og enten spesifisere 0.1 eller 100m (som leses hundre millicores). Vi anbefaler at man benytter m notasjonen og ikke desimal notasjonen slik at man skriver 1m og ikke 0.001 (som er det minste man kan spesifisere).\nSom standard har man 12 kjerner til fordeling i TT02, dvs. 12 000m, gitt dagens oppsett med 6 noder á 2 kjerner. Fra dette må vi trekke fra de systemtekniske containerne som kubernetes selv kjører, det tilsvarer ca. 30% av CPU, da er vi nede i 8000m til fordeling til Altinn 3 applikasjoner.\nFor en app er CPU satt som default til 50m. Dvs. man skal i teorien ha plass til 8000 / 50m = 160 apps på et slikt cluster. Men en app vil som standard kjøres opp i 2 instanser, da har vi brukt 2x50m=100m. I tillegg har hver app en såkalt sidecar container (Linkerd for kryptering/dekryptering) som får 25m. Denne følger instansen og det blir da 2x25=50m. Så en app vil da totalt kreve 150m for 2 instanser. Gitt 8 cpu’er tilgjengelig så får vi 53 apps med dagens oppsett. Dette er veiledende tall, men gir en grei pekepinn. Hvis en app krever mer CPU enn minimum vil den få det gitt at det finnes mer tilgjengelig.\nMinne Minne spesifiseres i byte, og man kan benytte ulike suffixer som Mi, M Ki etc. Altinn 3 spesifiserer dette i Mi som er Mebibyte som er tilnærmet det samme som Megabyte.\nSom standard har vi 48GiB (Gibi Byte) minne tilgjengelig i clusteret totalt, men dette er fordelt med 8GiB på hver av de 6 nodene. Fra dette må vi trekke fra ca. 0.5 - 1GiB som går til systemtekniske containere som kubernetes selv kjører, det tilsvarer ca. 10-20%. Dvs. at vi da har 6 noder x 7Mi = 42GiB (40054Mi) totalt i clusteret og 7GiB (7168Mi) per. Node til fordeling.\nFor en app er minne satt til 128Mi som default. Dvs. man skal i teorien ha plass til 7168Mi / 128Mi = 56 app instanser per node og 336 apps totalt i clusteret hvis vi kun ser på minne. Når vi ser på tallene over minneforbruk så er det et overforbruk av minne, så 256Mi er nok et bedre tall per app. Korrigert for dette så kan vi halvere tallene slik at det blir 24 app instanser per node og 168 app instanser totalt i clusteret.\nHvordan fungerer ressursallokering i clusteret? Når en ny app skal deployes til et Kubernetes cluster vil Kubernetes litt forenklet se på hvor mye minne og CPU det er spurt om som minimum og prøve å finne node som har ledig plass. Hvis den ikke finner en node med ledig plass så vil den se om det er noen av de kjørende applikasjonene som overforbruker ressurser i forhold til hva de har spurt om å kaste ut den eller de som har høyest overforbruk for å gi plass til den nye.\nMerk: Det at Kubernetes vil kaste ut en applikasjon som overforbruker gjør det svært viktig å ha et forhold til hvor mye ressurser man har tilgjengelig, hvor mye hver enkelt app krever og at summen av dette går opp - hvis ikke risikerer man ustabilitet i miljøet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/technology/",
	"title": "Teknologi",
	"tags": [],
	"description": "Systemdokumentasjon for Altinn Studio, Altinn Apps og Altinn Platform.",
	"content": "Dokumentasjon for teknologi er foreløpig kun tilgjengelig på engelsk.\nLøsningene\rDen nyeste generasjonen Altinn-plattform lar deg bygge, teste, kjøre og overvåke dine digitale tjenester i skyen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/texts/",
	"title": "Tekster",
	"tags": [],
	"description": "Hvordan editere og formatere tekster, bruke variabler og legge til hjelpetekster.",
	"content": "Tekster lagres i ressursfiler i katalogen App/config/texts. Tekster kan være fra felles biblioteker, datamodellen eller manuelt lagt inn av utvikler.\nTekstressursene er tilgjengelig når man redigerer UI komponenter i skjemaet via Altinn Studio, og de vises til sluttbruker når skjemaet lastes inn i nettleser.\nTekster lagres i JSON-format og det er én fil pr språk. Format på filnavn for tekster er resource.[språk].json f.eks: resource.nb.json.\nFormatering av tekster Alle tekster kan formateres med markdown. Nedenfor er de mest benyttede formateringene beskrevet.\nMer omfattende dokumentasjon og tips til hvordan markdown kan benyttes finnes her: Markdown Cheatsheet.\nUthevede tekster Det er ekstremt enkelt å gjøre ord eller setninger fet eller kursiv i markdown.\nDette er en _kursiv tekst_ laget med understrek. Dette er også en *kurvis tekst* laget med stjerne. Dette er __fet tekst__ laget med understrek. Dette er også **fet tekst**, men laget med stjerner! Lenker Trykk [her](https://altinn.no) for å komme til Altinn. Overskrifter # Dette er en stor heading (H1) ## Dette er en litt mindre heading (H2) ### Og enda litt mindre (H3) #### Bitteliten heading (H4) Legge til og endre tekster i en app Man har to alternativer når man skal endre tekster i en app, enten gjøres det via Altinn Studio eller direkte i repository.\nTeksteditor i Altinn Studio Designer I den øverste navigeringsmenyen i Altinn Studio, velg Språk for å kunne redigere tekster. En oversikt over tekstene som allerede er tilgjengelig for applikasjonen listes opp.\nPå denne siden kan man redigere eksisterende tekster samt legge til nye teksressurser. Nye tekster legges til ved å trykke på Ny tekst, og fylle ut tekst og en unik nøkkel.\nLagre endringer i tekstene ved å trykke på Lagre tekster.\nLegge til og endre tekster i repository Dersom det er mange tekster som skal endres på en gang kan det være praktisk å redigere tekstene i JSON-struturen direkte i repoet. Enten via Altinn Studio Repos eller i en lokal klone i selvvalgt kodeeditor.\nTekstene ligger lagret i App/config/texts\nVariabler i tekster Variabler i tekster kan inkluderes ved å følge oppsettet nedenfor. Det er viktig at rekkefølgen på variablene er den samme som parameterne i teksten.\n{ \u0026#34;id\u0026#34;: \u0026#34;good.text.id\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Hello, {0}! Here is a second variable {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;datamodelField\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.\u0026lt;dataModelName\u0026gt;\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;settings key\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;applicationSettings\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;\u0026lt;instance value key\u0026gt;\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;instanceContext\u0026#34; } ] } Datakilder Det er per nå mulig å hente verdier fra 3 ulike datakilder.\nDatamodel\nVed å angi dataModel.\u0026lt;dataModelNavn\u0026gt; som datakilde kan man hente ut verdier fra felter i skjema som brukeren fyller ut. Data kan hentes fra felter uavhengig av om de er synlige eller ikke. Hvis bruker endrer på data i et felt referert i en variabel så vil teksten bli oppdatert når brukeren stopper å skrive i feltet. Instillinger\nVed å angi applicationSettings som datakilde kan man hente ut verdier fra en spesiell seksjon i appsettings.{miljø}.json filen(e) med navn FrontEndSettings. Dette er en dynamisk liste man kan utvide uten å måtte gjøre endringer i kode. Dette gjør det mulig å ha ulike verdier fra miljø til miljø ved å ha andre verdier i de ulike appsettings.{miljø}.json filene. Vær obs på ulik bruk av stor bokstav i starten av nøkkel mellom FrontEndSettings og applicationSettings. \u0026#34;FrontEndSettings\u0026#34;: { \u0026#34;HomeBaseUrl\u0026#34;: \u0026#34;https://www.testdirektoratet.no\u0026#34; }, Instans\nVed å angi instanceContext som datakilde kan man hente ut enkelte verdier fra den aktive instansen. Vi har altså ikke gitt tilgang til hele instanse objektet. Listen med egenskaper så langt er: instanceOwnerPartyId inneholder avgiver sin party id. instanceId inneholder id\u0026rsquo;en til den aktive instansen. appId inneholder id\u0026rsquo;en til appen instansen er knyttet til. Komplett eksempel: { \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}. Organisasjonens party id er {2}. [Link til oss]({3}).\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnavn\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig.organisasjonsnummer\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;instanceOwnerPartyId\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;instanceContext\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;homeBaseUrl\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;applicationSettings\u0026#34; } ] } Variabler i tekst - repeterende grupper For at variabler i tekst skal fungere med data som ligger i repeterende grupper, må oppsettet vist over endres litt for de aktuelle feltene, for å spesifisere den repeterende gruppen dataene ligger i.\nDette gjøres ved å legge til [{0}] etter den repeterende gruppen når man spesifiserer felt i datamodellen i key-parameteren. F.eks.:\n{ \u0026#34;id\u0026#34;: \u0026#34;common.submitinfo\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du leverer nå skjema for: {0} med organisasjonsnummer: {1}.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnavn\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;skattepliktig[{0}].organisasjonsnummer\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } Det er fullt mulig å kombinere variabler fra felter i repeterende gruppe med variabler fra felter utenom den repeterende gruppen. Det anbefales derimot ikke å kombinere variabler fra felter fra forskjellige repeterende grupper, med mindre man er helt sikker på at rekkefølgen på innslag i gruppene vil bli helt like.\nLegge til hjelpetekst Hjelpetekster er små tekstsnutter som gir en kort og konsis beskrivelse av hva sluttbrukeren er forventet å fylle ut i feltet som teksten er tilknyttet.\nSpråknøklene som peker på hjelpeteksten er definert i FormLayout.json. I app repoet finner du filen under App/ui/.\nNedenfor ser du et eksempel på en FormLayout.json uten hjelpetekster.\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;appName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Dersom du skulle ønske å legge til hjelpetekst på en av disse skjemakomponentene må du\nLegge til hjelpeteksten i tekstressursfilen som beskrevet her. Åpne FormLayout.json-filen. Legg til en binding til den nye hjelpeteksten med nøkkel \u0026quot;help\u0026quot; og verdi lik nøkkel til tekstressursen. Slik ser hele filen ut etter å ha lagt til en hjelpetekst:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;616071dc-90b1-4ce5-8d18-492844828a41\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;componentType\u0026#34;: 0, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;appName\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {} }, { \u0026#34;id\u0026#34;: \u0026#34;08d707a9-2475-4d23-bf76-f209fb434ec2\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;componentType\u0026#34;: 7, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tilleggsopplysninger.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;tilleggsopplysninger.desc\u0026#34;, \u0026#34;help\u0026#34;: \u0026#34;tilleggsopplysninger.help\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;omsetningsoppgaverTilleggsopplysninger.value\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;bd6589b6-e2ab-49ba-b39a-dd3f8b63e5de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;componentType\u0026#34;: 9, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Send inn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Endre applikasjonstittel Når man oppretter en applikasjon vil man ha en tekstressurs med label appName. Dette er tittelen på applikasjonen som vil gjenspeiles flere steder i løsningen vår. Blant annet når en sluttbruker fyller ut skjema, og når elementer skal vises i meldingsboksen på altinn.no.\nTittelen på applikasjonen skal ligge to steder i applikasjonsrepoet:\nI tekstressurser med nøkkelen appName. Tjenesteeiere oppfordres til å legge inn tittel på bokmål, nynorsk og engelsk. Dersom tittel mangler i tekstressursene vil lagringsnavnet (navnet på repoet) vises til sluttbrukeren.\nI applicationmetadata.json under property title. Denne filen ligger under App/config/.\nDersom man gjør endrer appName på applikasjonen sin lokalt er det viktig at også legge til den oppdatere tittelen i applicationmetadata.json også. Dersom tittel på applikasjonen endres i Altinn Studio enten på \u0026ldquo;Om\u0026rdquo; eller \u0026ldquo;Språk\u0026rdquo;-siden bli applicationmetadata.json oppdatert automatisk.\nEksempel på korrekt konfigurasjon for applikasjonstittel I App/config/applicationmetadata.json:\n\u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;nn\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34;, \u0026#34;en\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, I App/config/texts/resource.nb.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.nn.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;nn\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Automatisk deploy applikasjonen\u0026#34; }, . . . ] } I App/config/texts/resource.en.json:\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Auto deploy application\u0026#34; }, . . . ] } Endre applikasjonseier tekst I applikasjonen så vises applikasjonsnavn og applikasjonseier-tekstene øverst i skjema.\nApplikasjonsnavn hentes som standard ut fra tekstene som er definert i altinn-orgs.json. Om det er ønskelig å endre på dette navnet kan det gjøres ved å legge til nøkkelen appOwner i tekstressursene. Denne vil da overstyre det som ligger på CDN.\nEksempel:\n{ \u0026#34;language\u0026#34;: \u0026#34;en\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;appOwner\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Test Ministry\u0026#34; }, . . . ] } Endre tekster på kvitteringssiden for arkiv Tekster på kvitteringssiden kan overstyres av applikasjonen ved å spesifisere tekster i applikasjonens config/texts/resource.xx.json fil.\nOverstyring av tekster i kvitteringen vil ha påvirkning for alle kvitteringer for den gitte applikasjonen. Dette betyr at alle skjemaer som allerede er insendt vil også få det oppdaterte tekstene på kvitteringssiden. PDF filen som er generert vil ikke påvirkes av dette.\rMarkdown og variabler kan benyttes i kvitteringstekstene. Det er kun mulig å hente variabler fra Instance (Se Data Sources for detaljer)\nDette er tekstnøklene som kan brukes for å overstyre standardtekstene:\nreceipt_platform.attachments receipt_platform.date_sent receipt_platform.helper_text receipt_platform.is_sent receipt_platform.receipt receipt_platform.receiver receipt_platform.reference_number receipt_platform.sender receipt_platform.sent_content Hvis du for eksempel vil overstyre hjelpeteksten, kan du legge dette til i config/texts/resource.nb.json filen i applikasjonen:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;receipt_platform.helper_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Min egendefinerte hjelpetekst\u0026#34; } ] } Bildet nedenfor viser hvilke tekstnøkler som styrer hvilken del av brukergrensesnittet:\nMerk! Disse tekstendringene vil ikke være synlige når du tester appen din lokalt, de synes kun i eksternt testmiljø, f.eks.TT02. Du vil se endringene når du åpner et allerede arkivert skjema fra Arkivet ved å trykke på knappen \u0026ldquo;Se innsendt skjema\u0026rdquo;. Per nå blir ikke disse modifiserte tekstene brukt under selve innsendingen av skjemaet (det ligger en sak på dette på github).\nOversettelse av tekster\rHvordan oversette tekster i applikasjonen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/runtime-environment/resource-allocation-tips/",
	"title": "Tips til ressurserfordeling",
	"tags": [],
	"description": "Hva kan/bør man gjøre utover standard innstillinger?",
	"content": "Før vi går på konkrete tips må vi kort introdusere Helm Chart. Helm Chart er de(n) filen(e) som styrer hvordan applikasjonen din deployes) til Kubernetes. Det er også her man styrer CPU og minne allokering. Du finner Chart.yamlog values.yamli deployment mappen i applikasjonen din. Dette er viktige filer som kan være lett å overse og ikke ha et aktivt forhold til.\nTips 1 - Kjør siste versjon av Helm Chart Med siste versjon får du de mest oppdaterte innstillingene som standard. Se Endringslogg for deployment for hvordan oppgradere til siste versjon.\nTips 2 - Ha et aktivt forhold til hva applikasjonen krever av minne og CPU Altinn kommer med en standard på 50m CPU og 128Mi minne, men hva som faktisk kreves er det jo bare den som utvikler en applikasjon som vet. Hvis det caches mye data, vil det kreve mye minne. Hvis det er tunge operasjoner så vil det kreve mye CPU. De faktiske kravene bør gjenspeiles i Helm Chart hvis de avviker fra standarden.\nTips 3 - Reduser antall instanser i testmiljø Trenger man 2 kjørende instanser i test eller kan man klare seg med 1? Ønsker man å teste hvordan en app oppfører seg med flere instanser så trenger man nødvendigvis 2 eller flere, men ofte så holder det men 1 kjørende instans i test og man tåler litt nedetid ved deploy.\nMerk: Har man gjort de tiltakene man kan, men alikevel har nådd taket på hva clusteret håndterer så er neste steg å øke antallet noder evt. ha kraftigere noder. Ta kontakt med oss i Altinn så ser vi på dette sammen med dere.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/develop-component/",
	"title": "Utvikle en komponent",
	"tags": [],
	"description": "Start gjerne utviklingen av ny funksjonalitet eller nye komponenter som er godkjent av Altinn. Vi setter pris på om du planlegger arbeidet ditt med oss før du begynner.",
	"content": "Før du starter utvikling av ny funksjonalitet kan det være lurt å sjekke om oppgaven allerede ligger i backloggen vår. Om du ikke finner den vil vi gjerne at du først foreslår ønsket funksjonalitet/komponent og starter en dialog med oss før utviklingen starter.\nVi stiller samme krav til eksterne bidrag som vi gjør til vår egne. Før utviklingen starter vil vi derfor gjerne være med å spesifisere hvordan komponenten skal løses både når det gjelder design og tekniske beslutninger. Det beste for å få til en bra flyt er en dialog.\nI dialog med deg vil vi:\nFinne ut hva komponenten skal dekke og diskutere løsningen Er det mangler i designskisser eller teknisk løsning som må utbedres Trenger du hjelp med design eller brukertesting Utviklingshåndbok All informasjon du trenger for komme i gang finner du i vår utviklingshåndbok. Håndboken inneholder blant annet informasjon du trenger for å skrive konsistent kode og bygge nye komponenter.\nTilgjengelighetstest Apper bygget på Altinn 3 skal være tilgjengelig for alle og for å forsikre oss om dette skal vi oppfylle WCAG 2.1 rettningslinjene. Se kravene beskrevet på UU-tilsynet eller a11yproject.\nReview av komponent Når en pull request blir laget vil vi gjøre en review av komponenten din. Forhåpentligvis har vi blitt enige om hvordan komponenten skal løses på forhånd slik at ikke de store endringene blir i denne delen av prosessen.\nTesting WCAG-testing Code review Design review Dersom vi finner noe som bør utbedres kontakter vi deg for videre utvikling.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/",
	"title": "Utvikling",
	"tags": [],
	"description": "Hvordan opprette og redigere apper i Altinn Studio.",
	"content": "\rData\rKonfigurering av datamodell, preutfylling og andre ting relatert til data i en app.\nApp brukergrensesnitt\rKonfigurering av komponenter, layouts, sider, grid, etc.\nLogikk\rHvordan legge til, endre og konfigurere applikasjonslogikk som validering, kalkulering, dynamikk m.m.\nKonfigurasjon\rKonfigurering av ulike aspekter av en app.\nAPI\rAppene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/",
	"title": "API",
	"tags": [],
	"description": "Appene som man utvikler i Altinn Studio kan både eksponere standard og custom APIer samt benytte seg av APIer. Slik gjør du det.",
	"content": "\rEksponere APIer fra en app\rMan kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.\nInstans\rHvordan gjøre endringer på applikasjonsinstanser\nKonsumere APIer i en app\rEn applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/checkbox/",
	"title": "Avkrysningsboks",
	"tags": [],
	"description": "Avkrysningsbokser brukes i tilfeller der brukeren kan huke av ett eller flere alternativer fra en liste.",
	"content": "Dersom brukeren kun kan velge et av alternativene, bruk radioknapper i stedet.\nRetningslinjer: Avkrysningsboksene skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte avkrysningsbokser bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "App API å jobbe med forekomster av en app.",
	"content": "Overview An instance can be regarded as an envelope or folder where data is collected and exchanged between the application user and owner. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance lives and how many interactions there are between the application owner and user will vary from one app to another. Advanced apps will have their own documentation.\nbasePath\n{org}/{appname}/instances Get instance Endpoint for downloading the instance metadata document for a specific instance. The app API does not have an endpoint for listing instances. The Storage API in the Platform has a query endpoint that can be used for this purpose.\nUse this endpoint for instances that are active, and the owner party id and instance guid for the instance are known. External systems that work with an instance over multiple sessions might want to keep these values (or full URL) stored on their end to limit the need to query this information multiple times.\nGET {basePath}/{instanceOwnerPartyId}/{instanceGuid} Get active instances Endepunkt for å liste aktive instanser for en avgiver.\nDette endepunktet kan benyttes for å avgjøre om en ny instans av en app skal opprettes eller om det er mer hensiktsmessig å fortsette utfylling av en eksisterende instans. Merk at objektet som returneres er en liste med forenklede instansobjekt og at LastChangedBy inneholder navnet på den sist aktive entiteten i stedet for id.\n[ { \u0026#34;id\u0026#34;: \u0026#34;1337/bffd2c17-9d93-49f4-b504-3d0ece2402c7\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-09-23T10:19:43\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; }, { \u0026#34;instanceId\u0026#34;: \u0026#34;1337/agfd2c17-4d93-49f4-b504-3d0ece2402d8\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2021-07-11T22:14:02\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;Sophie Salt\u0026#34; } ] GET {basePath}/{instanceOwnerPartyId}/active Create instance Altinn assigns a unique identifier to all users that wish to report data. We call this id instanceOwner.partyId. If you do not know this, you should provide the official identity number, e.g national identification number for persons or organisation number for organisations, and in some case user name. This should be provided as part of the payload to the creation request. Altinn will look up this identifier and replace it with the instanceOwner.partyId. The official identity number will be stored in the instance metadata.\nData elements can be provided as part of the creation request, but can also be uploaded at a later time.\nThe client specifies the instance owner and may set a number of the metadata fields of the instance by attaching the following form:\n{ \u0026#34;appId\u0026#34; : \u0026#34;org/app\u0026#34;, \u0026#34;instanceOwner\u0026#34;: { \u0026#34;personNumber\u0026#34;: \u0026#34;12247918309\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;dueBefore\u0026#34;: \u0026#34;2019-06-01T12:00:00Z\u0026#34;, \u0026#34;visibleAfter\u0026#34;: \u0026#34;2019-05-20T00:00:00Z\u0026#34; } Notice that all dates must be expressed in Utc (Zulu) time zone and represented according to ISO 8601!\nData elements (files) can be attached to the initial request as a multipart/form-data or as attachments. The name of the parts must correspond to element types defined in the application metadata.\nPOST {basePath} A multipart/formdata should contain the instance json document and the data element files of the instance. The first part should be instance which contains the json template to create an instance from.\nThe subsequent parts must have a name that correspond to the element types defined in application metadata. They may have a filename. Hence the model1 and certificate names correspond to data types defined in the application metadata. If additional data elements are required they must be defined in the application metadata.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { ... } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;model1\u0026#34; \u0026lt;xml\u0026gt; ... \u0026lt;/xml\u0026gt; --abcdefg Content-Type: application/pdf Content-Disposition: form-data; name=\u0026#34;certificate\u0026#34;; filename=certificate.pdf %PDF-1.4 %Óëéá 1 0 obj ... --abcdefg-- This call will return the instance metadata document that was created.\nSimplified instansiation For scenarios where the multipart is not required there is a new API that is simpler. It supports both key-value prefilling and copying data from an archived instance.\nThe endpoint is available at\nPOST {basePath}/create Required body differs for the two features, and examples of the request body are available below.\nInstantiation with key-value prefill { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;personNumber\u0026#34;: \u0026#34;12247918309\u0026#34;, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;prefill\u0026#34;: { \u0026#34;navnGarantist\u0026#34; : \u0026#34;Ole Hansen\u0026#34; }, \u0026#34;dueBefore\u0026#34;: \u0026#34;2019-06-01T12:00:00Z\u0026#34;, \u0026#34;visibleAfter\u0026#34;: \u0026#34;2019-05-20T00:00:00Z\u0026#34; } Instantiation from archived instance { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;partyId\u0026#34;:\u0026#34;50002108\u0026#34;, \u0026#34;personNumber\u0026#34;: null, \u0026#34;organisationNumber\u0026#34;: null }, \u0026#34;sourceInstanceId\u0026#34;: \u0026#34;50002108/049622b8-ea06-40f6-9f1b-26ceb7566232\u0026#34; } Update sub status The instance sub status is used to give an end user further details about the state of their instance. Currently, only application owner is allowed to update substatus for an instance. Include the new substatus in the body of the requests as a json.\nPUT {basePath}/{instanceOwnerPartyId}/{instanceGuid}/substatus Request body\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } The values can be referencing text resource names from the language files or be regular text.\nComplete instance Endpoint used by application owner to mark an instance as completed. Technically this only means that the instance is no longer needed by the application owner.\nAltinn will permanently delete an instance and all the data, if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nPOST {basePath}/{instanceOwnerPartyId}/{instanceGuid}/complete The request does not use the request body for anything even though it is a POST request.\nDelete instance Endpoint for marking an instance as deleted. This can be used by both application owner and user to delete an instance. The endpoint has an optional parameter called hard that can be used to indicate the type of delete that is wanted. Setting the parameter to false or simply omitting it, will move the instance to a recycle bin. Hard delete means that the instance will be unrecoverable.\nInstances that where active might be permanently deleted by Altinn within a few days. Archived instances will be permanently deleted if both application owner and a user with the necessary rights indicate on the instance that they no longer have a need for it.\nDELETE {basePath}/{instanceOwnerPartyId}/{instanceGuid}?hard=true The endpoint does not use the request body for anything.\nThere are no Application API endpoint for recovering instances in the recycle bin.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/components/listcomponent/",
	"title": "Listekomponent",
	"tags": [],
	"description": "",
	"content": "Listekomponenten kan brukes til å presentere innholdsrike data til bruker i tabellformat. Hver rad i tabellen er velgbar. Komponenten støtter søk, sortering og paginering.\nDette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre. Støtte for oppsett via Altinn Studio kommer senere.\rHvordan definere komponenten i skjema Komponenten er av typen List. Eksempel på hvordan man kan definere kompoenten i layout.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;list-component\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;List\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Hvem gjelder saken?\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;SelectedItem\u0026#34;, \u0026#34;profession\u0026#34;: \u0026#34;SelectedItemProfession\u0026#34; }, \u0026#34;bindingToShowInSummary\u0026#34;: \u0026#34;SelectedItem\u0026#34;, \u0026#34;dataListId\u0026#34;: \u0026#34;people\u0026#34;, \u0026#34;tableHeaders\u0026#34;: [ \u0026#34;Navn\u0026#34;, \u0026#34;Alder\u0026#34;, \u0026#34;Yrke\u0026#34; ], \u0026#34;sortableColumns\u0026#34;: [ \u0026#34;Alder\u0026#34; ], \u0026#34;pagination\u0026#34;: { \u0026#34;alternatives\u0026#34;: [ 5, 10 ], \u0026#34;default\u0026#34;: 5 }, \u0026#34;required\u0026#34;: \u0026#34;true\u0026#34; }, Populering av tabell Listekomponenten populeres med dynamiske data. Dataene defineres i en egen fil som implementerer interfacet IDataListProvider. Dette fungerer tilsvarende kodelister/options. Feltet dataListId må legges til på komponenten som definerer hvilken dataliste komponenten referer til. Dynamiske datalister kan enten være åpen eller sikret. Eksempel på en klasse som implementerer interfacet IDataListProvider\npublic class ListCases : IDataListProvider { public string Id { get; set; } = \u0026#34;people\u0026#34;; public async Task\u0026lt;DataList\u0026gt; GetDataListAsync(string language, Dictionary\u0026lt;string, string\u0026gt; keyValuePairs) { int start = 0; int count = 10; if (keyValuePairs.ContainsKey(\u0026#34;size\u0026#34;) \u0026amp;\u0026amp; keyValuePairs.ContainsKey(\u0026#34;page\u0026#34;)) { string size = keyValuePairs[\u0026#34;size\u0026#34;]; string page = keyValuePairs[\u0026#34;page\u0026#34;]; start = int.Parse(size) * int.Parse(page); count = int.Parse(size); } List\u0026lt;ListItem\u0026gt; items = new List\u0026lt;ListItem\u0026gt;(); items.Add(new ListItem { Name = \u0026#34;Caroline\u0026#34;, Age = 28, Profession = \u0026#34;Utvikler\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Kåre\u0026#34;, Age = 37, Profession = \u0026#34;Sykepleier\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Johanne\u0026#34;, Age = 27, Profession = \u0026#34;Utvikler\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Kari\u0026#34;, Age = 56, Profession = \u0026#34;Snekker\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Petter\u0026#34;, Age = 19, Profession = \u0026#34;Personlig trener\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Hans\u0026#34;, Age = 80, Profession = \u0026#34;Pensjonist\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Siri\u0026#34;, Age = 28, Profession = \u0026#34;UX designer\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Tiril\u0026#34;, Age = 40, Profession = \u0026#34;Arkitekt\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Karl\u0026#34;, Age = 49, Profession = \u0026#34;Skuespiller\u0026#34; }); items.Add(new ListItem { Name = \u0026#34;Mette\u0026#34;, Age = 33, Profession = \u0026#34;Artist\u0026#34; }); if (keyValuePairs.ContainsKey(\u0026#34;sortDirection\u0026#34;)) { string sortDirection = keyValuePairs[\u0026#34;sortDirection\u0026#34;]; if (sortDirection == \u0026#34;asc\u0026#34;) { items = items.OrderBy(o =\u0026gt; o.Age).ToList(); } else if (sortDirection == \u0026#34;desc\u0026#34;) { items = items.OrderBy(o =\u0026gt; o.Age).ToList(); items.Reverse(); } } DataListMetadata appListsMetaData = new DataListMetadata() { TotaltItemsCount = items.Count }; List\u0026lt;object\u0026gt; objectList = new List\u0026lt;object\u0026gt;(); items.ForEach(o =\u0026gt; objectList.Add(o)); return new DataList { ListItems = objectList.GetRange(start, count), _metaData = appListsMetaData }; } } Her blir listen laget i koden, men her kan man istedet kalle på et annet API som returnerer data man vil vise i tabellen. Hvis dette APIet støtter sortering og paginering kan man videresende disse verdiene til APIet slik at man ikke henter unødvendig data.\nKolonner Hvilke kolonner tabellen skal bestå av defineres med feltet tableHeaders. Dette feltet er en array av strings. For å støtte flere språk kan man bruke referanser til nøkler i språkfilene her. Det er innholdet er som vil stå i header av tabellen. Du må selv sørge for at dataene i tabellen populeres i samme rekkefølge, slik at innholdet i cellene stemmer med header.\nSortering I layout.json definerer du hvilke kolonner som skal være sorterbare gjennom feltet sortableColumns. Dette er en array av strings, og strings du bruker her må være definert som en header i feltet tableHeaders. Dette gjør at de valgte kolonnene får en pil som viser hvilken retning kolonnen er sortert, og kolonnen som styrer sortering nå blir markert. Selve sorteringslogikken må man selv implementere. Metoden GetDataListAsync tar inn parameteren keyValuePairs som inneholder sortDirection og sortColumn til dette formålet. For eksempel direkte i metoden GetDataListAsync slik som gjort i eksempelet over, eller ved å videresende sortDirection.\nPaginering For å definere paginering bruker du feltet pagination som har et objekt som verdi. I dette objektet defineres alternatives som er en array med number som representerer hvilke valg brukeren har for antall rader i listen. I tillegg definerer du default som er default på hvor mange rader som vises i listen. På samme måte som med sortering må pagineringslogikken implementeres slik at riktige data vises, dette gjennom verdiene size og page fra keuValuePairs.\nSøk For at en bruker skal kunne søke i listen/tabellen må man legge til et tekstfelt av typen søk. Dette tekstfeltet knyttes til et felt i datamodellen, og videre bruker man denne verdien i datamodellen til søk. I listekomponenten må man legge til feltet mapping. Den kan se sånn her ut, hvor soknad.navn er et felt i datamodellen:\n\u0026#34;mapping\u0026#34;: { \u0026#34;soknad.navn\u0026#34;: \u0026#34;search\u0026#34; } Verdien på soknad.navn vil da bli sendt i keyValuePairs med key search. OBS! Dette kan selvfølgelig brukes til andre ting enn søk.\nData lagret i datamodellen Valgt rad må lagres i datamodellen, hver kolonne/celle må lagres i eget felt i datamodellen. Dette defineres gjennom dataModelBindings:\n\u0026#34;dataModelBindings\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;SelectedItem\u0026#34;, \u0026#34;profession\u0026#34;: \u0026#34;SelectedItemProfession\u0026#34; }, Her er SelectedItem og SelectedItemProfession felter i datamodellen, og name og profession er properties i modellen som brukes for å beskrive en rad. I eksempelet som er vist her er det laget en datamodell som representerer en rad, og den ser slik ut:\npublic class ListItem { public string Name { get; set; } public int Age { get; set; } public string Profession { get; set; } } Komponenten i oppsummering Dersom man ønsker å vise listekomponenten i oppsummering av skjema vil det vises enkelt med kun en verdi fra valgt rad. Dette defineres med property bindingToShowInSummary, og vil se slik ut:\nSikrede datalister På samme måte som med kodelister kan man for datalister også sikre listene dersom de inneholder sensitive data. Da benytter man interfacet IInstanceDataListProvider, og tillegg må man legge til en secure boolean på komponenten.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/pdf/",
	"title": "PDF",
	"tags": [],
	"description": "Hvordan konfigurere generering av PDF.",
	"content": "Det er mulig å ekskludere enkelte komponenter, eller hele sider fra å bli med i pdf.\nDet er to måter å ekskludere data fra PDF på\nVia konfigurasjon i filen Settings.json under App/ui Programmatisk For den programatiske måten er det noen mindre forskjeller avhengig av hvilke versjon av applikasjonsmalen du er på. v4, v5, v6\rI tidligere versjoner så gjøres endringene i PdfHandler.cs filen under App/logic/Print katalogen.\rv7\rI versjon 7 har vi endret måten vi gjør kode baserte tilpassninger på. Vi benytter nå dependency injection i stedet for overstyring av metoder. Hvis du tidligere plasserte koden din i FormatPdf metoden in PdfHandler.cs klassen så vil du erfare at det er mer eller mindre det samme som nå gjøres.\nOpprett en klasse som implementerer IPdfFormatter grensesnittet som ligger i Altinn.App.Core.Features navnerommet.\nDu kan navngi og plassere filene i den mappestrukturen du selv ønsker i prosjektet ditt. Men vi anbefaler at du benytter meningsfulle navnerom som i et hvilket som helst annet .Net prosjekt. Registrer din implementering i Program.cs klassen services.AddTransient\u0026lt;IPdfFormatter, PdfFormatter\u0026gt;(); Dette sørger for at din kode er kjent for applikasjonen og at koden blir kjørt når den skal. Siden IPdfFormater grensesnittet har samme metode som PdfHandler.cs klassen er resten av dokumentasjonen og eksemplene felles for alle versjoner.\nDersom en side/komponent alltid skal ekskluderes fra PDF er det anbefalt å sette det opp i konfigurasjonsfilen.\nDersom ekskludering av en side/komponent er avhengig av dynamikk må dette gjøres programmatisk.\nEkskludere sider I eksemplene nedenfor ekskluderes siden med id page2 fra PDF.\nKonfigurasjon Oppsett i Settings.json under App/ui:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [\u0026#34;page2\u0026#34;] } } Programmatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Pages ??= new(); layoutSettings.Pages.ExcludeFromPdf ??= new(); layoutSettings.Pages.ExcludeFromPdf.Add(\u0026#34;page2\u0026#34;); } return await Task.FromResult(layoutSettings); } Ekskludere komponenter I eksemplene nedenfor blir komponenten med id image-component-id ekskludert fra pdf.\nKonfigurasjon Oppsett i Settings.json under App/ui:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;components\u0026#34;: { \u0026#34;excludeFromPdf\u0026#34;: [\u0026#34;image-component-id\u0026#34;] } } Programmatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Components ??= new(); layoutSettings.Components.ExcludeFromPdf ??= new(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;image-component-id\u0026#34;); } return await Task.FromResult(layoutSettings); } Ekskludere komponentinnslag i en repeterende gruppe Dersom du ønsker å ekskludere én eller flere komponenter fra et innslag i en repeterende gruppe gjøres dette ved å spesifisere indeksen av gruppeelementet i tillegg til komponent id.\nFormat for ekskludering: componentId-\u0026lt;groupIndex\u0026gt;.\nDersom komponenten skal ekskluderes for alle innslag i den repeterende gruppen kan intruksjonene i seksjonen over følges i stedet.\nI eksempelet nedenfor ekskluderes gruppeelement med indeks 1 og id ownerId fra PDF.\nProgrammatisk public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data.GetType() == typeof(Skjema)) { layoutSettings.Components ??= new(); layoutSettings.Components.ExcludeFromPdf ??= new(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;ownerId-1\u0026#34;); } return await Task.FromResult(layoutSettings); } Bildet illustrerer at komponenten med indeks 0 og 2 er bevart i PDF, mens komponent med indeks 1 er borte.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/",
	"title": "Testing av apper",
	"tags": [],
	"description": "Applikasjoner (apper) kan testes i testmiljø, eller lokalt.",
	"content": "\rTest av app lokalt\rBeskrivelse av hvordan test av app lokalt på egen maskin kan gjøres\nTest app i testmiljø\rBeskrivelse av hvordan test i testmiljø kan utføres.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/data-element/",
	"title": "DataElement",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Et DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.",
	"content": "DataElement The data element model is the main model for metadata related to a specific data element. A data element can be any data associated with an instance. The two most common type of data is the actual form data and attachments.\nProperties Name Description id A globally unique id for the data element. instanceGuid The globally unique id for the instance the data element is associated with. dataType The name of the data type describing the requirements of the data element. filename The data blob name if represented as a file. contentType The mime-type of the content of the blob. blobStoragePath The physical location of the data as it is stored in the Application owner storage account. selfLinks A complex type containing a set of named links of how to obtain a copy of the data element. size The number of bytes in the blob. locked A value indicating whether the blob is read only. refs A list of UUID values. Can be used to link related data elements. isRead A boolean indicating if the dataElement has been read by a user. created The date and time when the data element was first created. createdBy An idenfificator indicating who it was that created the data element. lastChanged The date and time when the data element was last changed. lastChangedBy An idenfificator indicating who it was that made the last change to the data element. Complete example This data element example is from the instance example.\n{ \u0026#34;id\u0026#34;: \u0026#34;8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;bd9edd59-b18c-4726-aa9e-6b150eade814\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Kursdomene_BliTjenesteeier_M_2020-05-25_5703_34553_SERES\u0026#34;, \u0026#34;filename\u0026#34;: null, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/bli-applikasjonseier/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;https://local.altinn.cloud/ttd/bli-applikasjonseier/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;https://local.altinn.cloud/storage/api/v1/instances/1337/bd9edd59-b18c-4726-aa9e-6b150eade814/data/8a8a01ae-9533-4aa9-b914-8ab0fae6ea0d\u0026#34; }, \u0026#34;size\u0026#34;: 401, \u0026#34;locked\u0026#34;: false, \u0026#34;refs\u0026#34;: [], \u0026#34;created\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;createdBy\u0026#34;: null, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-11-18T15:56:43.1089008Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: null } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/radiobutton/",
	"title": "Radioknapp",
	"tags": [],
	"description": "Radioknapper brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder nedtrekksliste, så vær bevisst på når du bruker hvilken.",
	"content": "Radioknapper velges når:\nDu ikke har for mange valgalternativer (Maks 7) Det ikke er et tydelig anbefalt valg Når brukeren enkelt skal kunne sammenligne alternativene Du ønsker at brukeren skal lese alle alternativene Valgalternativene er ukjent for brukeren Retningslinjer: Radioknapper skal stå foran tilhørende tekst, og skal aldri stå alene. Deaktiverte radioknapper bør unngås. Dersom et valg ikke er tilgjengelig bør det heller fjernes og forklares i tekst hvorfor det mangler. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/widgets/",
	"title": "Widgets",
	"tags": [],
	"description": "Hvordan bruke sammensatte komponenter (widgets).",
	"content": "Hva er en widget? En widget er en kompleks komponent, sammensatt av en eller flere enkle skjemakomponenter - de skjemakomponentene som er tilgjengelige for bruk i Altinn Studio i dag. En widget er et verktøy i Altinn Studio som gjør det lettere å lage og gjenbruke layouts.\nHvordan bruke widgets Widgets er tilgjengelige i venstre-menyen i skjemaeditoren i Altinn Studio. Den kan dras inn i skjemasiden på samme måte som andre skjemakomponenter. Når en widget dras inn i skjema i Altinn Studio, legges de skjemakomponentene som er definert som del av widget\u0026rsquo;en til i layouten, sammen med ev. standard oppsett som knytning til datamodell, tekster, osv. Når en widget er dratt inn i skjema, vil man kun se de skjemakomponentene som den er laget av. Disse kan redigeres som normalt i skjemaeditoren. Dersom det er tekster definert for widget\u0026rsquo;en, disse legges til i ressursfilene for tekster automatisk.\nEksempel: Meldings-widget Tilgjengelige widgets Standard widgets Vi vil etter hvert kunne tilby en samling av forskjellige widgets, disse vil dukke opp automatisk i venstre-menyen i skjemaeditoren i Altinn Studio. Listen oppdateres etter hvert som nye widgets legges til. Per nå. er følgende widgets tilgjengelig:\nNavn Beskrivelse Skjermbilde Melding Inneholder komponentene som utgjør en standard melding:\ntittel\nmeldingstekst\nvedlegg\nnavigasjonsknapp\nTekstene er satt opp med referanse til felt i standard melding datamodell. Se her for mer info om meldinger. Egendefinerte widgets I tillegg til standard widgets som kommer opp automatisk i Altinn Studio, er det også mulig å definere sine egne widgets. En widget består av 3 deler:\nKomponenter: Dette er liste over komponentene som skal inngå, inkl. definisjon av disse komponentene. Dette settes opp på samme måte som i layout-filene, man kan f.eks. kopiere ut komponenter direkte fra en layout-fil. Visnings-navn: Dette er teksten som vises i Altinn Studio, i menyen der widget\u0026rsquo;en ligger. Tekstressurser: Dette er valgfritt, og er en liste over tekstressurser på de språk som man ønsker å ha med. Nyttig om komponentene f.eks. skal ha noen standard tekster de bruker. Se oppsett for meldings-widget for et konkret eksempel. Det fins også en widget-mal som kan lastes ned for å komme i gang.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/select/",
	"title": "Nedtrekksliste",
	"tags": [],
	"description": "Nedtrekksliste brukes i tilfeller der brukeren skal velge et alternativ blant flere. Det samme gjelder radioknapper, så vær bevisst på når du bruker hvilken.",
	"content": "Nedtrekksliste velges når:\nDu har mange alternativer (mer enn 5) Du har et anbefalt valg som vises som forhåndsvalgt Det ikke er så viktig for brukeren å kunne sammlenligne alternativene Du ønsker ikke at brukeren skal trenge å lese alle alternativene Valgalternativene er kjent for brukeren Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/helptext/",
	"title": "Hjelpetekst",
	"tags": [],
	"description": "Hjelpetekster er små tekstsnutter som kan benyttes for å gi brukeren ekstra veiledning i utfylling av skjemafelter.",
	"content": "Man kan også benytte feltet til å forklare et regelverk, fremmede begreper, eller utdype hvorfor man ber om informasjonen.\nRetningslinjer: Hjelpetekst plasseres i sammenheng med en label eller tittel som skal utdypes. Dersom innholdet er avgjørende informasjon for at brukeren skal kunne fylle ut skjemaet riktig, bør det heller plasseres i en infotekst i grensesnittet (under labelen). Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/error-message/",
	"title": "Feilmeldinger",
	"tags": [],
	"description": "Feilmeldinger forklarer brukeren hva som gikk galt og hvordan det kan rettes opp i.",
	"content": "Vær kort og tydelig i formuleringen av feilmeldingene og sørg for at brukeren vet hva som må gjøres for å komme videre. Å skrive \u0026ldquo;Feltet er ikke fyllt ut korrekt\u0026rdquo; gir ikke brukeren en forklaring på hva som er feil.\nEksempel på forklarende feilmeldinger: \u0026ldquo;Postnummer må ha 4 siffer\u0026rdquo; \u0026ldquo;Du må velge minst ett leveringsalternativ\u0026rdquo; \u0026ldquo;For å sende inn skjemaet må du bekrefte at navnet er korrekt ved å huke av i avkrysningsboksen\u0026rdquo; Les mer om å formidle feil i skjema på UU-tilsynets nettsider.\nRetningslinjer: Feilmeldingstekst bør gjenta nøkkelord fra label Kravene for å fylle ut skjemaet riktig skal tydelig fremgå av skjemaet uten at brukeren trenger å få noen feilmeldinger fra valideringen for å forstå dette. Dersom skjemaet har feil når brukeren forsøker å gå videre, skal feilmeldingsboksen i toppen vise alle feilene og lenke til de feltene feilen gjelder. Feilene skal forsvinne etterhvert som de blir utbedret. ⚠️ NB: Denne funksjonaliteten er ikke tilgjengelig i Altinn Studio enda. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.",
	"content": "3.11.0 Utvidet modeller med støtte for automatisk sletting av data element DataElement-modellen har blitt utvidet med en ny egenskap deleteStatus. I tillegg er ApplicationMetadata.AppLogic utvidet med en ny egenskap autoDeleteOnProcessEnd. 3.10.0 Utvidet ApplicationMetadata/AppLogic med allowAnonymousOnStateless AppLogic modellen har blitt utvidet med en ny egenskap allowAnonymousOnStateless som åpner for at en data type kan akksesseres anonymt når man kjører i stateless mode. Default er false som dagens funksjonalitet og du må eksplisitt sette den til true hvis du ønsker å tillatte annonym tilgang. 3.9.0 Utvidet EFormidlingContract med DPFShipmentType EFormidlingContract modellen har blitt utvidet med en ny egenskap DPFShipmentType. Verdien er en streng som representeres forsendelsestype hvis servicen er DPF. 3.8.0 Utvidet ProcessHistoryItem med performedBy ProcessHistoryItem modellen har blitt utvidet med en ny egenskap performedBy. Verdien er en streng og kan inneholde personnummer eller organisasjonsnummer som representerer entiteten som trigget eventet. 3.7.0 Utvidet PlatformUser med nationalIdentityNumber egenskap PlatformUser modellen har blitt utvidet med en ny egenskap nationalIdentityNumber. 3.6.0 Utvidet InstanceOwner med username egenskap InstanceOwner modellen har blitt utvidet med en ny egenskap username. 3.5.0 Lagt til CopyInstanceSettings på modellen Application Application modellen har blitt utvidet med en ny egenskap for å holde på konfigurasjon knyttet til kopiering av instans. Egenskapen tillater å aktivere kopiering av instans, samt spesifisere ekskluderte datafelt og -typer. 3.4.0 Lagt til MessageBoxConfig på modellen Applicaton Application modellen har blitt utvidet med en ny egenskap for å holde på en meldingsbokskonfigurasjon. 3.3.0 Lagt til Tags på modellen DataElement DataElement modellen har blitt utvidet med en ny egenskap for å holde på en liste med stikkord (tags). 3.2.0 Innføring av ny modell OnEntryConfig Innføring av en ny model, OnEntryConfig for å støtte definering av hva som skal skje når en bruker åpner opp en applikasjon. Modellen er lagt inn som en egenskap på Application. 3.0.1 Innføring av ny modell DataValues Modellen DataValues er innført til å representere input til API endepunkt for registrering av tekster fra skjema direkte på en Instance. 3.0.0 Refactoring and model application/instance model changes Endringer som krever tilpassninger i app kode (breaking changes) Modellen PresentationField har endret navn til DataField. Dette gjøres slik at den kan benyttes i flere sammenhenger. Bruken av modellen er utvidet til å representere et element i egenskapen DataFields på Application i tillegg til at den fortsatt brukes for å representere elementer i egenskapen PresentationFields. Det er ingen andre endringer i modellen eller hvordan den blir brukt. Andre endringer Application modellen er utvidet med en ny egenskap kalt DataFields og Instance er utvidet med korresponderende egenskap kalt DataValues for å holde verdiene identifisert basert på DataFields. "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v7/",
	"title": "v7",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v7 av Altinn.App.* pakkene og applikasjonsmalen.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v7.0.0.\nHva er nytt?\rOversikt over endringer som ble introdusert i versjon 7.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v6/",
	"title": "v6",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v6 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v6.0.0.\nHva er nytt?\rOversikt over endringer som ble introdusert i versjon 6.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v5/",
	"title": "v5",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v5 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOverview of breaking changes introduced into app nuget packages in v5.0.0.\nHva er nytt?\rOversikt over endringer som ble introdusert i versjon 5.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/",
	"title": "v4",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v4 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.\nHva er nytt?\rOversikt over endringer som ble introdusert i versjon 4.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v3 av Altinn.App.* pakkene.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.\nHva er nytt?\rOversikt over endringer som ble introdusert i versjon 3.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/altinn-2/",
	"title": "Utvikle datamodell for Altinn 2 i Altinn Studio",
	"tags": ["translate-to-english"],
	"description": "Hva må gjøres for å utvikle datamodell til Altinn 2?",
	"content": "Endre eksisterende datamodell Eksisterende datamodell (XSD) kan lastes opp i verktøyet og redigeres. Alle XSD attributter vil følge med fra den opprinnelige XSD\u0026rsquo;en, selv om disse ikke kan redigeres i verktøyet.\nDersom det kun er behov for små endringer på datamodellen, og det kun er behov for endringer ifm Altinn 2, anbefales det allikevel at man gjør disse endringene manuelt direkte på XSD\u0026rsquo;en. Dette kan gjøres med forskjellige verktøy, noen eksempler følger:\nXML Spy Visual Studio Code med f.eks. XML extension Opprette ny datamodell for Altinn 2 Det er mulig å lage en ny datamodell fra bunnen av til Altinn 2 i Altinn Studio Datamodellering. Dette gjøres ved å velge Lag ny i verktøyet. Det blir da opprettet en mal for modellen med et enkelt felt. Pass på å legge til følgende på rot i {model}.schema.json-filen for modellen, da dette må til for at TUL skal kjenne igjen modellen som en SERES-modell.\n\u0026#34;@xsdRootElement\u0026#34;: \u0026#34;melding\u0026#34;, For mer informasjon om utvikling av modell fra bunn av i ASD, se denne guiden.\nDersom man gjør endringer på datamodell via Altinn Studio Datamodellering anbefales det at alle manuelle endringer som gjøres i tillegg, gjøres på {model}.schema.json-filen . Denne filen opprettes/genereres automatisk når man lager en ny datamodell, eller laster/henter opp XSD. Dette er for å slippe å måtte gjøre de samme manuelle endringene på XSD hver gang man gjør endringer på modellen.\nDersom man kun gjør endringer direkte på XSD utenfor ASD, vil ikke denne {model}.schema.json-filen bli generert og man kan jobbe direkte på XSD.\ndataFormatId og dataFormatVersion Disse verdiene vil tas med fra den opprinnelige datamodellen dersom man laster den opp i Altinn Studio Datamodellering. De kan derimot ikke redigeres i ASD. Ved behov for å redigere disse for eksisterende modeller, gjøres dette manuelt direkte i \u0026lt;model\u0026gt;.schema.json-filen som genereres når XSD lastes opp. Dette er for å sikre at disse verdiene følger med også om man gjør endringer på modellen i ASD ved senere tidspunkt.\nVed behov for å opprette nye datamodeller (som ikke baserer seg på en eksisterende modell med disse verdiene satt) for Altinn 2 må disse verdiene settes manuelt.\ndataFormatId kan være en string med maks 30 karakterer. Konvensjonen på SERES XSD\u0026rsquo;er har vært et tall med 4 siffer, men dette feltet kan også inneholde andre tegn. dataFormatVersion må være et heltall for å fungere med Altinn 2. Om man oppretter en ny datamodell anbefaler vi å f.eks. begynne på 1, og øke ved behov. XSD attributter Altinn Studio Datamodellering støtter i utgangspunktet ikke redigering av XSD attributter. Ved opplasting av eksisterende XSD vil alle eksisterende XSD-attributter beholdes og skrives tilbake når ny XSD genereres etter endringer.\nRedigere XSD attributter Disse kan redigeres manuelt i \u0026lt;model\u0026gt;.schema.json-filen som genereres når man lager en ny modell eller laster opp XSD i verktøyet. De kan finnes på det feltet de hører til, under @xsdAttribute-tagen.\nLegge til nye XSD attributter Dette gjøres også manuelt i \u0026lt;model\u0026gt;.schema.json-filen som genereres når man lager en ny modell eller laster opp XSD i verktøyet. Finn frem til den noden som skal ha en XSD attributt, og legg til under properties på noden:\n... \u0026#34;properties\u0026#34;: { \u0026#34;myAttribute\u0026#34;: { \u0026#34;@xsdType\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;@xsdAttribute\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;const\u0026#34;: \u0026#34;\u0026lt;bytt ut med ønsket verdi\u0026gt;\u0026#34; } } XSD anyAttribute Dette kan settes/redigeres manuelt i \u0026lt;model\u0026gt;.schema.json-filen som genereres når man lager en ny modell eller laster opp XSD i verktøyet. Finn frem til noden der anyAttribute skal settes, og legg til følgende på noden:\n\u0026#34;@xsdAnyAttribute\u0026#34;: { \u0026#34;Namespace\u0026#34;: \u0026#34;##any\u0026#34;, \u0026#34;ProcessContent\u0026#34;: \u0026#34;None\u0026#34; }, Attributter på xsd:schema-noden Dette kan settes/redigeres manuelt i \u0026lt;model\u0026gt;.schema.json-filen som genereres når man lager en ny modell eller laster opp XSD i verktøyet. Det er ikke nødvendig å legge dette til manuelt om man har lastet opp en XSD i verktøyet, kun om man starter med tom modell i verktøyet. Disse settes på roten av \u0026lt;model\u0026gt;.schema.json-filen, ved å legge til:\n\u0026#34;@xsdSchemaAttributes\u0026#34;: { \u0026#34;AttributeFormDefault\u0026#34;: \u0026#34;Unqualified\u0026#34;, \u0026#34;ElementFormDefault\u0026#34;: \u0026#34;Qualified\u0026#34;, \u0026#34;BlockDefault\u0026#34;: \u0026#34;None\u0026#34;, \u0026#34;FinalDefault\u0026#34;: \u0026#34;None\u0026#34; }, XSD Namespaces Namespaces på xsd:schema-noden Dette kan settes/redigeres manuelt i \u0026lt;model\u0026gt;.schema.json-filen som genereres når man lager en ny modell eller laster opp XSD i verktøyet. Det er ikke nødvendig å legge dette til manuelt om man har lastet opp en XSD i verktøyet, kun om man starter med tom modell i verktøyet (med mindre man ønsker å redigere/tilføye noe). Disse settes på roten av \u0026lt;model\u0026gt;.schema.json-filen, ved å legge til node med de navnerommene man ønsker å inkludere. F.eks.:\n\u0026#34;@xsdNamespaces\u0026#34;: { \u0026#34;xsi\u0026#34;: \u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34;, \u0026#34;seres\u0026#34;: \u0026#34;http://seres.no/xsd/forvaltningsdata\u0026#34;, \u0026#34;xsd\u0026#34;: \u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; }, "
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/authentication/",
	"title": "Autentisering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Hvordan autentisere ved å bruke APIene.",
	"content": "Authentication for application owners Application owners should be authenticated with Maskinporten.\nAPI provisioning in Maskinporten API-provider To provide an API in maskinporten Altinn has to do two operations.\nAs API-provider Altinn registres a scope in Maskinporten POST /scopes { \u0026#34;prefix\u0026#34;: \u0026#34;altinn\u0026#34;, \u0026#34;subscope\u0026#34;: \u0026#34;instances/metadata.read\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Clients can access metadata for all instances for all apps of the organisation\u0026#34; } As API-provider Altinn has to give access to its scope for a given organisation PUT /scopes/access/889640782?scope=altinn:apps.read Here we have given organisation 889640782 access to the scope altinn:instances/metadata.read. The organisation must then create a client that uses the scope. API-consumer To access the Altinn API an organisation must create a client.\nAs API-consumer the organisation must create a client in Maskinporten with scopes provided by Altinn: POST /clients { \u0026#34;client_name\u0026#34;: \u0026#34;altinnOrgRead\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Client for accessing the my orgs app data\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:instances/metadata.read\u0026#34; ], \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; } Scopes scope names must follow the following regexp:\n^([a-z0-9]+\\/?)+[a-z0-9]+(\\.[a-z0-9]+)?$? It means that we cannot have - or _ in scope names.\nAll instances scope altinn:serviceowner/instances.read altinn:serviceowner/instances.write This is the most general scope which can be given to an organisation by Altinn. It means that the application owner can create a client that can access all instances of apps issued by that application owner.\nClients with write scope will be able to instantiate applications through direct access to the app\u0026rsquo;s api, update metadata, update process state, upload data, validate data, and change process of an instance.\nClients with read token will only be allowed to read metadata, data and events information.\nExchange of JWT token Application owners register clients in Maskinporten and selects the scope they need.\nA client is authenticated by Maskinporten and are given a Maskinporten JWT access token.\nThis token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nMaskinporten JWT access token (input) Client provides a self-contained access-token.\nAutorization: Bearer eyJraWQiOiJIdFlaMU1UbFZXUGNCV0JQVWV3TmxZd1RCRklicU1Hb081OFJ4bmN6TWJNIiwiYWxnIjoiUlMyNTYifQ.eyJhdWQiOiJ0ZXN0X3JwIiwic2NvcGUiOiJ ... GET /authentication/api/v1/exchange/maskinporten The token looks something like this (after base64-decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;HtYZ1MTlVWPcBWBPUewNlYwTBFIbqMGoO58RxnczMbM\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;aud\u0026#34;: \u0026#34;https://tt02.altinn.no/maskinporten-api/\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.write\u0026#34;, \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;client_amr\u0026#34;: \u0026#34;virksomhetssertifikat\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571935870, \u0026#34;iat\u0026#34;: 1571923870, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;U3HMLIY8b_X454CADQzfttSuWpCADPQhc57iZXVF_Ac\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; } } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Maksinporten provides the legal consumer (the client) in ISO 6523 format. The client_orgno claim is deprecated.\nThe Altinn JWT Access token (output) The convert operation validates the incoming token and generates a new JWT token with the same scope as the token. The scopes is copied. The orgNumber and org is added by the token converter.\n{ \u0026#34;scope\u0026#34;: \u0026#34;altinn:instances.read altinn:instances.write\u0026#34;, \u0026#34;token_type\u0026#34;: \u0026#34;Bearer\u0026#34;, \u0026#34;exp\u0026#34;: 1571996946, \u0026#34;iat\u0026#34;: 1571995146, \u0026#34;client_id\u0026#34;: \u0026#34;0de19f7a-f5fa-45d1-874c-3d2e88ce97d9\u0026#34;, \u0026#34;client_orgno\u0026#34;: \u0026#34;974760673\u0026#34;, \u0026#34;jti\u0026#34;: \u0026#34;BcNIAuZKXdjpECmmwalAm-pcBp0iNc56T6eXhlxNBZE\u0026#34;, \u0026#34;consumer\u0026#34;: { \u0026#34;authority\u0026#34;: \u0026#34;iso6523-actorid-upis\u0026#34;, \u0026#34;ID\u0026#34;: \u0026#34;0192:974760673\u0026#34; }, \u0026#34;org\u0026#34;: \u0026#34;brg\u0026#34;, \u0026#34;orgNumber\u0026#34;: 974760673, \u0026#34;iss\u0026#34;: \u0026#34;https://platform.altinn.cloud/\u0026#34;, \u0026#34;AuthenticateMethod\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;AuthenticationLevel\u0026#34;: 3, \u0026#34;nbf\u0026#34;: 1571995146 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Authentication for end user system End user systems should be authentication with ID-porten. When authenticated the system may exchange an access token provided by ID-porten with an Altinn token by instructions below.\nExchange of JWT token This token has to be validated and replaced with an Altinn JWT access token which should be used to access the apis.\nIT IS IMPORTANT THAT THE USER HAS PROFILE IN ALTINN. Profile is automatic created when login in to portal\nID-porten JWT access token (input) Autorization: Bearer eyJraWQiOiJjWmswME1rbTVIQzRnN3Z0NmNwUDVGSFpMS0pzdzhmQkFJdUZiUzRSVEQ0IiwiYWxnIjoiUlMyNTYifQ.eyJhdF9 ... GET /authentication/api/v1/exchange/id-porten The token looks something like this (after decoding):\n{ \u0026#34;kid\u0026#34;: \u0026#34;cZk00Mkm5HC4g7vt6cpP5FHZLKJsw8fBAIuFbS4RTD4\u0026#34;, \u0026#34;alg\u0026#34;: \u0026#34;RS256\u0026#34; } . { \u0026#34;at_hash\u0026#34;: \u0026#34;IF-jpSLtMjzoHdEhLq9pnw\u0026#34;, \u0026#34;sub\u0026#34;: \u0026#34;PZcxQYOR_ylbrlj69pXn_HdTmrpDRpA3X0rTyOEyN5I=\u0026#34;, \u0026#34;amr\u0026#34;: [ \u0026#34;Minid-PIN\u0026#34; ], \u0026#34;iss\u0026#34;: \u0026#34;https://oidc-ver2.difi.no/idporten-oidc-provider/\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1584978003167642\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;bQDBkJmjrX3bx2agu4q7BS5QW6TPf9CHnJX11vEthZg\u0026#34;, \u0026#34;aud\u0026#34;: \u0026#34;38e634d9-5682-44ae-9b60-db636efe3156\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1584978021, \u0026#34;exp\u0026#34;: 1584978141, \u0026#34;iat\u0026#34;: 1584978021, \u0026#34;jti\u0026#34;: \u0026#34;_Og8JT1zMKzzHFB4WoVCdvqzmEpoY1hPhLa47bieJ94\u0026#34; } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; The Altinn JWT Access token (output) The exchange operation validates the incomming token and generates a new JWT token that contains user data retrieved from the database using the provided pid (person identification number) and pre-existing data from the ID-porten token.\npid is referred to as ssn (social security number) i Altinn Platform.\n{ \u0026#34;nameid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:userid\u0026#34;: \u0026#34;20000011\u0026#34;, \u0026#34;urn:altinn:username\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;urn:altinn:partyid\u0026#34;: 50002119, \u0026#34;urn:altinn:authenticatemethod\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;urn:altinn:authlevel\u0026#34;: 3, \u0026#34;amr\u0026#34;: \u0026#34;Minid-PIN\u0026#34;, \u0026#34;pid\u0026#34;: \u0026#34;191080XXXXX\u0026#34;, \u0026#34;locale\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;nonce\u0026#34;: \u0026#34;1585045781364132\u0026#34;, \u0026#34;sid\u0026#34;: \u0026#34;BYSqEpVGRrh6rElmnzzTjcU0roC95rxNCC2kAsB2hmY\u0026#34;, \u0026#34;acr\u0026#34;: \u0026#34;Level3\u0026#34;, \u0026#34;auth_time\u0026#34;: 1585045793, \u0026#34;exp\u0026#34;: 1585047785, \u0026#34;iat\u0026#34;: 1585045985, \u0026#34;nbf\u0026#34;: 1585045985 } . \u0026lt;\u0026lt;signature\u0026gt;\u0026gt; Open ID Connect configuration This is work-in-progress. The response is still missing required information and might be inconsistent with actual authentication mechanisms.\rMetadata about Altinn as an Open ID provider is exposed as a .well-known endpoint as defined by OpenID Connect Discovery.\nThe primary porpose of this endpoint is to make available the Altinn signing certificate for the JSON Web Tokens being generated. It is recommended that clients of Altinn use this discovery endpoint to automatically have their systems updated when Altinn changes their signing certificate.\nEnvironment URL AT2x https://platform.at2x.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration YT01 https://platform.yt01.altinn.cloud/authentication/api/v1/openid/.well-known/openid-configuration TT02 https://platform.tt02.altinn.no/authentication/api/v1/openid/.well-known/openid-configuration "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/",
	"title": "Definere autorisasjonspolicy",
	"tags": [],
	"description": "I Altinn Studio designer kan applikasjonsutvikleren definere policyen for applikasjonen som er opprettet",
	"content": "Applikasjonsutvikleren definerer autorisasjonsreglene for en applikasjon i en XACML-policyfil som er plassert i applageret. XACML-policyen inneholder en eller flere regler som bestemmer hvem som kan utføre forskjellige handlinger på forskjellige ressurser. Du kan redigere XACML-filen i et tekstredigeringsprogram etter eget valg.\nRegler fra applikasjonsmal Når du oppretter en app i Altinn studio, er den basert på gjeldende asp.net-mal og vil inkludere en autogenerert XACML policy-fil.\nApplikasjonsutvikleren kan endre autorisasjonsreglene i policy.xml, som ligger i App/config/authorization i programlageret. Du kan finne detaljer om konfigurering av policyfilen nedenfor. Du kan også finne en god mengde eksempler på regler her.\nVær oppmerksom på at endringer i policyfilen er på egen risiko og at det alltid anbefales å delegere lesetillatelser til enheter med skrivetillatelser.\rRessursattributtene Ressursattributtene til regler beskriver hvilken applikasjon eller del av reglene som gjelder.\nAttribute Description urn:altinn:org Organisasjonsdelen av ressursattributtet definerer hvilken organisasjon som eier appen. urn:altinn:app Appdelen som identifiserer selve appen urn:altinn:task Oppgavedelen av ressursen gjør det mulig å ha egne regler for de ulike oppgavene. urn:altinn:event Arrangementsdelen av ressursen gjør det mulig å ha egne regler for lesing av hendelser. Eksempel Eksempelet nedenfor viser en del av XACML 3.0-policyen der en ressurs er definert.\n\u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;skd\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;taxreport\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;instansiate\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; Subjektattributene Subjektdelen for regelen definerer hvem regelen er rettet mot.\nAttribute Description urn:altinn:rolecode The role code is used for rule that target end users and systems. urn:altinn:org The org code is used for rule that target orgs. En fullstendig liste over rolletyper finner du her.\nDet er viktig å lese Veiledning for autorisasjonsregler før du velger rolle.\nExamples Eksempel med rollekode\n\u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;regna\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; Eksempel med org:\n\u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;skd\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; Action attributter Action attributtene beskriver hvilken operasjon regelen gjelder\nAttribute Description urn:oasis:names:tc:xacml:1.0:action:action-id Handlingen som regelen gjelder for. I appen kan dette være read, write, instantiate, complete aog delete. Dette vil bli utvidet når ny funksjonalitet legges til Eksempel med read operasjon.\n\u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; Obligation Obligation delen av policy brukes til å definere informasjon som skal brukes av PEP. Det nødvendige autentiseringsnivået er satt til 2 som standard. Dette gjøres som en forpliktelse i XACML Policy-filen.\nHvis nødvendig autentiseringsnivå er satt til 4, må du definere at tjenesteeier kan samhandle med det gjennom nivå 3 autentisering for Maskinporten. Dette fordi Maskinporten er definert som nivå 3. Se regelbiblioteket for eksempler.\nEksempel med autentiseringsnivå 2\n\u0026lt;xacml:ObligationExpressions\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel1\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation1-assignment1\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;2\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;/xacml:ObligationExpressions\u0026gt; Regelbibliotek\rBibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.\nVeiledning for autorisasjonsregler\rAutorisasjonsregler må defineres med omhu. Disse retningslinjene forteller hva applikasjonseier må vurdere før autorisasjonsregler settes for en applikasjon\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/data-elements/",
	"title": "Data-elementer",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API å jobbe med dataelementene knyttet til en app instans.",
	"content": "Overview A data element consist of two parts: its metadata document and the actual data blob. This API work primarily with the blob while keeping the metadata document updated.\nbasePath\n{org}/{appname}/instances/{instanceOwnerPartyId}/{instanceGuid}/data Get data Endpoint for downloading the data blob.\nGET basePath/{dataGuid} Accept: application/{xml/json} The response will depend on the type of blob. There are currently 2 primary types: form data based on a model and attachments. An Accept header in a request will be considered only when the requested data element is connected to a data model. The header is then used to pick a serializer for the data.\nResponse with form data A response with form data will either be a json or xml serialized version of the data model depending on the Accept header in the request. The value application/xml will result in an XML document and the value application/json will result inn a JSON document.\nResponse with attachment A response with a file attachment will be a file stream. Content-Type will be the same as the original value given when the file was uploaded. The same is true for the file name.\nContent-Disposition: attachment; filename=cute_cat.png; filename*=UTF-8\u0026#39;\u0026#39;cute_cat.png Content-Length: 16994 Content-Type: image/png Upload data Endpoint for uploading a new data element on a specific instance.\nPOST basePath?dataType={data type name} The dataType parameter is required and should reference one of the data types defined on the application. Data types with an appLogic property are linked to a form and will have data validation and calculation rules associated with them. Data types without an appLogic property will be handeled as an attachment and streamed directly to storage.\nRequest Content-Type is handled a little differently between the two cases:\nIf a request is uploading form data, the Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type. If a request is uploading an attachment, the validation of Content-Type will depend on the rules of the data type. If the data type has no Content-Type requirements, there will be no validation and the request can contain any Content-Type. If the data type has Content-Type requirements, there is a new set of checks. The request Content-Type must either be application/octet-stream or match the MIME type of the file being uploaded. Altinn will perform a mapping from file extension to MIME type before comparing with Content-Type. As an example we can see that .xml will map to text/xml and not application/xml. If the data type allow Content-Type application/octet-stream no further validation is performed. If not, the identified MIME type must match one of the allowed Content-Types on the data type. Uploading form data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Uploading form data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; Uploading an attachment An example of a request uploading a PDF file.\nContent-Type: application/pdf Content-Disposition: attachment; filename=\u0026#34;receipt.pdf\u0026#34;; filename*=UTF-8\u0026#39;\u0026#39;receipt.pdf Content-Length: 16994 %PDF-1.4 %Óëéá 1 0 obj ... Response example The endpoint returns the data element metadata document that was created.\n{ \u0026#34;id\u0026#34;: \u0026#34;692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;instanceGuid\u0026#34;: \u0026#34;762011d1-d341-4c0a-8641-d8a104e83d30\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, \u0026#34;blobStoragePath\u0026#34;: \u0026#34;org/app/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;selfLinks\u0026#34;: { \u0026#34;apps\u0026#34;: \u0026#34;{appPath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34;, \u0026#34;platform\u0026#34;: \u0026#34;{storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/data/692ee7df-82a9-4bba-b2f2-c8c4dac69aff\u0026#34; }, \u0026#34;filename\u0026#34;: \u0026#34;default.xml\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-03-06T15:00:23Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2019-03-07T15:00:23Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;org23\u0026#34;, \u0026#34;size\u0026#34;: 20001, \u0026#34;locked\u0026#34;: false } Replace data Endpoint for replacing the content of an existing data element with new data. The new data must match the data type of the data element it is replacing.\nPUT basePath/{dataGuid} The endpoint works exactly like the endpoint for uploading a new data element.\nDelete data Endpoint for deleting an existing data element. It is currently not possible to delete the data for a form this way.\nDELETE basePath/{dataGuid} Tags\rApp API for å manipulere stikkord på et data element\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/",
	"title": "Datamodell i Altinn Studio",
	"tags": [],
	"description": "Informasjon om datamodeller og datamodellering i Altinn Studio",
	"content": "\rAltinn Studio Datamodellering\rBrukerguide for verktøyet Altinn Studio Datamodellering\nDatamodeller for applikasjoner\rInformasjon om datamodeller for applikasjoner\nDatamodeller for organisasjoner\rInformasjon om datamodeller for organisasjoner i Altinn Studio\nUtvikle datamodell for Altinn 2 i Altinn Studio\rHva må gjøres for å utvikle datamodell til Altinn 2?\nKjente feil og mangler\rInformasjon om kjente feil og mangler i verktøyet for datamodellering i Altinn Studio\nErstatning for Seres i Altinn Studio\rHva må gjøres når Seres erstattes?\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/",
	"title": "Designer",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Designer.",
	"content": "Designer er verktøyet du starer i etter å ha logget inn på https://altinn.studio. Det er et verktøy for å opprette, konfigurere og deploye apper.\nNavigere til en app Alle apper du har tilgang til å endre på vises på dashboardet. Gå til appen ved å klikke på appen. Dersom du ikke har en lokal klone av appen, vil du bli bedt om å opprette det.\nHvis du ønsker å gå til app-repositoryet når du er inne i en app i Designer, er det en lenke i menyen som ligger i profilmenyen øverst til høyre.\nRedigere en app Det er to navigasjonsmenyer - en toppmeny og en venstremeny.\nI toppmenyen kan du navigere mellom ulike funksjonelle områder av applikasjonen. I venstremenyen kan du navigere innad i området.\nOm Om appen Lage Datamodell UI-Editor Tilgangsstyring Språk Tekster Deploy UI editor\rHvordan bygge et skjema med UI editor i Altinn Studio.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/file-upload/",
	"title": "Filopplasting",
	"tags": [],
	"description": "Filopplasting tillater brukere å laste opp en eller flere filer.",
	"content": "Du bør ikke be brukeren laste opp vedlegg med mindre det faktisk har en avgjørende betydning for tjenesten. Sjekk først om informasjonen kan hentes inn på annet vis, kanskje gjennom API?\nRetningslinjer: Vær så fleksibel som mulig i forhold til hvilke filtyper som kan lastes opp. Ikke alle har kompetanse til å endre filtypeformat eller komprimere filer. Dersom det er feil i opplastingen, vær så spesifikk som mulig i feilmeldingen. Å si at “formatet ikke er godkjent” holder ikke, det må spesifiseres nøyaktig hva som kreves. Har du behov for at brukeren laster opp vedlegg av ulike typer/kategorier, anbefaler vi å bruke flere steg med en filopplaster i hvert steg. Spesifiser i innledningen på hver side hva som skal legges ved, slik at brukeren ikke blir i tvil. Eksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/instances/",
	"title": "Instanser",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for instanser.",
	"content": "Overview An instance works as a form of envelope or folder where data can be collected and exchanged between the user and owner of the application. The instance document is a way for Altinn and external parties to track the state of one specific data exchange. How long an instance can live and how many interactions there can be between the application owner and user will vary from one app to another. Advanced Apps will have their own documentation.\nbasePath = https://{hostname}/storage/api/v1/instances Query instances It is possible to query instances based on a number of query parameters.\nApplication owners can search for from a single application or across all applications that they have. Using this endpoint requires the scope \u0026lsquo;altinn:instances.read\u0026rsquo;. And query parameter \u0026lsquo;org\u0026rsquo; or \u0026lsquo;appId\u0026rsquo; must be included in the request.\nUsers can search for instances linked to either themselves or an instanceOwner they are authorized to read the instances of. Query parametr \u0026lsquo;instanceOwner.partyId\u0026rsquo; must be included in the request if using this endpoint as an end user.\nSearch for instances with a simple GET request towards the instances endpoint. Avaliable query paramters include:\nprocess.currentTask (string)\nSearch for instances at a specific step in its process. process.isComplete (bool)\nSearch for instances where the process is completed. process.endEvent (string)\nDeprecated. The parameter doesn\u0026rsquo;t have any code associated with it. process.ended (datetime)\nFilter instances based on ended date. instanceOwner.partyId (int)\nFilter instances based on the instance owner party id. lastChanged (datetime)\nFilter instances based on the last time they where worked on. created (datetime)\nFilter instances based on when they where initially created. visibleAfter (datetime)\nFilter instances based on when they became visible. dueBefore (datetime)\nFilter instances based on their due date. excludeConfirmedBy (string)\nExclude instances already confirmed by a specific stakeholder. Usually the short name of an application owner. isArchived (bool) Filter instances based on whether they are archived. isSoftDeleted (bool) Filter instances based on whether they are soft deleted. isHardDeleted (bool) Filter instances based on whether they are hard deleted. Note that hard deleted instances are only included if an application owner retrieves instances, and the results may include deleted drafts. Some examples:\nGet all instances of application org/app, that is at process task with id Task_2 (which is Submit, see process definition), and has last changed date greater than 2019-05-01.\nGET {storagePath}/instances?appId=org/app\u0026amp;process.currentTask=Task_2\u0026amp;lastChanged=gt:2019-05-01 Get all instances of all applications of a given application owner org that has ended date greater than 2020-03-10.\nGET {storagePath}/instances?org=org\u0026amp;process.ended=gt:2020-03-10 Get all instances of all applications of a given application owner org that has not already been confirmed completed by org.\nGET {storagePath}/instances?org=org\u0026amp;excludeConfirmedBy=org Get all instances of an application that are at a specific process task e.g. Task_1.\nGET {storagePath}/instances?appId={org}/{app}\u0026amp;process.currentTask={taskId} On query parameters specifying date time you can use the following operators:\ngt: - greater than gte: - greater than or equal to lt: - less than lte: - less than or equal to eq: - equal (can also be blank) They can be combined to define a range:\ndueBefore=gt:2019-02\u0026amp;dueBefore=lt:2019-03-01 The query returns a result object (page) which includes a collection of instances that matched the query. 100 instances is returned by default. Use size to get more or less instances per page. To get to the next page you have to use the continuationToken present in the next link.\nThe instances endpoint returns a query result object with information about how many total hits totalHits that the query matched and how many objects returned count.\nThe endpoint supports application/json.\nAccept: application/json { \u0026#34;totalHits\u0026#34;: 234, \u0026#34;count\u0026#34;: 50, \u0026#34;self\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026#34;, \u0026#34;next\u0026#34;: \u0026#34;{storagePath}/instances?appId=org/app\u0026amp;size=50\u0026amp;continuationToken=%257b%2522token%2522%253a%2522%252bRID%...\u0026#34; \u0026#34;instances\u0026#34;: [ {...}, {...}, ... ] } } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/intro/",
	"title": "Intro for utviklere",
	"tags": [],
	"description": "Introduksjon",
	"content": "Altinn Studio aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; What are we creating A app development solution Altinn Studio: The development tool Altinn Platform: The supporting platform Altinn Apps: The solution to host the Apps What technologies are we using .NET Core : Backend / API React : Frontend Altinn Studio \u0026amp; App Docker: Apps are created as Docker Containers Kubernetes: The containers are hosted in Kubernetes Azure: We use Azure for Kubernetes hosting Altinn Studio Design frontend Define frontend logic Define datamodel for app Define app logic for backend Build \u0026amp; deploy app container Source Control for App files Altinn Apps Kubernetes Cluster where apps are hosted One cluster per Organisation Altinn Platform Supporting functionality Authentication Authorization Storage Register Profile Documentation The different solutions are described in detail on docs Terms Architecture The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/known-issues/",
	"title": "Kjente feil og mangler",
	"tags": ["translate-to-english"],
	"description": "Informasjon om kjente feil og mangler i verktøyet for datamodellering i Altinn Studio",
	"content": "Oversikt over registrerte feil og mangler finner man på her.\nOversikt over planlagt ny funksjonalitet finner man her.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/",
	"title": "Test av app lokalt",
	"tags": [],
	"description": "Beskrivelse av hvordan test av app lokalt på egen maskin kan gjøres",
	"content": "Dersom man skal skrive en del kode (f.eks. logikk), eller kjapt sjekke hvordan skjema ser ut kan det være nytting å kunne teste endringer uten å måtte deploye hele appen til testmiljø.\nNår appen lages, kommer den med alle nødvendige filer og oppsett til å kunne kjøres som en frittstående applikasjon. Ved å laste ned alle filene knyttet til appen fra repoet til appen, kan man kjøre appen lokalt på egen maskin, og på den måten enkelt teste endringer.\nI testmiljø bruker appen et sett med plattform-tjenester for å kunne hente ut/lagre data osv. Det er opprettet en forenklet versjon av disse tjenestene som kan settes opp og kjøres lokalt, og dette er nødvendig for at appen skal kunne testes lokalt.\nKjøre appen lokalt Naviger til app repoet i Altinn Studio. Se her for hvordan man navigerer seg dit. Last ned alle filene i repoet ved å bruke git clone kommandoen (les mer) ved å trykke på nedlastingsikonet (da lastes det ned som en zip-fil) Se Altinn Studio på Github for informasjon om hvordan man laster ned og kjører den lokale plattformen,og hvordan man kjører appen.\nTesting av app API-er lokalt\rHvordan teste app-APIer lokalt.\nDebugging av app\rNår man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.\nTestbrukere lokalt\rVi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/maskinporten/",
	"title": "Autentisere med Maskinporten",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.",
	"content": "Samarbeidsportalen I Min profil i Samarbeidsportalen så har du tilgang til selvbetjening for Maskinporten, og der kan du opprette nye integrasjoner (klienter).\nhttps://tt02.altinn.no er testmiljø for apper i Altinn, og det er koblet mot Ver 2-miljøet i Maskinporten. https://www.altinn.no er koblet mot Produksjon. Tilgang som tjenesteeier For å kunne hente data fra Storage i Altinn 3 via API som tjenesteeier, så må man opprette en integrasjon (klient) i Maskinporten, med nødvendige scopes.\nFølgende scopes er opprettet av Altinn, og delegert til tjenesteeier. Disse scopene behøves for å benytte APIene relatert til instanser som tjenesteeier:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write Klienter med write scope kan bl.a. instansiere apper på vegne av bruker via appens eget API, laste opp data, oppdatere metadata og prosess-status. Klienter med read scope kan kun lese data, metadata og events.\nI de fleste tilfeller så vile en klient for tjenesteeier ha behov for begge scopene.\nOppretting av klient kan gjøres via API eller i Samarbeidsportalen.\nPOST https://integrasjon.difi.no/clients/ { \u0026#34;integration_type\u0026#34;: \u0026#34;maskinporten\u0026#34;, \u0026#34;client_name\u0026#34;: \u0026#34;DIHE testklient for instanser\u0026#34;, \u0026#34;client_type\u0026#34;: \u0026#34;CONFIDENTIAL\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Klient for å hente data fra mine apper\u0026#34;, \u0026#34;scopes\u0026#34;: [ \u0026#34;altinn:serviceowner/instances.read\u0026#34;, \u0026#34;altinn:serviceowner/instances.write\u0026#34; ], \u0026#34;token_reference\u0026#34;: \u0026#34;SELF_CONTAINED\u0026#34; } Veksle til Altinn Token Altinn godtar ikke Maskinporten API direkte. Disse må veksles inn i Altinn token. Se detaljer i scenario under.\nMer informasjon For mer informasjon, se dokumentasjon for API-konsument fra Maskinporten. Se også scenario for autentication for enda flere detaljer (på engelsk). "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/first-time-setup/",
	"title": "Opprette bruker i Altinn Studio",
	"tags": [],
	"description": "Konfigurer brukeren din i Altinn Studio for første gang.",
	"content": "Lag en bruker i Altinn Studio Din Altinn Studio bruker er personlig for deg og kan knyttes til en eller flere organisasjoner for å samarbeide med andre og få tilgang til eksisterende apper.\nVis/skjul innhold\rLag bruker med GitHub brukernavn\rVelg å logge inn på altinn.studio. På “Logg in”-siden, klikk på knappen “Har du en Github konto? Registrer deg med den her”. Logg inn i GitHub hvis du ikke allerede er det. Godkjenn at Altinn Studio bruker din GitHub-konto for å logge inn. Lage en Altinn Studio bruker ved å fylle ut brukernavn, epost, passord, en captcha og klikk på “Fullfør”.\nBrukeren i Altinn Studio vil bli koblet til din GitHub-bruker og du er klar for å begynne arbeide med din første applikasjon. Vis/skjul innhold\rLag en bruker med epostadresse (uten GitHub)\rPå “Logg inn”-siden, klikk på knappen “Behov for konto? Registrer deg nå.” Lage en Altinn Studio bruker ved å fylle ut brukernavn, epostadresse, passord, en captcha og klikk på “Fullfør”. Du er nå klar for å begynne arbeide med din første applikasjon. Bli del av en organisasjon Organisasjoner i Altinn Studio er det samme som tjenesteeiere i Altinn. De eier applikasjonene og gjør det mulig for flere innen samme organisasjon å samarbeide.\nFor å bli del av en organisasjon tar du kontakt med administrator for organisasjonen du arbeider for som legger deg til. Hvis du er usikker på hvem som er administrator eller du ikke vet om organisasjonen din er satt opp i Altinn Studio, kan du spørre Altinn Servicedesk om hjelp.\nOpprette en organisasjon Det er Altinn som oppretter organisasjoner i Altinn Studio. For å kunne få en organisasjon i Altinn studio må du ha en avtale med Altinn.\nSend en mail til Altinn Servicedesk med navn på organisasjonen og hvem som skal være administrator for å opprette en ny organisasjon. Det vil kunne ta noen dager å opprette organisasjonen og du vil få en mail så fort det er gjort.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/slide/",
	"title": "Presentasjon",
	"tags": [],
	"description": "En presentasjon om målsettinger og konsepter for Tjenester 3.0",
	"content": "Altinn Studio Aka. \u0026ldquo;Tjenester 3.0\u0026rdquo; Dagens løsning Produksjonsatt sommeren 2010 Basert på InfoPath og SharePoint 115.000.000 skjema fylt ut 404 aktive innsendingstjenester i 2018 Bakgrunn og mål Behov har vært kjent lenge POC utviklet i 2015 (men lagt på is grunnet manglende finansiering) Finansiering på Statsbudsjettet 2018 Startet opp igjen våren 2018 Hva er målet med prosjektet? En modern utviklingsplattform Et effektivt utviklingsverktøy En moderne infrastruktur En plattform for gjenbruk En platform for deling av data og erfaringer En moderne utviklingsplattform Altinn Studio er en åpen og modern utviklingsplattform\nVersjonering og samarbeid via Git Støtte for distribuert utvikling All programvare som benyttes er åpen kildekode. Også selve 3.0-plattformen. Funksjonalitet i Altinn tilgjengelig via API’er Moderne og populær teknologi, f.eks. React og Visual Studio Code Full selvbetjening Tekniske utviklere kan benytte best-of-breed utvikler-verktøy og teknologi, slik de er vant til. Et effektivt utviklingsverktøy Altinn Studio tilbyr enkel, effektiv og 100% selvbetjent utvikling og forvaltning av tjenester, også for ikke-teknologer.\nBrukergrensesnitt (GUI) API’er Arbeidsflyt Logikk og dynamikk Datamodellering Konfigurasjon og tilgangsstyring Automatisert testing … En moderne infrastruktur Altinn Studio (og tjenester som lages der) vil kjøre på en moderne infrastruktur.\nDocker containers for applikasjoner Kubernetes for orkestrering av containers Dette gir isolering mellom applikasjoner (microservices), enklere skalering og understøtter “DevOps”.\nHva kan jeg gjøre med MVP? Opprette bruker og logge inn i Altinn Studio Lage (og finne igjen) en tjeneste Finne tjenester fra andre organisasjoner Laste opp en datamodell som fungerer i tjenesten (Seres eller OR) Lage et skjemadesign med drag and drop av elementer (begrenset utvalg av komponenter) Legge inn tekster/tekstnøkler for tjeneste Legge inn regler for skjemalogikk (validering, kalkulering, dynamikk) Bruke API-oppslag i tjenesten (forutsetter Ajax kall kodet i GUI)\nEndre på standardfil for arbeidsflyt Endre på filer med versjonskontroll Legge den ferdige tjenesten i test- og produksjonsmiljø Tjenster 3.0 vs Tjenester 2.0 Skjemaverktøy Egenutviklet vs InfoPath React vs SharPoint formserver Responsivt vs ikke responsivt Arbeidsflyt BPMN vs Custom Tjenester som API REST vs SOAP Individuell API vs Generelle Ressurser Isolerte vs delte Raskt skalerbar vs lang leveringstid Dataformat JSON/XML vs XML Kontroll på logikk Full kontroll på når ting skjer i plattformen i motsetning til Infopath Shipment Inntil videre kun pull-basert nedlasting av skjemadata. Videre arbeid i MVP Fokus på infrastruktur Skyløsninger Sikkerhet Deploy av tjenester Integrasjon med tjenesteeier Understøtte piloter Detaljer løsning Tre nye løsninger\nAltinn Studio Altinn Apps Altinn Platform Altinn Studio Altinn Apps Altinn Platform Status Du kan følge utviklingen på Github. Motivasjon Se Archimate arkitekturmodell. The End Tilbake\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/data-model/seres-migration/",
	"title": "Erstatning for Seres i Altinn Studio",
	"tags": [],
	"description": "Hva må gjøres når Seres erstattes?",
	"content": "Denne siden beskriver hva som må gjøres ifm. overgangen fra Seres til Altinn Studio som datamodelleringsverktøy. Siden vil oppdateres i takt med utviklings- og migreringsarbeidet som gjøres så det må forventes oppdateringer.\rAlle XSD\u0026rsquo;er som lå i Altinn 2 pr. 06.12.2022 er importert til Altinn Studio.\rAltinn Studio Datamodellering Seres er et verktøy for å lage XSD\u0026rsquo;er som igjen validerer korrektheten til en XML. Det nye datamodelleringsverktøyet jobber på Json Schema som igjen validerer Json. Prinsippet er det samme, men formatet er forskjellig.\nSelv om datamodelleringsverktøyet jobber på Json Schema vil det fortsatt være mulig å hente ut en XSD hvis man trenger det, f. eks. i et mottakssystem. Json Schema vil da bli konvertert til XSD. En XSD produsert i Seres og som leses inn i ASD vil inneholde nok metadata til å kunne re-generere XSD\u0026rsquo;en slik den var. Dette muliggjør at man kan bruke verktøyet til å jobbe med datamodeller for Altinn 2 ev. lage en Altinn 3 applikasjon som leverer samme format som Altinn 2.\nSelv om både XSD og Json Schema handler om å beskrive og validere dataformater så har de begge forskjellige egenskaper og måter å beskrive datatyper og datastrukturer på. Json Schema startet som et noe mer lettvekts alternativ til XSD - noe av denne \u0026ldquo;lettheten\u0026rdquo; blir dog borte når man må kunne re-generere en XSD 100%.\nDet anbefales derfor at man starter fra bunnen av og modellerer på nytt for en Altinn 3 applikasjon hvis man har muligheten til dette, slik at man sikrer mest mulig enkle og oversiktlige datamodeller.\nOvergangen fra Seres til Altinn Studio Datamodellering - Hva må du som tjenesteeier gjøre? Verifisere at alle XSD\u0026rsquo;er fra Altinn 2 er overført XSD\u0026rsquo;er som er lastet opp til og tatt i bruk i Altinn 2 vil bli hentet ut og overført til et dedikert lagringsområde per tjenesteeier i Altinn Studio. Dette er et repository som ligger under den enkelte tjenesteeier sin organisasjon i Altinn Studio/Gitea og har navnet {org}-datamodels.\nDu finner det ved å enten søke det opp i dashboardet til Altinn Studio, eller se i listen Datamodeller på dashboardet, og klikke på den grønne repository lenken.\nNår du har åpnet repository vil du se flere mapper, XSD\u0026rsquo;er fra Altinn 2 vil ligge under Seres mappen.\nI tillegg vil du se en readme.md fil som vises på forsiden av repository. Denne inneholder en tekstlig beskrivelse av alle XSD\u0026rsquo;ene som er hentet ut fra Altinn 2.\nIfm. at dette arbeidet ble startet i 2021 ble det gjort et uttrekk av XSD\u0026rsquo;er da, disse ligger igjen. Vi har kjørt et nytt uttrekk i 23. november 2022, og igjen 6. desember 2022.\nVi har ikke slettet skjemaer som allerede er overført til ny løsning selv om de er fjernet i Altinn 2.\nDet gjøres ingen endringer i XSD\u0026rsquo;ene ifm. uttrekket og overføringen til repository i Altinn Studio. XSD\u0026rsquo;ene skal være 100% like. Det er først når man velger å jobbe videre på XSD\u0026rsquo;ene at nytt datamodelleringsverktøy vil tas i bruk. Videreutvikling kan være mindre endringer for Altinn 2 ev. bygge videre på skjema med tanke på å bruke det i en Altinn 3 applikasjon.\nXSD\u0026rsquo;er som er under arbeid i Seres Hvis du har XSD\u0026rsquo;er som er under arbeid i Seres og som ikke er satt i produksjon i Altinn 2 må disse tas ut av Seres manuelt og lastes opp i repository hvis du ønsker å jobbe videre med de i Altinn Studio ev. ha alt samlet på et sted. Alternativt kan man starte på nytt med datamodellering i nytt verktøy.\nXSD\u0026rsquo;er som kun er lastet opp i TUL Her gjelder det samme som for punktet over.\nTeste nytt verktøy Har du planer om å gjøre endringer i en eller flere XSD\u0026rsquo;er som skal produksjonsettes i Altinn 2 bør endringsprosessen testes og helst gjøres med mindre endringer slik at det blir lettere å verifisere den genererte XSD\u0026rsquo;en før den lastes opp og tas i bruk i Altinn 2.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/data-elements/tags/",
	"title": "Tags",
	"tags": ["api"],
	"description": "App API for å manipulere stikkord på et data element",
	"content": "Oversikt API\u0026rsquo;et for tags (stikkord) på data elementer har endepunkter for å liste ut tags, legge til en tag, samt sletting av tag.\nbaseSti\n{org}/{appname}/instances/{instanceOwnerPartyId}/{instanceGuid}/data/{dataGuid}/ Hent tags Endepunkt for å laste ned listen med tags som allerede er lagt til på et data element.\nGET baseSti/tags Accept: application/json Legge til tag Endepunkt for å legge til en ny tag.\nPOST baseSti/tags Content-Type: application/json \u0026#34;bokstaver\u0026#34; API kallet må inneholde det nye ordet i anførselstegn. Dette er en JSON representasjon av en enkel tekst og Content-Type skal være application/json. Ordet kan inneholde bokstaver fra alle verdens språk.\nSvaret på et kall vil inneholde listen over alle tags lagt til på data elementet inkludert det nye ordet.\nSlett tag Endepunkt for å fjerne en tag fra et data element.\nDELETE baseSti/tags/{tag} Svaret vil gi http status kode 204 hvis operasjonen lykkes.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/stateless-data-elements/",
	"title": "Tilstandsløse data",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.",
	"content": "Overview A stateless data element is a data object based on a data model without relations to an instance, instance owner or a state. The data is never persisted anywhere, and the avilable endpoints simply creates, prefills and/or runs calculations on a data object before returning it to the caller.\nbasePath\n{org}/{app}/v1/data Create new data Endpoint for creating a new stateless dataelement based on a data type.\nPOST basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nIf prefill or calculations are defined for the data type, these will be run on the data element before it is returned.\nResponse A response with the data element in the body will be returned if a valid data type is provided.\nCalculate data Endpoint for running calculations on a data element.\nPUT basePath?dataType=[dataTypeId] Accept: application/{xml/json} The dataType parameter is required and should reference one of the data types defined on the application that requires app logic.\nThe Content-Type is used by Altinn to deserialize the request into a strongly typed object. A request must either be application/json or application/xml. No other Content-Types are supported. Content-Type is not validated against allowed Content-Types on the data type.\nProviding data as application/json Content-Type: application/json { \u0026#34;dataFormatProvider\u0026#34;: \u0026#34;SERES\u0026#34;, \u0026#34;dataFormatId\u0026#34;: \u0026#34;5703\u0026#34;, \u0026#34;dataFormatVersion\u0026#34;: \u0026#34;34553\u0026#34;, \u0026#34;Tjenesteeier\u0026#34;: null, \u0026#34;Kontaktperson\u0026#34;: { \u0026#34;navn\u0026#34;: \u0026#34;Sophie Salt\u0026#34;, \u0026#34;epost\u0026#34;: \u0026#34;1337@altinnstudiotestusers.com\u0026#34;, \u0026#34;telefonnummer\u0026#34;: \u0026#34;90001337\u0026#34; }, \u0026#34;OEnsketBruk\u0026#34;: null } Providing data as application/xml Content-Type: application/xml \u0026lt;BliTjenesteeier_M xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; dataFormatProvider=\u0026#34;SERES\u0026#34; dataFormatId=\u0026#34;5703\u0026#34; dataFormatVersion=\u0026#34;34553\u0026#34;\u0026gt; \u0026lt;Kontaktperson\u0026gt; \u0026lt;navn\u0026gt;Sophie Salt\u0026lt;/navn\u0026gt; \u0026lt;epost\u0026gt;1337@altinnstudiotestusers.com\u0026lt;/epost\u0026gt; \u0026lt;telefonnummer\u0026gt;90001337\u0026lt;/telefonnummer\u0026gt; \u0026lt;/Kontaktperson\u0026gt; \u0026lt;/BliTjenesteeier_M\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/v2/",
	"title": "v2",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.",
	"content": "2.5.10 Dependency on .NETStandard2.0 The package was changed to depend on .NetStandard2.0 in place of .NetStandard2.1. This should ensure that applications based on .NET Framework 4.7 can use the package. 2.5.9 Expanded the eFormidlingContract with SecurityLevel eFormidlingContract model was given a new property holding security level information. #5740 2.5.8 Extended eFormidlingContract with additional parameters eFormidlingContract model was given three new properties to support eFormidling in apps. #5740 2.5.7 Extended eFormidlingContract with a new property: sendAfterTaskId eFormidlingContract model was given a new property to identify which task should trigger an eFormidling shipment. #5740 2.5.6 Adjustments around PresentationField and texts Fixes to how PresentationFields were annotated. New class PresentationTexts to hold a list of texts generated by presentation field rules on an instance. 2.5.5 Added PresentationFields to Application New class PresentationField to represent a data extraction rule. Instance model was given a new property called presentationFields. #5638 2.5.4 Fix the OpenAPI specification of ReadStatus ReadStatus was changed to be defined as a string. #5637 2.5.3 eFormidling support Added a new model to support integration with eFormidling. 2.5.2 Dependency on .NETStandard2.1 The package was changed to depend on .NetStandard2.1 in place of .NETCoreApp3.1. The dependency to the Microsoft.AspNetCore.Mvc.NewtonsoftJson package was removed and there is now instead a direct dependency to the Newtonsoft.Json package. 2.5.1 DataElement IsRead is true by default The value of IsRead is changed to have default value true. "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/",
	"title": "v3",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v3 av app frontend.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i app frontend i v3.0.0\nHva er nytt?\rOversikt over endringer som ble introdusert i v3 av app frontend.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/enterpriseuser/",
	"title": "Autentisere med virksomhetsbruker",
	"tags": [],
	"description": "Beskrivelse hvordan man kan benytte virksomhetsbrukere i Altinn 3",
	"content": "Overordne beskrivelse Virksomhetsbrukere er et konsept hvor man kan benytte et virksomhetssertifikat i kombinasjon med et brukernavn/passord.\nVirksomhetsbrukere må bli tildelt roller og/eller rettigheter fra virksomheten de tillhører, men brukeren kan så bruke disse rettighetene i maskin til maskin kommunikasjon med Altinn uten at noen person i virksomheten må involveres i autorisasjon.\nVirksomhetsbrukere i Altinn 3 Virksomhetbrukere i Altinn 3 kan benyttes via vanlig virksomhetsbrukerinnlogging på Altinn.no med sertifikat lagret i nettleser, men er mest relevant i sammenheng med API bruk.\nDette gjøres ved å kombinere maskinporten for selve autentisering av sertifikatet, samt en innveksling av maskinportentoken sammen med brukernavn og passord.\nAdministrasjon av virksomhetsbrukere er dokumentert her.\nPålogging og veksling av token er dokumenter her her\nPostman eksempel finnes her.\nVidere bruk mot Altinn App API og Platform API er tilsvarende som man har et Altinn token basert på en ID-porten sesjon.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/design/guidelines/components/picture-component/",
	"title": "Bilde",
	"tags": [],
	"description": "Bruk bilder og illustrasjoner for å fremheve poenger eller illustrere konsepter som er vanskelig å beskrive med tekst",
	"content": "Retningslinjer: Du må legge til alternative tekster som beskriver bildet. Hvis bilde bare er dekorativt, er det best å ikke inkludere en alternativ tekst. Ikke bruk bilder for bildets skyld, spør det selv om dette er noe som illustrerer et poeng eller øker forståelsen av det du prøver å formidle Test om bildet skalerer bra på forskjellige skjermstørrelser som mobil og nettbrett. Et bilde som ser bra ut på en PC kan fort ta veldig mye plass på en mindre skjerm Unngå bilder med tekst i, dette kan ikke leses av skjermlesere Hvordan skrive en god alternativ tekst Det er viktig at måten vi skriver alternative tekster er konsekvente. Vi anbefaler derfor at vi følger måten UUtilsynet foreslår.\naldri start med \u0026ldquo;bilde av\u0026hellip;\u0026rdquo; skriv kort og begynn med det viktigste avslutt ved å si om det er foto, illustrasjon eller grafikk Eksempel \u0026ldquo;Tre gamle tretraller. Foto.\u0026rdquo;\nEksempel på bruk: "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/partytype/",
	"title": "Aktørtyper",
	"tags": [],
	"description": "Hvordan sørge for at kun bestemte typer aktører kan bruke en app.",
	"content": "Avgrense tilgang i Altinn Studio designer I Altinn Studio designer finner du mulighet for å styre hvilke aktørtyper som har tilgang til en app i kategorien \u0026ldquo;Lage\u0026rdquo; i toppmenyen, på siden \u0026ldquo;Tilgangsstyring\u0026rdquo; representert ved låshull-ikonet. På denne siden krysser du av for de aktørtypene en app er tilgjengelig for. Hvis ingen (eller alle) aktørtyper er valgt, vil alle ha tilgang. Valget \u0026ldquo;Virksomhet\u0026rdquo; benyttes for tilfeller der det skal rapporteres på hovedenhet.\nSkjermdumpen under viser innstillingene for at alle organisasjonsnummer (både hovedenheter og underenheter) skal kunne bruke appen.\nJustere i applicationmetadata.json Hvis du foretrekker å jobbe i kode, finner du muligheten til å justere hvilke aktørtyper som kan benytte en app i applicationmetadata.json som ligger i mappa App/config i app-repositoryet. Eksempelet under viser samme innstillinger som skjermdumpen.\n\u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: true, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: true }, "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/dashboard/",
	"title": "Dashboard i Altinn Studio",
	"tags": [],
	"description": "Hvordan bruke dashboardet i Altinn Studio",
	"content": "Kontekst I dashboardet har man mulighet til å sette hvilken kontekst man ønsker å filtrere applikasjoner på. Dette gjøres ved å klikke på profilikonet til høyre i dashboardet.\nHer vil man få opp en meny over hvilke kontekster man kan filtrere på. Konteksten kan være en organisasjon man er del av, alle, eller seg selv.\nVelger man en gitt organisajon vil det kun være disse appene som er synlig i listen i dashboardet.\nFavoritter Fra dashboardet har man enkel tilgang til sine favoritter. Favorittene i dashboardet gjenspeiler \u0026ldquo;Star\u0026rdquo;-konseptet i Gitea, og markerer du et repository som starred i gitea vil det dukke opp som favoritt i dashboardet. Disse applikasjonene vil alltid ligge øverst i dashboardet og vil være synlige uavhengig av valgt kontekst.\nFor å legge til eller fjerne en favorittmarkering kan man toggle stjerne-ikonet.\nSøk Fra dashboardet kan man gjøre et søk blant de applikasjonene man har tilgang til. Dette gjøres fra søkefeltet, og resultatet vil dukke opp i listen under.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/copy-app/",
	"title": "Kopier app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en kopi av applikasjon i Altinn Studio.",
	"content": "I Altinn Studio har man mulighet til å lage en kopi av en eksisterende applikasjon innad i en organisasjon. Dette gjøres fra dashboardet. Merk: for å ha mulighet til å lage en kopi i en org må du ha rettigheter til å opprette nye repositories. Medlemmer av teamene \u0026ldquo;Owners\u0026rdquo; og \u0026ldquo;Developers\u0026rdquo; har disse rettighetene. Dersom du mangler skrivetilgang må du ta kontakt med personen som har administratorrettigheter for din organisasjon.\nKlikk på \u0026ldquo;\u0026hellip;\u0026quot;-ikonet til høyre i raden til applikasjonen du ønsker kopiere.\nVelg \u0026ldquo;Lag kopi\u0026rdquo; fra menyen.\nLegg inn navnet du ønsker den nye applikasjonen skal ha. Dette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er. Navnet bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;. Navnet kan ikke endres etter at appen er publisert.\nOpprett kopien ved å klikke \u0026ldquo;Lag kopi\u0026rdquo;.\nNår applikasjonen har blitt kopiert vil du bli sendt til din nye applikasjon.\nFor at den kopierte applikasjonen skal være klar til å brukes trengs det en liten endring i koden. Denne endringen har automatisk blitt lagt inn som en pull request mot repositoriet ditt. For å navigere til repo klikk på profil-ikonet i høyre hjørne og velg \u0026ldquo;Åpne repository\u0026rdquo;. Naviger så til fanen \u0026ldquo;Pull requests\u0026rdquo; og se at det ligger klar en pull request med navnet \u0026ldquo;Auto-generated: Final changes for cloning app.\u0026rdquo;. Klikk deg inn på denne og se over at endringene stemmer overens med det nye navnet på applikasjonen din.\nOm alt ser greit ut så kan endringen merges ved å klikke på \u0026ldquo;Merge pull request\u0026rdquo;.\nSiste steget som trengs er nå å pulle endringene dine til studio. Naviger så til fanen med den ny appen din og klikk \u0026ldquo;Pull\u0026rdquo; for å hente endringene du nettopp merget. Voila! Du er nå klar til å utvikle på den kopierte appen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/create-app/",
	"title": "Opprette app i Altinn Studio",
	"tags": [],
	"description": "Slik oppretter man en ny applikasjon i Altinn Studio.",
	"content": "Altinn Studio brukes til å opprette applikasjoner (apps). En app kan være alt fra enkle skjemaer til større applikasjoner med både API-er og UI, og alt derimellom.\nDu lager en ny app fra dashboardet i Altinn Studio.\nKlikk på \u0026ldquo;ny app\u0026quot;-knappen i det øvre høyre hjørnet av dashboardet.\nVelg hvem som skal være eier av appen. Hvis du ikke har tilgang for noen organisasjoner, må du velge deg selv så du lager appen i din sandkasse.\nLegg inn navnet på appen.\nDette navnet brukes til å identifisere appen, og brukes også som navn på repository, og i URL-er og API-er Det er noen regler knyttet til navngivning av en applikasjon, utover dette bør være kort og beskrivende som for eksempel \u0026ldquo;sykmelding\u0026rdquo; eller \u0026ldquo;lokalvalg-2019\u0026rdquo;.\nNavnet kan ikke endres etter at appen er gått i produksjon.\nRegler for navngivning av applikasjon\nKan kun inneholde lowercase alfanumeriske tegn og bindestrek (-), Navnet må begynne med en bokstav Navnet må ende med en bokstav eller et tall Opprett appen ved å klikke \u0026ldquo;Opprett applikasjon\u0026rdquo;.\nNår apppen er opprettet vil du videresendes til den nyopprettede appen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/migrate-services/",
	"title": "Migrere tjenester",
	"tags": [],
	"description": "Fra Altinn 2 til Altinn 3.",
	"content": "Migrere en eksisterende tjeneste til Altinn 3 Gjør deg kjent med Tjenesteeier-funksjonalitet i Altinn 3.\nOpprett bruker og app i Altinn Studio.\nNår bruker er opprettet kan du be om å bli en del av en organisasjon. Dette for å kunne samarbeide med andre i organisasjonen og ha tilgang til å kjøre deploy av apper. Utvikle app/tjeneste.\nHer finner du veiledninger som er nyttige når man utvikler en app i Altinn Studio. Se også punkt 9. Laste opp datamodell.\nDet er mulig å gjenbruke datamodeller som er basert på InfoPath uten for store endringer. Slik importerer du datamodellen i Altinn Studio. Kombiner UI editor og kodeverktøy.\nAltinn Studio UI editor gjør det enkelt å legge til og flytte skjema komponenter. Kodeverktøy er enklere å bruke når man skal redigere koden. Test lokalt.\nLokalt test miljø er en effektiv måte å teste apper uten å måtte kjøre en delploy. Test app i testmiljø.\nUnder fanen Deploy i Altinn Studio kan du bygge og deploye app. Når Appen er klart kan du logge inn i test miljøet med en testbruker for å kjøre tjenesten. Sette opp App i produksjonsmiljø og bestille om skjema-side.\nFør man setter app i produksjon må man ha tilgang til et produksjonsmiljø. Nyttig informasjon på om skjema-side gjør bruker av tjenesten selvhjulpen og Altinn brukerservice i stand til å hjelpe brukere. Tilrettelegge system for mottak av data.\nDet finnes standardiserte mønstre basert på REST-API for å sende og motta data fra/til dine interne systemer. Autentisering skjer med Maskinporten og du laster ned data ved pull fra database, og laster opp data direkte mot API i den enkelte applikasjon. Vår referanseapplikasjon Altinn CLI​ viser disse mønstrene og kan brukes for å komme i gang. Konvertere fra tjenster med Altinn2-converter.\nAltinn2-converter er et komandolinje basert verktøy for å konvertere Altinn 2 tjenester til Altinn 3 apps. Dette verktøyet har status som Proof of concept (POC) og kan derfor mangle en del funksjonalitet. Lag en skisse av skjema For å migrere en utvalgt tjeneste kan det være nyttig å lage seg en skisse av tjenesten slik at man gjør seg kjent med designelementer i Altinn 3, og slik at man har en referanse å se til når man utvikler løsningen. Slik gjør du dette.\nVis/skjul innhold\rLage en skisse av skjema i Figma.\rGå inn på nettsiden https://www.figma.com/ og lag deg en bruker. Figma kan installeres lokalt eller brukes i din nettleser. Altinn har et åpent design kit for eksterne og det finner du her. Gå inn på denne siden for å få mer informasjon om hvordan du kan komme i gang med Figma. "
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/process/",
	"title": "Prosess",
	"tags": ["api", "translate-to-norwegian"],
	"description": "API endepunkter for å lede en instans gjennom prosessen som er definert.",
	"content": "Overview All apps have a process definition that specifies start events, end events, tasks and the allowed flows (transitions) between these. A process is started by the application, which selects a start event to start and follows the sequence flow to the first task and creates a current task object to hold the process state.\nA process is represented by an process modell in BPMN/XML notation. Each task has an unique id, which is used to refer to the task in the api.\nProcess model Get the application\u0026rsquo;s process model.\nGET {appPath}/process Returns the bpmn file defining the process.\n\u0026lt;bpmn2:process id=\u0026#34;Process_1\u0026#34; isExecutable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;bpmn2:startEvent id=\u0026#34;StartEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_1\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:startEvent\u0026gt; \u0026lt;bpmn2:task id=\u0026#34;Task_1\u0026#34; name=\u0026#34;Utfylling\u0026#34; altinn:tasktype=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;bpmn2:incoming\u0026gt;Flow_1\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;bpmn2:outgoing\u0026gt;Flow_2\u0026lt;/bpmn2:outgoing\u0026gt; \u0026lt;/bpmn2:task\u0026gt; \u0026lt;bpmn2:endEvent id=\u0026#34;EndEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn2:incoming\u0026gt;Flow_2\u0026lt;/bpmn2:incoming\u0026gt; \u0026lt;/bpmn2:endEvent\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_1\u0026#34; sourceRef=\u0026#34;StartEvent_1\u0026#34; targetRef=\u0026#34;data_1\u0026#34; /\u0026gt; \u0026lt;bpmn2:sequenceFlow id=\u0026#34;Flow_2\u0026#34; sourceRef=\u0026#34;Task_1\u0026#34; targetRef=\u0026#34;EndEvent_1\u0026#34; /\u0026gt; \u0026lt;/bpmn2:process\u0026gt; Altinn specific task types Application developers can in their BPMN Definition specify some altinn specific task types, see altinn:tasktype, which signify the behaviour of the task. So far we have defined the following:\ndata - user is asked to fill inn one or more data elements, e.g. upload data or fill in forms confirmation - user is asked to confirm the correctness of the information which has been filled in on previous tasks feedback - user is asked to wait while external feedback is uploaded to the instance Get process state of a specific instance GET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process For an ongoing process this process state can look like the json below. It indicates that the process was started at a given date time and that it\u0026rsquo;s current task is Task_1. The flow number indicates the sequence of process events/tasks that occurs during the execution of the process. Notice that same task can be visited multiple times in a process if there is a sequence flow that allows that.\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-10T32:22.00Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut\u0026#34;, \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;validated\u0026#34;: { \u0026#34;timestamp\u0026#34;: \u0026#34;2019-10-04T12:00.00Z\u0026#34;, \u0026#34;canCompleteTask\u0026#34;: true } } } For an ended process the following will be returned:\n{ \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; } Process events The system will generate a number of process related events, which can be found in the instances event history.\nStart Event StartTask Event EndTask Event End Event Start Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:Start\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-10T14:01:22.034Z\u0026#34;, } StartTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:StartTask\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-09-25T09:32:44.20Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Fyll ut MVA rapport\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-01T13:22.01Z\u0026#34;, } EndTask Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndTask\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;flow\u0026#34;: 2, \u0026#34;started\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;altinnTaskId\u0026#34;: \u0026#34;data\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34; } }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T01:11.33Z\u0026#34;, } End Event { \u0026#34;instanceId\u0026#34;: \u0026#34;347829/41e57962-dfb7-4502-a4dd-8da28b0885fc\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;process:EndEvent\u0026#34;, \u0026#34;processInfo\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2017-10-01T13:22.00Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, \u0026#34;endEvent\u0026#34;: \u0026#34;EndEvent_1\u0026#34; }, \u0026#34;createdDateTime\u0026#34;: \u0026#34;2019-10-05T08:15:23.544Z\u0026#34;, } Get process history of a specific instance Based on the process events the history of the instance\u0026rsquo;s process is generated. The following illustrates an ended process:\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/history { \u0026#34;processHistory\u0026#34;: [ { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:09.3109169Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_StartTask\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;started\u0026#34;: \u0026#34;2020-01-21T13:49:09.4264322Z\u0026#34;, \u0026#34;ended\u0026#34;: \u0026#34;2020-01-21T13:49:39.66609Z\u0026#34; }, { \u0026#34;eventType\u0026#34;: \u0026#34;process_EndEvent\u0026#34;, \u0026#34;elementId\u0026#34;: \u0026#34;EndEvent_1\u0026#34;, \u0026#34;occured\u0026#34;: \u0026#34;2020-01-21T13:49:39.7681248Z\u0026#34; } ] } Start Process To start a process one can post start to the process endpoint.\nPOST {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/start[?startEvent=StartEvent_1] This will start the process and move the process state to the first task from the given start. If process has more than one start event, then the client has to chose which one to start with the startEvent query parameter.\nComplete and move to next task The process logic attempts to finish the current task and then moves the process forward to the next task in the flow. The cannot always select the next task, especially when more than one tasks can be chosen. In this case the client must chose which process element id to select.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next[?id=Task_2] Complete the process The complete process method will attempt to complete the process for an instance. Hence, the app will move the process from one task to the next until it reaches an valid end state.\nIf a task\u0026rsquo;s exit condition is not met, the process will be stopped in the last valid task. And the user must manually fix the problem and complete the process.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/completeProcess Get the next tasks in a process Returns an list of the next tasks/events that can be reached from the current task.\nGET {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next Start a task If you are at a specific task and want to start the next task you can try to put next to the process endpoint. The process controller then tries to close the current task and start the wanted task. Updates process state accordingly. If exit condition of current task is not met, an error will be returned. If the task is not directly reachable by the flow, an error will be returned.\nPUT {appPath}/instances/347829/41e57962-dfb7-4502-a4dd-8da28b0885fc/process/next?id=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/apps/",
	"title": "Apps infrastruktur tilganger",
	"tags": [],
	"description": "Hvordan bestille tilganger til Altinn Apps infrastruktur.",
	"content": "Tilgang til logger og hemmeligheter Det er definert to forskjellige typer roller for tilgang i driftsmiljøene i Altinn Apps.\nDeveloper gir tilgang til Application Insights der applikasjonslogger samles for tjenesteeier sine applikasjoner i miljøet. Operations gir tilgang til Key Vault for å laste opp hemmeligheter som sertifikater, passord og api-nøkler. Disse rollene er videre delt opp i tilgang til test (TT02) og produksjon (prod). En bruker kan tildeles en eller flere roller.\nTjenesteeiere kan bestille følgende tilganger for sine ressurser i miljøene TT02 og produksjon:\nTest Developer Test Operations Prod Developer Prod Operations For å få aksess til disse rollene må autoriserte bestillere hos Tjenesteeier, bestille dette på vår Selvbetjeningsportal. Velg Support, så ny sak. Her skal du finne skjemaet Apps under menyvalget Bestilling/tilganger.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/datafields/",
	"title": "Datafelter på instansobjektet",
	"tags": [],
	"description": "Konfigurasjon av datafelter for app.",
	"content": "I noen tilfeller kan det være nyttig å legge ekstra informasjon på instansobjektet f. eks. for å kunne basere ruting av instans til rett system i bakkant hos tjenesteeier.\nDette kan gjøres på to måter, ved konfigurasjon eller manuelt. Ved konfigurasjon vil systemet ekstrahere data fra skjemafeltene og legge disse på instansobjektet. Man er da begrenset til skjemafelter, men slipper å programmere dette selv. Hvis man velger å gjøre det manuelt har man frihet til å legge på de dataene man selv ønsker f. eks. fra eksterne apier, kalkuleringer, faste strenger etc.\nDet er også mulig å benyttes seg av begge metoder så lenge man benytter seg av forskjellige id\u0026rsquo;er på datafeltene. De konfigurerte verdiene vil da flettes sammen med de manuelle på instansen.\nDatafelter er på mange måter tilsvarende presentasjonsfelter. Men der hvor bruken av presentasjonsfelter er forhåndsbestemt (benyttes i meldingsboksen til Altinn), er bruken av datafelter opp til den enkelte applikasjonseier.\nKonfigurasjon Konfigurasjon av datafelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn dataFields med følgende underfelter\nNavn Beskrivelse id Id på datafeltet. Benyttes til å identifisere feltet når den er lagret på instansen. path Datamodell path til skjemafeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen. dataTypeId Id på datamodellen som verdien skal hentes fra. Konfigurasjonen til en app med to definerte datafelter vil se slik ut:\n\u0026#34;dataFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;AnsettelseAntAar\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }] Resultatet vil være en liste på instansobjektet med verdier fra de konfigurerte feltete:\n\u0026#34;dataValues\u0026#34;: { \u0026#34;AnsettelseAntAar\u0026#34;: 10, \u0026#34;Navn\u0026#34;: \u0026#34;Ola Nordmann\u0026#34; } Legg merke til at det på instansobjektet heter dataValues mens når det konfigureres heter dataFields, det er fordi dataValueser resultatet av konfigureringen som gjøres på dataFields.\nManuelt For å legge til dataverdier manuelt benyttes metoden UpdateDataValues fra IInstance interfacet. Det er den samme metoden som kalles når dataverdier populeres fra konfigurasjon og den sørger for å flette sammen verdiene til en liste.\nMerk at det er applikasjonsutvikler sitt ansvar å sørge for unike id\u0026rsquo;er hvis man kombinerer dataverdier fra konfgiurasjon og manuelt. Har man ikke unike id\u0026rsquo;er vil verdier overskrives, og man har ingen garanti for hvilken som blir lagret på instansen.\rEksemplet under viser hvordan man kan sette datavedier manuelt. I dette tilfellet gjøres det ved å gjøre legge inn kode i RunProcessTaskEnd i App.cs som kjører når en task avsluttes.\npublic override async Task RunProcessTaskEnd(string taskId, Instance instance) { var customDataValues = new DataValues() { Values = new Dictionary\u0026lt;string, string\u0026gt;() { { \u0026#34;customKey\u0026#34;, \u0026#34;customValue\u0026#34; } } }; var (instanceOwnerPartyId, instanceGuid) = InstanceHelper.DeconstructInstanceIdFromUrl(_httpContextAccessor.HttpContext.Request.Path.Value); await _instanceService.UpdateDataValues(instanceOwnerPartyId, instanceGuid, customDataValues); await Task.CompletedTask; } Man bør også tenke gjennom når man trenger disse verdiene på instansobjektet slik at man ikke gjør unødvendige api kall og dermed får en dårligere ytelse på applikasjonen.\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/deploy/",
	"title": "Test app i testmiljø",
	"tags": [],
	"description": "Beskrivelse av hvordan test i testmiljø kan utføres.",
	"content": "Klargjøring av app og deploy til testmiljø gjøres fra Deploy-fanen i Altinn Studio.\nBygge app Før en app kan deployes til testmiljø, må alle nødvendige filer samles sammen i en pakke som kan deplpoyes. Dette gjøres ved å bygge appen.\nMerk at det er filene fra app-repoet som benyttes i bygget. Dersom en har gjort endringer på en app i Altinn Studio så må disse sendes til repoet for at endringene skal bli med i bygg-pakken. Dette gjøres ved å velge Push fra Lage-fanen i Altinn Studio.\rNår en app er klar til test, kan den bygges ved å gå til Deploy-fanen i Altinn Studio (inne på den appen som skal deployes).\nPå høyre side vises et panel for å bygge appen.\nMerk at det kun er mulig å bygge ny versjon av appen dersom det faktisk er gjort endringer i appen. Dersom det er gjort endringer og det ikke er mulig å bygge ny versjon, pass på at endringene har blitt sendt til app repoet.\rSkriv inn versjonsnummer for den versjonen av appen som skal bygges. Må være unikt (altså ikke brukt tidligere for denne appen). Skriv inn beskrivelse for denne versjonen av app\u0026rsquo;en. Trykk på Bygg versjon for å starte bygget. Status for bygget vises under Tidligere bygg av applikasjonen. Når status er grønn, er denne versjonen av app\u0026rsquo;en klar til å bli deployet til testmiljø.\nDeploy av app til testmiljø Når en app er bygget ferdig kan den deployes til testmiljø. Dette gjøres fra Deploy-fanen. Der vises en oversikt over tilgjengelige miljø, i tilegg til en oversikt over hvilke versjoner av appen som er i de forskjellige miljøene.\nVelg versjonen av appen som skal deployes fra nedtrekkslisten som ligger under det aktuelle miljøet. Trykk på Deploy ny versjon. Valgt versjon vil da deployes til valgt miljø. Her er det mulig å deploye ny versjon, eller rulle tilbake til en eldre versjon om det er ønsket.\nTeste app i testmiljø Logg inn i testmiljø med testbruker. Bruk lenken som vises over hvert miljø i Deploy-fanen for å komme til ønsket testmiljø og starte ny instans av appen.\nAlle instanser vil være synlig i meldingsboks/arkiv til valgt aktør, på samme måte som dagens tjenester (som er basert på Altinn II).\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/id-porten/",
	"title": "Autentisere med ID-porten",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "Systemer for sluttbrukere kan autentisere brukere via ID-porten. Dette for å kunne benytte API fra applikasjoner kjørende i Altinn Apps og enkelte funksjoner i Altinn Platform på vegne av sluttbruker.\nDet er i hoveddsak to typer systemer hvor dette er aktuelt. Dette er webbaserte løsninger og tykke klienter.\nFelles for begge løsninger er at sluttbruker vil logge inn via nettleser i ID-porten med den autentiseringsmekanismen de ønsker.\nDette er for eksempel:\nMin-ID BankID på mobil BankId Systemet må forespøre et sett med scopes i ID-porten som sluttbruker må akseptere at systemet kan utføre på vegne av sluttbruker.\nDet er disse scopene som tildels avgrenser hva systemet kan utføre på vegne av sluttbruker.\nScopene som er definert og relevant for Altinn 3 er:\naltinn:instances.meta - Se oversikt over innboks og arkiv i Altinn altinn:instances.read - Lese innholdet i innboks og arkiv i Altinn for alle elementer som sluttbruker er autorisert for altinn:instances.write - Fylle ut, signere og sende inn skjema i Altinn for alle elementer sluttbruker er autorisert for altinn:lookup - Benytte innsynstjenester i Altinn altinn:reportees - Se hvem du kan representere i Altinn Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nFor detaljer om scope og opplisting av alle scopes tilgjengelig se dokumentasjon fra ID-porten.\nDet er disse scopene som avgjør hva sluttbruker kan utføre. Bildet nedenfor viser hvordan sluttbruker må bekrefte tilgangen.\nNår pålogging er gjennomført vil systemet ha tilgang til et ID-token, refresh token og et access token.\nDette access tokenet har begrenset levetid, men kan fornyes med ved hjelp av refresh token.\nWeb baserte systemer Webbaserte systemer består av løsninger med en webbasert frontend som kjører i nettleser, samt serverside kode.\nSe detaljer hos ID-porten.\nTykke klienter Med tykke klienter mener vi applikasjoner som installeres og kjøres lokalt på en datamaskin og ikke i nettleser.\nDisse må likevel benytte seg av nettleser for å logge inn.\nSe detaljer hos ID porten.\nVeksling av access token til Altinn token Access-tokenet som utstedes fra ID-porten må veksles inn i et Altinn-token før det kan benyttes mot Altinns API\u0026rsquo;er.\nDette Altinn-tokenet vil ha samme levetid som access-tokenet.\nFlytdiagrammet nedenfor viser hvordan tokenet veksles inn.\nSe detaljer i Altinns API dokumentasjon under metoden GET /exchange/{tokenProvider}.\nSluttbrukere har i Altinn mulighet til å få oversikt over alle systemer og hvilke tilganger de har.\nPå denne måten kan man trekke langvarige tilganger. Systemet vil da bli avvist neste gang det prøver å refresehe access-token.\nBildet nedenfor viser hvordan dette vil bli i Altinn (ikke satt i produksjon enda).\nEt system som har fått tilgang til et token fra ID-porten vil kunne utføre handlinger som bruker er autorisert kun begrenset av bruksområdet til scope. Det betyr at hvis system har fått scope for innsending av skjema så vil systemet kunne sende inn alle skjema for alle avgivere som sluttbruker er autorisert for. Det er derfor viktig at sluttbruker kan stole på systemet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/instance-events/",
	"title": "Instance events",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Plattform API for å jobbe med instans-hendelser.",
	"content": "Instance events All instance events, e.g. creation, read, save, change process state, \u0026hellip;\nGET {storagePath}/instances/347829/762011d1-d341-4c0a-8641-d8a104e83d30/events Example of event data.\n{ \u0026#34;id\u0026#34;:\u0026#34;6dff32bc-0928-4ae8-937c-b362d6941c89\u0026#34;, \u0026#34;instanceId\u0026#34;: \u0026#34;60238/5c6b1a71-2e1f-447a-ae2f-d1807dcffbfb\u0026#34;, \u0026#34;eventType\u0026#34;: \u0026#34;deleted\u0026#34;, \u0026#34;created\u0026#34;: \u0026#34;2019-05-02T13:08:21.981476Z\u0026#34;, \u0026#34;instanceOwnerPartyId\u0026#34;: \u0026#34;60238\u0026#34;, \u0026#34;user\u0026#34;: { \u0026#34;userId\u0026#34;: 338829, \u0026#34;authenticationLevel\u0026#34;: 1, \u0026#34;enduserSystemId\u0026#34;: 2 }, \u0026#34;process\u0026#34;: { \u0026#34;started\u0026#34;: \u0026#34;2019-05-01T12:45:01.3233Z\u0026#34;, \u0026#34;startEvent\u0026#34;: \u0026#34;Start_22\u0026#34;, \u0026#34;currentTask\u0026#34;: { \u0026#34;elementId\u0026#34;: \u0026#34;Task_2\u0026#34; } } } Application events (for application owners) WARNING: This section will be redesigned\nSelected instance events. Created, first read, change process state. Optinally specified by application developer.\nEvents can be queried. May be piped.\nGET {storagePath}/applications/org/app/events?created=gte:2019-03-30\u0026amp;process.currentTask=Task_2 "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/config/",
	"title": "Preutfylling av data med konfigurasjon",
	"tags": [],
	"description": "Hvordan konfigurere prefill for en app.",
	"content": "Ved bruk av kun konfigurasjon støtter Altinn apps prefill med data fra Enhetsregisteret, Folkeregisteret og brukerprofil i Altinn.\nVed å følge beskrivelsen nedenfor vil man under instansiering av et skjema preutfylle datamodellen med de definerte verdiene hentet fra Altinns database.\nPrefill fra nasjonale register og brukerprofil Oppsett av prefill i applikasjons repository Opprett en ny json-fil i app repoet under App/models. Navnet på filen skal inneholde navnet på datamodellen og ha postfix \u0026ldquo;.prefill.json\u0026rdquo;. Dersom datamodellen din heter appModel skal du nå kunne finne disse tre filene i mappen: appModel.metadata.json, appModel.schema.json, appModel.prefill.json\nLim inn innholdet nedenfor i filen.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/prefill/prefill.schema.v1.json\u0026#34;, \u0026#34;allowOverwrite\u0026#34;: true, \u0026#34;ER\u0026#34;: { }, \u0026#34;DSF\u0026#34;: { }, \u0026#34;UserProfile\u0026#34;: { } } Konfigurering av prefill.json $schema peker på json schema definisjonen til filen. Nåværende versjon er v1.\nVisual Studio Code vil pga. denne validere og tilby intellisense/autocomplete når du editerer filen lokalt.\nallowOverwrite avgjør om prefill definert i denne filen kan overskrive et felt i datamodellen dersom det allerede har en verdi.\nER her legger man inn felter fra datamodellen som skal preutfylles med data fra enhetsregisteret. Felt som preutfylles med ER-data vil kun få en verdi dersom man instansierer på vegne av en organisasjon. Instansiering vil feile dersom man forsøker å preutfylle ER-data, men ikke har en organisasjon tilgjengelig.\nEksempelet nedenfor vil populere feltet Datamodell.Organisasjon.Organisasjonsnummer med organisasjonsnummeret hentet fra enhetsregisteret.\n\u0026#34;ER\u0026#34;: { \u0026#34;OrgNumber\u0026#34;:\u0026#34;Datamodell.Organisasjon.Organisasjonsnummer\u0026#34; } DSF her legger man inn felter fra datamodellen som skal preutfylles med data fra folkeregistret. Feltet som preutfylles med DSF-data vil kun få en verdi dersom man instansierer på vegne av en person. Instansiering vil feile dersom man forsøker å preutfylle DSF-data, men ikke har en person tilgjengelig. Eksempelet nedenfor vil populere feltet Datamodell.Person.Nummer med telefonnummer henter fra folkeregistret.\n\u0026#34;DSF\u0026#34;: { \u0026#34;TelephoneNumber\u0026#34;:\u0026#34;Datamodell.Person.Nummer\u0026#34; } UserProfile her legger man inn telter fra datamodellen som skal preutfylles med data fra brukerens profil i Altinn. Merk at det er den innloggede brukeren om instansierer man henter ut data for. Eksempelet nedenfor vil populere feltet _Datamodell.Bruker.Epost med epost hentet fra brukerens profil i Altinn.\n\u0026#34;UserProfile\u0026#34;: { \u0026#34;Email\u0026#34;:\u0026#34;Datamodell.Bruker.Epost\u0026#34; } Tilgjengelige prefill verdier JSON-schema definisjonen av prefill-filen er også tilgjengelig her.\nBruken av et schema gjør at editorer, f.eks. Visual Studio Code, kan validere og tilby intellisense for raskere editering.\nFolkeregisteret Personedataen som eksponeres er den tilknyttet personen som skjemaet instansieres på vegne av. Dersom Ola Nordman instansierer et skjema på vegne av Kari Nordmann vil det være Kari sin data som eksponeres. Tilgjengelige verdier for prefill inkluderer:\nSSN Name FirstName MiddleName LastName TelephoneNumber MobileNumber MailingAddress MailingPostalCode MailingPostalCity AddressMunicipalNumber AddressMunicipalName AddressStreetName AddressHouseNumber AddressHouseLetter AddressPostalCode AddressCity Enhetsregisteret Enheten som eksponeres er den tilknyttet organisasjons som et skjema blir instansiert på vegne av. Tilgjengelige verdier for prefill inkluderer:\nOrgNumber Name UnitType TelephoneNumber MobileNumber FaxNumber EMailAddress InternetAddress MailingAddress MailingPostalCode MailingPostalCity BusinessAddress BusinessPostalCode BusinessPostalCity Brukerprofil Brukerprofilen som eksponeres er profilen til den som instansierer tjenesten. Dersom Ola Nordmann instansierer et skjema på vegne av Kari Nordmann vil dataen som hentes ut herfra være knyttet til Ola. For objektene Party.Organization og Party.Person vil man finne igjen samme feltene som man ser i ER og DSF-prefill. Merk at Party.Organization vil være null om brukeren er logget inn som en privatperson, og tilsvarende for Party.Person om man er logget inn med en virksomhetsbruker. Preutfyllingen vil feile om objektet man preutfyller fra ikke finnes, så om man ønsker å dynamisk preutfylle basert på disse verdiene må dette settes opp som egendefinert prefill.. Tilgjengelige verdier for prefill inkluderer:\nUserId UserName PhoneNumber Email PartyId Party.PartyId Party.PartyTypeName Party.OrgNumber Party.SSN Party.UnitType Party.Name Party.isDeleted Party.OnlyHierarchyElementWithNoAccess Party.Person Party.Organization Party.ChildParties UserType ProfileSettingPreference.Language ProfileSettingPreference.PreSelectedPartyId ProfileSettingsPreference.DoNotPromptForParty Egendefinert prefill Altinn apps muliggjør prefill av en instans med egendefinert data, det være seg resultet fra et API-kall, beregninger gjort under instansiering, eller annen logikk. Dette implementeres i metoden DataCreation i filen InstansiationHandler.cs som finnes i applikasjonsrepoet under App/logic.\nEksempelet nedenfor populerer feltet Bruker.FulltNavn i modellen Datamodell med verdien \u0026ldquo;Test Testesen\u0026rdquo;.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; model.Bruker.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } Bytt ut Datamodell med navnet på C# klassen som er blitt generert basert på xsd-en som ble lastet opp i Altinn Studio. Dersom du bruker en egnet kodeeditor vil du kunne definere felter som skal populeres ved bruk av intellisense.\nVær oppmerksom på at dersom du har komplekse typer i modellen din, må disse instansieres før man kan tilegne en verdi til ett av typens underelementer. Se eksempel nedenfor der vi legger til grunn at \u0026lsquo;Bruker\u0026rsquo; og \u0026lsquo;Name\u0026rsquo; er egne C# klasser.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; Bruker b = new Bruker(); b.Navn = new Name(); b.Navn.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } Instansiering med prefill Altinn apper støtter instansiering med prefill. Skjemadataen legges ved i en multipart i instansieringsrequesten som sendes til appen. Nedenfor ser du et eksempel på en request for å instansiere en app med prefill for partyId 12345.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; Body: --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;PartyId\u0026#34; : \u0026#34;12345\u0026#34; } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;Endring-av-navn\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;1533\u0026#34; spesifikasjonsnummer=\u0026#34;11172\u0026#34; blankettnummer=\u0026#34;RF-1453\u0026#34; tittel=\u0026#34;Endring av navn\u0026#34; gruppeid=\u0026#34;9308\u0026#34;\u0026gt; \u0026lt;Innledning-grp-9309 gruppeid=\u0026#34;9309\u0026#34;\u0026gt; \u0026lt;NavneendringenGjelderFor-grp-9310 gruppeid=\u0026#34;9310\u0026#34;\u0026gt; \u0026lt;SubjektFornavnFolkeregistrert-datadef-34730 orid=\u0026#34;34730\u0026#34;\u0026gt;Ola Nordmann\u0026lt;/SubjektFornavnFolkeregistrert-datadef-34730\u0026gt; \u0026lt;/NavneendringenGjelderFor-grp-9310\u0026gt; \u0026lt;Kontaktinformasjon-grp-9311 gruppeid=\u0026#34;9311\u0026#34;\u0026gt; \u0026lt;MelderFultnavn orid=\u0026#34;34735\u0026#34;\u0026gt;LANGØY MADS\u0026lt;/MelderFultnavn\u0026gt; \u0026lt;/Kontaktinformasjon-grp-9311\u0026gt; \u0026lt;/Innledning-grp-9309\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/",
	"title": "Navigasjon i Altinn Studio",
	"tags": [],
	"description": "Slik navigerer du mellom de ulike delene av Altinn Studio.",
	"content": "Som bruker av Altinn Studio kan du bruke ulike verktøy, avhengig av kompetanse, preferanser og kompleksiteten på det du skal utvikle. Hvordan du navigerer er ulikt mellom verktøyene.\nDesigner\rSlik navigerer du i Altinn Studio Designer.\nRepos\rSlik navigerer du i Altinn Studio Repos.\nCode\rSlik navigerer du i Altinn Studio Code.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/presentationfields/",
	"title": "Presentasjonsfelter",
	"tags": [],
	"description": "Konfigurasjon av presentasjonsfelter for app.",
	"content": "I noen tilfeller kan det være nyttig med presentasjonsfelter for å enklere kunne skille mellom flere instanser av samme applikasjon.\nVed å konfigurere presentasjonsfelter på en applikasjon vil man hente ut verdier fra skjemadataene og legge dette på instansobjektet. Disse verdiene benyttes i meldingsboksen i Altinn til å berike tittelen til instansen med dataverdiene.\nKonfigurasjon Konfigurasjon av presentasjonsfelter gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn presentationField med følgende underfelter:\nNavn Beskrivelse id Id på presentasjonsfeltet. Benyttes til å identifisere presentasjonsteksten når den er lagret på instansen. path Datamodell path til presentasjonsfeltet. Denne verdien er den samme som bindes til en komponent i layoutfilen til appen. dataTypeId Id på datamodellen som verdien skal hentes fra. Konfigurasjonen til en app med to definerte presentasjonsfelter vil se slik ut:\n\u0026#34;presentationFields\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;Ansettelse\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.Arbeidsforhold-grp-8856.AnsattAar-datadef-33267.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;Navn\u0026#34;, \u0026#34;path\u0026#34;: \u0026#34;OpplysningerOmArbeidstakeren-grp-8819.OpplysningerOmArbeidstakeren-grp-8855.AnsattNavn-datadef-1223.value\u0026#34;, \u0026#34;dataTypeId\u0026#34;: \u0026#34;default\u0026#34; } ] Resultat Resultatet i meldingsboksen vil være tittel på applikasjonen med påfølgende presentasjonstekster i en kommaseparert liste.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/",
	"title": "Definere applikasjonsprosess",
	"tags": [],
	"description": "Hvordan definere prosessen til en app.",
	"content": "En applikasjon har definert en prosess som styrer flyten. Prosessen er definert som BPMN 2.0.\nStøttede prosess-task-typer Nåværende applikasjonsmal støtter følgende tasks.\nData (Data) (Tilsvarer utfyllingssteg i Altinn II) Bekreftelse (Confirmation) Feedback Fremtidige prosess-tasker (tentativ) Signering (Signing) Betaling (Payment) Parallellsignering (Paralell Signing) Brukerstyrt signering (User Controlled Signing) Ekstern validering (External Validation) Endre prosessen For å endre på prosessen kan du manuelt redigere BPMN-filen med en valgfri XML- eller BPMN-editor. Den ligger lagret i app-repoet som App/config/process/process.bpmn.\nAutomatisk sletting\rEn applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.\nDefiner egendefinerte prosess hooks\rDefiner egendefinert kode som skal kjøres før eller etter en task er startet eller avsluttet\nExclusive Gateways\rDefiner egendefinert kode som avgjør flyt ut av en exclusive gateway\nMelding\rHvordan sette opp en melding i Altinn Studio.\nTilpasse visninger av steg\rHvordan tilpasse visninger i forskjellige steg av en prosess.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/queryparameters/",
	"title": "Query parametere",
	"tags": [],
	"description": "Tilgjengelige query parametere for en app.",
	"content": "returnUrl Query parameteret returnUrl brukes av appen for å videresende brukeren til den spesifiserte verdien i returnUrl, når brukeren trykker på avslutt-knappen i appen.\nRegler:\nreturnUrl må ha et gyldig URL-format Host navnet definert i returnUrl må være det samme som appen man lenker til (se eksempelet nedenfor). Verdien til returnUrl må være en base64-streng Eksempel uten base64:\nhttps://foo.apps.tt02.altinn.no/foo/bar?returnUrl=https://foo.apps.tt02.altinn.no/foo/foobar\nEksempel med base64:\nhttps://foo.apps.tt02.altinn.no/foo/bar?returnUrl=aHR0cHM6Ly9mb28uYXBwcy50dDAyLmFsdGlubi5uby9mb28vZm9vYmFy\nHer ser man at returnUrl er en gyldig URL og at den peker mot samme host navn som appen.\nEksemplene under inneholder ikke base64 for lesbarhet.\nMan kan derimot ikke lenke til annet host navn:\nhttps://foo.apps.tt02.altinn.no/foo/bar?returnUrl=https://foo.apps.altinn.no/foo/foobar\nDet er viktig med korrekt rekkefølge i URLen, og her er et eksempel som viser den korrekte rekkefølgen: https://ttd.apps.at21.altinn.cloud/ttd/level1-app?returnUrl=https%3A%2F%2Fttd.apps.at21.altinn.cloud%2Fttd%2Fapps-test%2F%23%2Finstance%2Finstanceownerid%2Finstanceguid/#/instance/instanceownerid/instanceguid\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/repos/",
	"title": "Repos",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Repos.",
	"content": "Repos er verktøyet der appene er lagret som Git repositoryer, og kan bli funnet på https://altinn.studio/repos.\nHovedmeny Hovedmenyen øverst inneholder disse elementene:\nAltinn-logoen - tilbake til Altinn Studio-dashboardet. Dashboard - Lister ut dine aktiviteter og de repositoryene og organisasjonene du har tilgang til. Du kan også se dashboard for den enkelte organisasjonen. Issues - Lister ut åpne og lukkede issues som er relevant for deg. Pull requests - Lister ut åpne og lukkede pull requests som er relevant for deg. Utforsk - Gir deg tilgang til å se alle repositoryer, brukere og organisasjoner Navigere innad i et repository Når du har navigert til et repository dukker det opp et nytt sett menyvalg som er relevant for repositoryet.\nKode - innholdet, alle filer appen består av Issues - \u0026ldquo;saker\u0026rdquo; for repositoryet Pull Requests - for repositoryet Releases - opprettet for repositoryet Aktivitet - hva har skjedd i repositoryet Hvis du vil til Designer for det aktuelle repositoryet, er det et valg for dette i toppmenyen:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/messagebox/hide_instances/",
	"title": "Skjule instanser",
	"tags": [],
	"description": "Konfiurasjon for å skjule instanser fra meldingsboksen.",
	"content": "For applikasjoner med en kompleks appflyt kan det være nyttig å skjule instanser fra meldingsboksen under deler av prosessen eller for hele prosessen.\nKonfigurasjon Konfigurasjonen har tilbakevirkende kraft på tidligere opprettede instanser.\rKonfigurasjon av skjuling fra meldingsboks gjøres i applicationmetadata.json som ligger i repoet under mappen App/config.\nLegg til en ny seksjon med navn messageBoxConfiguration med følgende underfeltet hideSettings.\nHideSettings kan igjen bestå av én av to properties\nNavn Beskrivelse hideOnTask En liste med tasker der instanser skal skjules fra meldingsboksen. hideAlways En boolean som indikerer om instansen alltid skal skjules fra meldingsboksen. Eksempler Konfigurasjonen til en app der instanser skal skjules på Task_1 og Task_3, men være synlig på alle andre prosess-steg:\n\u0026#34;messageBoxConfig\u0026#34;: { \u0026#34;hideSettings\u0026#34;: { \u0026#34;hideOnTask\u0026#34;:[\u0026#34;Task_1\u0026#34;, \u0026#34;Task_3\u0026#34;] } } Konfigurasjonen til en app der instanser aldri skal vises i meldingsboksen.\n\u0026#34;messageBoxConfig\u0026#34;: { \u0026#34;hideSettings\u0026#34;: { \u0026#34;hideAlways\u0026#34;:true } } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/studio/",
	"title": "Altinn Studio tilganger",
	"tags": [],
	"description": "Hvordan konfigurere tilganger for team i Altinn Studio.",
	"content": "Tilgangsstyring for organisasjonen Som eier av en organisasjon i Altinn Studio har man mulighet til å konfigurere tilgangene til de øvrige brukerne knyttet til organisasjonen. Dette gjøres via Gitea på følgende lenke: https://altinn.studio/repos/org/{org}/teams/\nDet er definert fire standard team som legger føringer for hva en bruker har tillatelse til å gjøre innad i en organisasjon i Altinn Studio. Ved behov kan man som eier kan man legge til/fjerne brukere i team, opprette nye team og endre konfigurasjon på eksisterende team.\nOwners Beskrivelse Medlemmer i dette teamet kan tenkes på som administrator for organisasjonen. De vil kunne administrere tilgangsstyringen for alle team og repositories knyttet til organisasjonen.\nSom medlem i dette teamet kan man blant annet:\nopprette/slette team legge til og fjerne brukere i ulike team endre konfigurasjon for team Konfigurasjon Dette teamet ligger inne som standard i alle organisasjoner og det er ikke mulig å endre konfigurasjonen for dette teamet.\nDeploy-Production Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til produksjonsmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\nLesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til produksjonsmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\nLese samtlige repositories Aksessere alle områder i Gitea Deploy-TT02 Beskrivelse Medlemmer i dette teamet kan deploye applikasjoner til testmiljøet.\nØvrige rettigheter kan defineres fritt av owners. Default konfigurasjon inkluderer rettigheter for:\nLesetilgang i samtlige repositories Kan ikke opprette nye repositories Full tilgang til alle områder i Gitea Konfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, muligheten til å deploye til testmiljø er ikke avhengig av øvrig config.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\nLese samtlige repositories Aksessere alle områder i Gitea Devs Beskrivelse Medlemmer i dette teamet jobber med å utvikle applikasjoner og har tilgang til samtlige repositories.\nKonfigurasjon Konfigurasjonen av dette teamet kan justeres av owners etter behov, avhengig av hvor mye frihet man ønsker at apputvikleren skal ha. Merk at det blant annet er mulig å spesifisere hvilke(t) repository teamet skal ha tilgang til.\nStandard konfigurasjon for teamet inkluderer rettigheter til å\nOpprette nye repositories Skrive til samtlige repositories Aksessere alle områder i Gitea Datamodels Beskrivelse Medlemmer i dette teamet kan redigere datamodeller som ligger i \u0026lt;org\u0026gt;-datamodels repoet.\nKonfigurasjon Dette teamet er satt opp som standard på hver organisasjons datamodell-repo. Standard konfigurasjon for teamet inkluderer rettigheter til å\nOpprette nye filer i organisasjonens datamodell-repo Endre/slette filer i organisasjonens datamodell-repo Tilgangsstyring for repository En administrator for organisasjonen kan også styre hvem som har tilgang til det enkelte repository. Det gjøres ved at man går til repositoryet i Gitea, og går til fanen Collaboration under Innstillinger. Tilgang kan gis både til team og enkeltbrukere. For å holde oversikt anbefaler vi primært å sette opp team for tilgangsstyring. For å gi et team tilgang, søk det fram og klikk Add Team.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/access-management/",
	"title": "Tilganger",
	"tags": [],
	"description": "Hvordan man får tilganger til Altinn Studio, hemmeligheter og applikasjonslogger.",
	"content": "\rApps infrastruktur tilganger\rHvordan bestille tilganger til Altinn Apps infrastruktur.\nAltinn Studio tilganger\rHvordan konfigurere tilganger for team i Altinn Studio.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/validation/",
	"title": "Validering",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Validering API-endepunktene for instanser og dataelementer.",
	"content": "Overview There are multiple endpoints that can trigger validation and provide feedback regarding the state of an instance and its data. Some of them validates data already uploaded and stored in Altinn while others can validate input.\nValidate stored instance This action will validate an entire instance including the all data elements already uploaded and stored in Altinn. Validation will be performed based on current task in the process. Validation will ensure that all required data elements, as defined by the application metadata, have been uploaded and are valid. If the result of the validation is that nothing is missing or wrong, the action will update the instance with information indicating that the instance is valid. The response will be an empty array. In the case of validation issues the response will provide an array of the identified issues. Validation of a full instance use validation of data as described in the chapter below.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;INSTANCE\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;TooManyDataElementsOfType\u0026#34; } ] Validate stored data This action will validate a specific data element already uploaded and stored in Altinn. The logic validates that the data element has the correct Content-Type, that it isn\u0026rsquo;t too large and so on. Data elements with a model bound to them will be validated against the model (Schema).\nValidation will also check that the data element being validated is required for the current task in the process. If the data is validated during a task different from what is intended, the validator will give a warning.\nGET https://{org}.apps.at21.altinn.cloud/{org}/{app}/instances/{instanceOwnerPartyId}/{instanceId}/data/{dataid}/validate Example response:\n[ { \u0026#34;severity\u0026#34;: \u0026#34;Error\u0026#34;, \u0026#34;scope\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;targetId\u0026#34;: null, \u0026#34;field\u0026#34;: null, \u0026#34;code\u0026#34;: \u0026#34;MissingContentType\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;MissingContentType\u0026#34; } ] Validate data The application will provide a method to validate the datamodel without creating a instance of the data. Data must be provided as formdata. The validate method takes a data file of an dataType and performs validation on that file. It returns a validation report.\nPUT {appPath}/validate?dataType=modelA "
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/local-dev/",
	"title": "Lokal utvikling",
	"tags": [],
	"description": "Hvordan komme i gang med lokal utvikling",
	"content": "Under utvikling av en applikasjon vil man måtte jobbe både i Altinn Studio og i et lokalt utviklingsmiljø. Her er en oversikt over hvordan du kommer i gang med lokal utvikling.\nForberedelser Følg stegene beskrevet på GitHub for å klargjøre ditt lokale utviklingsmiljø for utvikling og testing av Altinn apps\nHvordan klone applikasjonen til et lokalt utviklingsmiljø Finn applikasjonen du vil jobbe med lokalt i Dashboardet i Altinn Studio\nNavigér til repositoriet ved å trykke på Repository-knappen Kopiér lenken til repoet (den blå firkanten), enten manuelt eller ved å trykke på knappen markert med en rød sirkel. Åpne en terminal i ditt lokale utviklingsmiljø\nNaviger til ønsket lokasjon for applikasjonsrepoet Skriv kommandoen git clone og lim inn URLen du kopierte i forrige steg $git clone https://altinn.studio/repos/ORG/APP.git I terminalen skal du se en output som likner dette Cloning into \u0026#39;APP\u0026#39;... remote: Enumerating objects: 982, done. remote: Counting objects: 100% (982/982), done. remote: Compressing objects: 100% (950/950), done. remote: Total 982 (delta 600), reused 0 (delta 0), pack-reused 0 Receiving objects: 100% (982/982), 166.38 KiB | 1.51 MiB/s, done. Resolving deltas: 100% (600/600), done. Du vil nå se at det er opprettet en mappe der innholdet i applikasjonsrepoet nå er klonet inn. Nå er det bare å åpne ditt foretrukne utviklingsverktøy og komme i gang med utviklingen.\nHvordan synkronisere endringer i Altinn Studio Laste opp endringer til master Trykk på Push på Lage-siden til applikasjonen i Altinn Studio Legg inn en beskrivende tekst for endringen(e) og trykk Valider endringer Vent på at endringene valideres Oppstår det en konklikt trykker du på Løs konflikt og følger instruksjonene Trykk push for å laste opp endringene til master Har alt gått bra vil du se denne bekreftelsen. Laste ned endringer fra master Trykk på Pull på Lage-siden til applikasjonen i Altinn Studio Har alt gått bra vil du se denne bekreftelsen. Hvordan synkronisere endringer i lokalt utviklingsmiljø Sykronisering av endringer gjort i det lokale utviklingsmiljøet kan gjøres på flere måter. Mange utviklingsverktøy har gode integrasjoner for nettopp dette, sjekk gjerne om ditt verktøy har den typen støtte.\nNedenfor er det beskrevet hvordan man kan synkronisere endringer fra kommandolinjen.\nLaste opp endringer til master Navigér til applikasjonsrepoet ditt i en terminal.\nLegg til filene du ønsker å pushe til master med kommandoen git add {sti til filen} Kommandoen kan kjøres for enkelt filer, flere filer samtidig eller en mappe\nCommit endringene med en fornuftlig melding med kommandoen git commit -m {commit-melding}\nPush endringene til master med kommandoen git push\nLaste ned endringer fra master Navigér til applikasjonsrepoet ditt i en terminal og kjør kommandoen git pull.\nLes mer om git pull her\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/code/",
	"title": "Code",
	"tags": [],
	"description": "Slik navigerer du i Altinn Studio Code.",
	"content": "Selv om vi har støtte for å redigere kode og konfigurasjonsfiler direkte i Altinn Studio Repos, er det ofte mer behagelig å gjøre det lokalt på din maskin.\nFor å gjøre dette må du laste ned og installere et koderedigeringsverktøy.\nVi anbefaler Visual Studio Code, men det er fritt fram hvilket verktøy du velger.\nFinne adressen til et repo URL-en til et gitt app repository er strukturert slik, så bytt ut owner og repo-navn:\nhttps://altinn.studio/repos/owner/repo.git.\nDu kan finne URL-en ved å navigere til repositoryet. Klikk ikonet til høyre for å kopiere.\nDu kan også finne samme URL i en popup i Designer hvis du klikker på \u0026ldquo;Clone\u0026rdquo;-knappen.\nKlone koden Etter at du har åpnet Visual Studio Code, åpne den integrerte terminalen (ctrl + ø) og skriv klone-kommandoen. Husk å få med riktig organisasjon og repo-navn.\ngit clone https://altinn.studio/repos/owner/repo Om du ikke er kjent med Visual Studio Code eller Git arbeidsflyt, er det god dokumentasjon her:\nhttps://code.visualstudio.com/docs/getstarted/introvideos https://code.visualstudio.com/docs/editor/versioncontrol#_git-support\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/custom/",
	"title": "Preutfylling av data med egendefinert kode",
	"tags": [],
	"description": "Hvordan kode egendefinert preutfylling i applikasjonen.",
	"content": "Altinn-apper muliggjør forhåndsutfylling av en instans med egne data, enten det er resultatet av et API-kall, beregninger gjort under instansiering eller annen logikk.\nv4, v5, v6\rAltinn apps muliggjør prefill av en instans med egendefinert data, det være seg resultet fra et API-kall, beregninger gjort under instansiering, eller annen logikk. Dette implementeres i metoden DataCreation i filen InstansiationHandler.cs som finnes i applikasjonsrepoet under App/logic.\nEksempelet nedenfor populerer feltet Bruker.FulltNavn i modellen Datamodell med verdien \u0026ldquo;Test Testesen\u0026rdquo;.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; model.Bruker.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } Bytt ut Datamodell med navnet på C# klassen som er blitt generert basert på xsd-en som ble lastet opp i Altinn Studio. Dersom du bruker en egnet kodeeditor vil du kunne definere felter som skal populeres ved bruk av intellisense.\nVær oppmerksom på at dersom du har komplekse typer i modellen din, må disse instansieres før man kan tilegne en verdi til ett av typens underelementer. Se eksempel nedenfor der vi legger til grunn at \u0026lsquo;Bruker\u0026rsquo; og \u0026lsquo;Name\u0026rsquo; er egne C# klasser.\npublic async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Datamodell)) { Datamodell model = (Datamodell)data; Bruker b = new Bruker(); b.Navn = new Name(); b.Navn.FulltNavn = \u0026#34;Test Testesen\u0026#34;; } } v7\rI versjon 7 har vi endret måten preutfylling med egendefinert kode gjøres på. Vi benytter nå dependency injection i stedet for overstyring av metoder. Hvis du tidligere plasserte koden din i DataCreation metoden in InstantiationHandler.cs klassen så vil du erfare at det er mer eller mindre det samme som nå gjøres.\nOpprett en klasse som implementerer IInstantiationProcessor grensesnittet som ligger i Altinn.App.Core.Features navnerommet.\nDu kan navngi og plassere filene i den mappestrukturen du selv ønsker i prosjektet ditt. Men vi anbefaler at du benytter meningsfulle navnerom som i et hvilket som helst annet .Net prosjekt. Eksempelet nedenfor populerer feltet Bruker.FulltNavn i modellen Datamodell med verdien \u0026ldquo;Test Testesen\u0026rdquo;. using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.App.Models; using Altinn.Platform.Storage.Interface.Models; public class Instantiation: IInstantiationProcessor { public async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { if (data.GetType() == typeof(Datamodell)) { Datamodell skjema = (Datamodell)data; Bruker b = new Bruker(); b.Navn = new Name(); b.FulltNavn = \u0026#34;Test Testesen\u0026#34;; skjema.Bruker = b; } await Task.CompletedTask; } } Registrer din implementering i Program.cs klassen services.AddTransient\u0026lt;IInstantiationProcessor, Instantiation\u0026gt;(); Dette sørger for at din kode er kjent for applikasjonen og at koden blir kjørt når den skal. "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/options/",
	"title": "Kodelister (options)",
	"tags": [],
	"description": "Hvordan konfigurere options/kodelister for en app.",
	"content": "Altinn tilbyr i dag to ulike måter en app kan eksponere kodelister - statisk og dynamisk. Dette gjøres gjennom et options-api som er eksponert av appen, og kodelisten vil være tilgjengelig på endepunktet {org}/{app}/api/options/{optionsId}. Checkbox, Dropdown og RadioButton komponenter vil automatisk kunne hente ut en slik liste om man kobler denne komponenten til en slik options-id.\nStatisk kodeliste fra app-repo Ved å legge json-lister i options mappen i app repo vil appen automatisk lese denne filen og eksponere det gjennom options-apiet. Options filene må ligge under App/options/ og vil bli differensiert ved hjelp av navngivningen på json-filen. F.eks land.json. Her vil da optionsId være land, og vil være eksponert gjennom endepunktet {org}/{app}/api/options/land. Kodelistene må være på et spesifikt format. Eksempel på en kodeliste som inneholder land (App/options/land.json):\n[ { \u0026#34;value\u0026#34;: \u0026#34;norway\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Norge\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;denmark\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;Danmark\u0026#34; }, { \u0026#34;value\u0026#34;: \u0026#34;sweden\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;country.label.sweden\u0026#34; } ] label feltet kan inneholde en tekstnøkkel til teskstressursene eller ren tekst.\nDynamisk kodeliste generert runtime I app-templaten har man også mulighet til å ha dynamisk kodelister som bestemmes under kjøringen av appen. Dette muligjør det å eksponere dynamiske verdier som kan filtreres eller hentes fra andre kilder. Dynamiske kodelister kan enten være åpne, dvs. alle brukere når de, eller de kan være sikret gjennom at du må ha tilgang til instansen for å se de.\nI versjoner eldre enn 4.24.0 ble dette gjort ved å legge til kode i metoden GetOptions i App.cs. Denne metoden er nå erstattet ved at man legger til egne klasser for hver kodeliste som implementerer et interface og at man registrerer denne i applikasjonen sin \u0026lsquo;dependency injection cointainer\u0026rsquo;. Dette gir bedre skille mellom de ulike kodelistene, muliggjør å sende avhengigheter inn i konstruktøren til klassen, sende inn språk og andre parametere og generelt håndtere alle aspekter av implementeringen slik du selv ønsker det.\nFor kodelister som er åpne implementerer man IAppOptionsProvider interfacet, mens for kodelister som skal være sikret implementerer man IInstanceAppOptionsProvider. Fremgangsmåten er den samme for begge to og modellen som returneres er lik. Men implementeringen holdes adskilt for ikke å eksponere verdier som skulle vært sikret.\nÅpne dynamiske kodelister Under finner du et eksempel på hvordan dette kan settes opp for en åpen kodeliste. Her vil man få ut den oppsatte kodelisten i det appen får et kall mot {org}/{app}/api/options/countries.\nusing Altinn.App.Common.Models; using Altinn.App.PlatformServices.Options; using System.Collections.Generic; using System.Threading.Tasks; namespace Altinn.App.Core { public class CountryAppOptionsProvider : IAppOptionsProvider { public string Id { get; set; } = \u0026#34;countries\u0026#34;; public Task\u0026lt;AppOptions\u0026gt; GetAppOptionsAsync(string language, Dictionary\u0026lt;string, string\u0026gt; keyValuePairs) { var options = new AppOptions { Options = new List\u0026lt;AppOption\u0026gt; { new AppOption { Label = \u0026#34;Norway\u0026#34;, Value = \u0026#34;47\u0026#34; }, new AppOption { Label = \u0026#34;Sweden\u0026#34;, Value = \u0026#34;46\u0026#34; } } }; return Task.FromResult(options); } } } For at denne implementasjonen skal plukkes opp av applikasjonen må den registreres i Startup.cs (eller Program.cs i .NET 6):\nservices.AddTransient\u0026lt;IAppOptionsProvider, CountryAppOptionsProvider\u0026gt;(); Legg merke til at du kan ha mange implementasjoner av dette interfacet. Den rette implementasjonen finnes gjennom å se på hvilken kodeliste id det spørres etter.\nInterfacene har en egenskap Id, som skal settes til til den id\u0026rsquo;en man skal spørre etter, og en metode GetAppOptionsAsync som returnerer selve kodelisten. Denne metoden tar i mot språk og en liste med key/value par som typisk er query parametre som plukkes opp av kontrolleren og sendes inn. Selv om språk kunne vært et key/value par og sånn sett hvert i listen, så er denne lagt utenfor for å være eksplisitt på språk.\nSpråkkoder bør baseres på ISO 639-1 standarden eller W3C IANA Language Subtag Registry standarden. Sistnevnte bygger på ISO 639-1 standarden men garanterer at alle kodene er unike, noe ISO 639-1 ikke gjør.\nSikrede dynamiske kodelister MERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.27.0 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\rOm du ønsker å eksponere kodelister som inneholder sensitive data som man ikke ønsker skal være tilgjengelige i et åpent API kan man benytte IInstanceAppOptionsProvider. Disse kodelistene validerer at brukeren har lesetilgang definert i applikasjonens policy.xaml-fil. Under finner du et eksempel på man setter opp en sikret kodeliste. Interfacet IInstanceAppOptionsProvider må implementeres og en secure boolean må legges på komponenten. Her vil man få ut den oppsatte kodelisten i det appen får et kall mot /{org}/{app}/instances/{instanceOwnerId}/{instanceGUID}/options/children.\nusing System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Common.Models; using Altinn.App.PlatformServices.Models; namespace Altinn.App.Core { public class ChildrenAppOptionsProvider : IInstanceAppOptionsProvider { public string Id { get; set; } = \u0026#34;children\u0026#34;; public Task\u0026lt;AppOptions\u0026gt; GetInstanceAppOptionsAsync(InstanceIdentifier instanceIdentifier, string language, Dictionary\u0026lt;string, string\u0026gt; keyValuePairs) { // ... // Some custom code to get the list of children from the instance owner // ... var options = new AppOptions { Options = new List\u0026lt;AppOption\u0026gt; { new AppOption { Label = \u0026#34;Ole\u0026#34;, Value = \u0026#34;1\u0026#34; }, new AppOption { Label = \u0026#34;Dole\u0026#34;, Value = \u0026#34;2\u0026#34; }, new AppOption { Label = \u0026#34;Doffen\u0026#34;, Value = \u0026#34;3\u0026#34; } } }; return Task.FromResult(options); } } } For at denne implementasjonen skal plukkes opp av applikasjonen må den registreres i Startup.cs (eller Program.cs i .NET 6):\nservices.AddTransient\u0026lt;IInstanceAppOptionsProvider, ChildrenAppOptionsProvider\u0026gt;(); Legg merke til at du kan ha mange implementasjoner av dette interfacet. Den rette implementasjonen finnes gjennom å se på hvilken kodeliste id det spørres etter.\nInterfacene har en egenskap Id, som skal settes til til den id\u0026rsquo;en man skal spørre etter, og en metode GetAppOptionsAsync som returnerer selve kodelisten. Denne metoden tar i mot språk og en liste med key/value par som typisk er query parametre som plukkes opp av kontrolleren og sendes inn. Selv om språk kunne vært et key/value par og sånn sett hvert i listen, så er denne lagt utenfor for å være eksplisitt på språk.\nSiste konfigurasjon som trengs er å legge til secure-boolean på den aktuelle komponenten. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;dropdown-component\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Some title\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Some description\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;some.field\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;children\u0026#34;, \u0026#34;secure\u0026#34;: true } Koble en komponent til kodeliste Dette gjøres ved å legge til feltet optionsId som referer til hvilken option (kodeliste) man ønsker refere til. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;8e6f7b2f-fcf0-438d-8336-c1a8e1e03f44\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;componentType\u0026#34;: 4, \u0026#34;textResourceBindings\u0026#34;: {}, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;optionsId\u0026#34;: \u0026#34;biler\u0026#34;, } Sende med query parametere ved henting av options Options støtter query parameters når det gjøres api kall. language er satt opp automatisk, men man kan også legge til egendefinerte parametere ved å sette opp mapping på den aktuelle komponenten.\n{ \u0026#34;id\u0026#34;: \u0026#34;c66d7b69-2e18-4786-af44-1fa913853618\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;NyGarantiLoyvetype\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;soknad.nyGaranti.loyvetype\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;loyvetyper\u0026#34;, \u0026#34;mapping\u0026#34;: { \u0026#34;soknad.transportorOrgnummer\u0026#34;: \u0026#34;orgnummer\u0026#34; } }, I eksempelet over vil det bli satt på et query parameter orgnummer={nr}, hvor {nr} er verdien på feltet soknad.transportorOrgnummer. Om man setter opp en kobling til et datafelt og dette feltet endrer seg så vil app-frontend hente options på nytt. På denne måten kan man dynamisk styre hvilke valg som vises basert på informasjon gitt av sluttbruker.\nÅ sende med query parametere fra repeterende grupper er også støttet ved å legge ved en indeks-indikator for de relevante gruppene. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;dropdown-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Select city\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Group.City\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;cities\u0026#34;, \u0026#34;mapping\u0026#34;: { \u0026#34;Group[{0}].Country\u0026#34;: \u0026#34;country\u0026#34; } }, For nøsta repeterende grupper vil man følge det samme mønsteret, men med en ekstra indikator for den nøsta gruppa:\n{ \u0026#34;id\u0026#34;: \u0026#34;dropdown-nested-group\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Select city\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Group.SubGroup.City\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;optionsId\u0026#34;: \u0026#34;cities\u0026#34;, \u0026#34;mapping\u0026#34;: { \u0026#34;Group[{0}].SubGroup[{1}].Country\u0026#34;: \u0026#34;country\u0026#34; } }, For et komplett eksempel kan du se vår demo app.\nUnder PDF-generering vil appen prøve å kalle det samme options-endepunktet som app-frontend gjør. Vi har foreløpig en svakhet ved at eventuelle mapping-parametere ikke blir inkludert i denne forespørselen, se issue #7903.\nEn mulig workaround her er å returnere en tom array i det PDF-generatoren spør om options med tomme query-parametere, eksempel:\nstring someArg = keyValuePairs.GetValueOrDefault(\u0026#34;someArg\u0026#34;); string someOtherArg = keyValuePairs.GetValueOrDefault(\u0026#34;someOtherArg\u0026#34;); if (string.IsNullOrEmpty(someArg) || string.IsNullOrEmpty(someOtherArg)) { return await Task.FromResult(new List\u0026lt;AppOption\u0026gt;()); } Merk at dette vil resultere i at PDF vil vise verdien valgt og ikke label som sluttbrukers svar.\nOptions basert på repeterende grupper i datamodellen Tradisjonelle options baserer seg på ressurser hentet fra backend. Denne måten å gjøre ting på endrer seg litt på dette, da det muliggjør å sette opp en direkte kobling fra komponent til skjemadata som ligger lagret i app frontend. Et typisk bruksområde for dette er om brukeren fyller ut en liste med data som man senere i skjema ønsker å kunne velge mellom i en nedtrekksliste eller liknende.\nKonfigurasjon For å sette opp options fra datamodellen har vi laget en nytt objekt som kan brukes på komponentene RadioButtons, Checkboxes og Dropdown som vi har kalt source. Dette nye objektet inneholder feltene group, label og value. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;dropdown-component-id\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Dropdown\u0026#34;, ... \u0026#34;source\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;some.group\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;dropdown.label\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;some.group[{0}].someField\u0026#34; } }, Forklaring:\ngroup - gruppen i datamodellen man baserer options på. label - en referanse til en text id som brukes som label for hver iterasjon av gruppen. Se mer under. value - en referanse til det feltet i gruppen som skal bruke som option verdi. Legg merke til [{0}] syntaxen. Her vil {0} bli erstattet med den aktuelle indeksen for hvert element i gruppen. Merk at value feltet må være unikt for hvert element. Om man ikke har et felt som er unik anbefales det å legge på et ekstra felt i datamodellen som kan benyttes som identifikator f.eks en GUID eller liknende.\nFor label feltet må vi definere en tekst ressurs som kan bli brukt som label for hver repetisjon av gruppen. Dette følger samme syntax som value, og vil være kjent for deg om du har brukt variabler i tekst.\nEksempel:\n{ \u0026#34;language\u0026#34;: \u0026#34;nb\u0026#34;, \u0026#34;resources\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;dropdown.label\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Person: {0}, Age: {1}\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;some.group[{0}].name\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; }, { \u0026#34;key\u0026#34;: \u0026#34;some.group[{0}].age\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.default\u0026#34; } ] } ] } I dette eksempelet har vi satt opp to parametere i teksten som refererer til felter i gruppen. Vi kjenner også igjen [{0}] syntaksen i key feltet som muliggjør gjenbruk av labelen for hver index i gruppen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/secrets/",
	"title": "Secrets",
	"tags": ["translate-to-english"],
	"description": "How to deal with secrets and sensitive data in an app.",
	"content": "Administrasjon av hemmeligheter i Azure Som applikasjonsutvikler administrerer man selv hemmelighetene som applikasjonen benytter i Azure Key Vault.\nRutiner for bestilling av tilgang til din organisasjons ressurser er beskrevet her.\nKonfigurer støtte for hemmeligheter i din app For å tilgjengeliggjøre hemmeligheter i applikasjonen må det gjøres oppdateringer i helm charten tilknyttet applikasjonen.\nI applikasjonsrepoet ditt finner du filen values.yaml i mappen deployment.\nUnder seksjonen volumeMounts legger du til følgende linjer:\n- name: altinn-appsettings-secret mountPath: \u0026#34;/altinn-appsettings-secret\u0026#34; Under seksjonen volumes legger du til følgende linjer:\n- name: altinn-appsettings-secret secret: secretName: altinn-appsettings-secret Vær påpasselig med innrykk når du jobber i values.yaml. I yaml skal indents være mellomrom og ikke tab, benytter du tab vil ikke din yaml være gyldig.\rSiste del av filen skal se omtrent slik ut når du har gjort ferdig alle endringer.\nHvordan benytte hemmeligheter i applikasjonen Servicen ISecret er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å hente ut en hemmelighet.\nLokal mock For å kunne kjøre tjenesten din lokalt uten å koble seg til Azure Key vault må man opprette filen secrets.json under mappen App. I Json strukturen kan man legge inn dummydata for hemmelighetene man har behov for. Har man lastet opp en hemmelighet i Key Vault med navnet \u0026ldquo;secretId\u0026rdquo; vil innholdet i json-filen se slik ut\n{ \u0026#34;secretId\u0026#34;: \u0026#34;local cecret dummy data\u0026#34; } Type hemmeligheter Secret - lagres som en streng direkte i keyvault. F.eks et sertifikat som er base64 encoded eller et token. Key - Nøkkel Certificate - et sertifikat\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man benytter en hemmelighet til å populere et skjemafelt under instansiering.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Models; using Altinn.App.Services.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private ISecrets _secretsService; /// \u0026lt;summary\u0026gt; /// Set up access to profile and register services /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;profileService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;registerService\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; public InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; } /// \u0026lt;summary\u0026gt; /// Run events related to instantiation /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// For example custom prefill. /// \u0026lt;/remarks\u0026gt; /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt; public async Task DataCreation(Instance instance, object data) { if (data.GetType() == typeof(Skjema)) { Skjema model = (Skjema)data; model.etatid = await _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;); } await Task.CompletedTask; } } } Den private variabelen for servicen inkluderes i klassen\nprivate ISecrets _secretsService; ISecrets servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, ISecrets secretsService) { _profileService = profileService; _registerService = registerService; _secretsService = secretsService; } I metoden der man har behov for hemmeligheten kaller man på servicen. secretId vil være navnet på hemmeligheten i KeyVault evt. i lokal mock.\nawait _secretsService_.GetSecretAsync(\u0026#34;secretId\u0026#34;); Dersom du prøver å bygge løsningen nå vil det feile.\nISecrets vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, ISecrets secretsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, secretsService); } "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/eformidling/",
	"title": "eFormidling",
	"tags": [],
	"description": "Hvordan konfigurere eFormidling integrasjon for en app.",
	"content": "Aktivere integrasjon med eFormidling i applikasjonen din For at applikasjonen din skal kunne sende instansdata videre til eFormidling må den referere til nugetversjon \u0026gt;= 4.22.0. Se hvordan du oppdaterer nugetreferanser for applikasjonen din her.\rI versjon 7 ble det innført en endring for å sikre at applikasjonen kjenner den endelige leveransestatsus for meldinger sent gjennom integrasjonspunktet til eFormidling og i tilfelle feilende leveranser vil disse logges eksplisitt. Denne endringer introduserer behovet for hendelsestøtte i applikasjonen.\rDersom man har behov for integrasjon med eFormidling i applikasjonen må dette aktiveres.\nI filen appsettings.json i mappen App må følgende legges til i seksjonen AppSettings\n\u0026#34;EnableEFormidling\u0026#34;: true I tillegg må det i samme fil opprettes en ny seksjon; EFormidlingClientSettings. Innholdet i kodesnutten nedenfor kan kopieres i sin helhet. Denne setter opp url til integrasjonspunktet. Lenken peker på mocken som kan kjøres opp lokalt. Les mer om oppsettet av eFormidlings mocken her.\nNår en app deployes til TT02 eller produksjon vil denne verdien overskrives og peke mot integrasjonspunktet i Altinn Platform.\n\u0026#34;EFormidlingClientSettings\u0026#34;: { \u0026#34;BaseUrl\u0026#34;: \u0026#34;http://localhost:9093/api/\u0026#34; } Dersom det ikke er ønskelig å teste integrasjonen med eFormidling når man kjører applikasjonen lokalt kan man overstyre denne konfigurasjonen i appsettings.Development.json.\nOpprett AppSettings seksjonen dersom den ikke finnes og sett EnableEFormidling til false.\n\u0026#34;AppSettings\u0026#34;: { \u0026#34;EnableEFormidling\u0026#34;: false } v4, v5, v6\rLegge til støtte for eFormidling i App.cs Neste steg for å få støtte for eFormidling i tjenesten din er å tilgjengeliggjøre services som appen behøver. Endringene skal alle gjøres i filen App.cs som ligger i mappen _App/logic.\nØverst i filen, blant bibliotekreferansene legges disse tre linjene til.\nusing Altinn.Common.EFormidlingClient.Models; using Altinn.Common.EFormidlingClient; using Altinn.Common.AccessTokenClient.Services; Videre skal vi injecte services i konstruktøren til både klassen og base klassen.\nKonstruktøren vil se ut som eksempelet nedenfor, men hvilke services som sendes med kan variere fra tjeneste til tjeneste, så her er kun et eksempel på det vanligste oppsettet.\npublic App( IAppResources appResourcesService, (...) IHttpContextAccessor httpContextAccessor):base( appResourcesService, (...) httpContextAccessor) Listen med services i konstruktøren skal utvides med de fire servicene vist nedenfor.\nIEFormidlingClient eformidlingClient, IOptions\u0026lt;AppSettings\u0026gt; appsettings, IAccessTokenGenerator tokenGenerator, IOptions\u0026lt;PlatformSettings\u0026gt; platformSettings Videre skal disse servicene sendes med videre til baseklassen, da er det kun navnene som sendes med og ikke typene.\neformidlingClient, appsettings, platformSettings, tokenGenerator Endelig resultat skal se slik ut:\npublic App( IAppResources appResourcesService, (...) IHttpContextAccessor httpContextAccessor, IEFormidlingClient eformidlingClient, IOptions\u0026lt;AppSettings\u0026gt; appsettings, IAccessTokenGenerator tokenGenerator, IOptions\u0026lt;PlatformSettings\u0026gt; platformSettings):base( appResourcesService, (...) httpContextAccessor, eformidlingClient, appsettings, platformSettings, tokenGenerator) v7\reFormidlingsintegrasjonen er en del av Altinn.App.Core nuget pakken, men er ikke aktivert som standard. For å aktivere støtte for eFormidling in applikasjonen må du registrere tjenestene ved å legge til følgende i Program.cs:\nservices.AddEFormidlingServices\u0026lt;EFormidlingMetadata, EFormidlingReceivers\u0026gt;(config); Konfigurere nøkkelverdier for eFormidling i applikasjonen din Det kreves en del metadata om eFormidlingsforsendelsen og denne defineres i applicationmetadata.json_. Filen finner du i repoet under mappen App/config.\nOpprett seksjonen eFormidling og fyll ut verdier for følgende parametre.\nId Beskrivelse serviceId Id som spesifiserer type forsendelse DPO, DPV, DPI eller DPF* dpfShipmentType Forsendelsestype som benyttes til routing på mottakersiden process Id som settes på scopet i StandardBusinessDocumentHeader** dataTypes Liste av data typer som automatisk skal legges ved forsendelsen sendAfterTaskId Id på tasken som skal avsluttes før forsendelsen sendes. Det er anbefalt at dette er et confirmation steg receiver Organisasjonsnummer til mottaker. Støtter kun norske virksomheter. Kan sløyfes og defineres i applogikken standard DocumentIdentification standard type Id på meldingstypen typeVersion Versjon av meldingstypen securityLevel Sikkerhetsnivå som settes på StandardBusinessDocument * per Januar 2022 støttes kun DPF.\n** tilgjengelige prosesser for mottaker er tilgjengelig på https://platform.altinn.no/eformidling/api/capabilities/{mottaker-orgnummer}\nEt eksempel for en konfigurasjon i application metadata:\n\u0026#34;eFormidling\u0026#34;: { \u0026#34;serviceId\u0026#34;: \u0026#34;DPF\u0026#34;, \u0026#34;dpfShipmentType\u0026#34;: \u0026#34;altinn3.skjema\u0026#34;, \u0026#34;process\u0026#34;: \u0026#34;urn:no:difi:profile:arkivmelding:administrasjon:ver1.0\u0026#34;, \u0026#34;dataTypes\u0026#34;: [ \u0026#34;ref-data-as-pdf\u0026#34; ], \u0026#34;sendAfterTaskId\u0026#34;: \u0026#34;Task_2\u0026#34;, \u0026#34;receiver\u0026#34;: \u0026#34;910075918\u0026#34;, \u0026#34;standard\u0026#34;: \u0026#34;urn:no:difi:arkivmelding:xsd::arkivmelding\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;arkivmelding\u0026#34;, \u0026#34;typeVersion\u0026#34;: \u0026#34;2.0\u0026#34;, \u0026#34;securityLevel\u0026#34;: 3 } Generering av metadata til forsendelsen i applikasjonen Apputvikler er selv ansvarlig for å sette opp meldingen til en forsendelse som skal via eFormidling. Les om de ulike meldingstypene tilgjengelig i eFormidling.\nI versjon 4, 5 og 6 ble dette gjort ved å legge til funksjonen nedenfor i App.cs. Mens i versjon gjør man dette ved å legge til en klasse som implementerer IEFormidlingMetadata grensesnittet som har samme metode og signatur. Husk at i versjon 7 må du også registrere implementeringen din i Program.cs.\nForventet output fra denne metoden er en tuppel som inneholder navnet på metadatafilen som første element og en stream med metadataen som andre element.\n/// \u0026lt;inheritdoc /\u0026gt; public override async Task\u0026lt;(string, Stream)\u0026gt; GenerateEFormidlingMetadata(Instance instance) { Altinn.Common.EFormidlingClient.Models.Arkivmelding arkivmelding = new (); // bygg opp arkivmeldingen eller annet metadataobjekt her. MemoryStream stream = new MemoryStream(); XmlSerializer serializer = new XmlSerializer(typeof(Altinn.Common.EFormidlingClient.Models.Arkivmelding)); serializer.Serialize(stream, arkivmelding); stream.Position = 0; StreamContent streamContent = new StreamContent(stream); streamContent.Headers.ContentType = MediaTypeHeaderValue.Parse(\u0026#34;application/xml\u0026#34;); return await Task.FromResult((\u0026#34;arkivmelding.xml\u0026#34;, stream)); } Sette mottaker for forsendelse i applikasjonslogikken Denne funksjonaliteten kan benyttes dersom mottaker av forsendelsen skal avgjøres dynamisk.\nI App.cs kan man overstyre metoden som henter ut mottaker av forsendelsen fra applicationmetadata.json_.\nv4, v5, v6\rDet må tre steg til for å sette mottaker i applikasjonslogikken, og alle endringer gjøres i App.cs.\nØverst i filen må det legges til en referanse til eFormidlings biblioteket. using Altinn.Common.EFormidlingClient.Models.SBD; Legg til denne funksjonen i klassen. Forventet output fra denne metoden er en liste som inneholder minst ett receiver-objekt.\npublic override async Task\u0026lt;List\u0026lt;Receiver\u0026gt;\u0026gt; GetEFormidlingReceivers(Instance instance) { Identifier identifier = new Identifier { Authority = \u0026#34;iso6523-actorid-upis\u0026#34; }; // 0192 prefix for all Norwegian organisations. identifier.Value = \u0026#34;[INSERT ORGANISATION NUMBER HERE WITH PREFIX `0192:`]\u0026#34; ; Receiver receiver = new Receiver { Identifier = identifier }; return new List\u0026lt;Receiver\u0026gt; { receiver }; } Legg til egen logikk for å populere identifier.Value i funksjonen. Merk at det kun er norske organisasjonsnummer som støttes, og at prefiksen 0192: er påkrevd før organisasjonsnummeret.\nv7\rI versjon 7 er GetEformidlingReceivers metoden flyttet til IEFormidlingReceivers grensesnittet. Lag en klasse som implementerer dette grensesnittet og registrer den i Program.cs. Nedefor er et eksempel på rammene for en slik implementering:\npublic async Task\u0026lt;List\u0026lt;Receiver\u0026gt;\u0026gt; GetEFormidlingReceivers(Instance instance) { Identifier identifier = new Identifier { Authority = \u0026#34;iso6523-actorid-upis\u0026#34; }; // 0192 prefix for all Norwegian organisations. identifier.Value = \u0026#34;[INSERT ORGANISATION NUMBER HERE WITH PREFIX `0192:`]\u0026#34; ; Receiver receiver = new Receiver { Identifier = identifier }; return new List\u0026lt;Receiver\u0026gt; { receiver }; } Lokal test av applikasjon med eFormidling Det er mulig å teste eFormidlingsintegrasjonen i applikasjonen lokalt på utviklingsmiljøet ditt. I tillegg til Altinn Localtest og applikasjonen er det to ting som må kjøre:\neFormidling integrasjonspunkt mock av eFormidling Forberedelser Installer siste versjon av Java. Finn nedlastingslenke og beskrivelse av nødvendige steg her\nDet skal nå lastes ned en rekke filer. Finn en egnet plassering for eFormidling lokalt på maskinen din og navigér dit i en terminal.\nKlon repoet som inneholder eFormidling mocken med følgende commando\ngit clone --branch development https://github.com/felleslosninger/efm-mocks.git Last ned integrasjonspunktet herfra. Dette kan plasseres på samme nivå som mappen efm-mocks.\nKjøre eFormidling lokalt Åpne en terminal og navigér til efm-mocks (Command prompt eller bash er anbefalt, PowerShell funker ikke. ) Kjør docker-compose up -d Navigér til mappen der integrasjonspunkt-filen ligger Kjør kommandoen java -Xmx2g -Dspring.profiles.active=mock -jar integrasjonspunkt-2.2.0.jar Dersom du har en nyere versjon av integrasjonspunktet enn 2.2.0 må kommandoen siste ledd i siste linje justeres for dette. Verifiser at eFormidling er satt opp korrekt Dette steget krever node og npm på maskinen din, men er ikke nødvendig for å bruke mocken.\nÅpne en terminal og navigér til efm-mocks/tests/ Kjør npm i Navigér inn i mappen next-move Kjør node NextMove.js dpf Verifiser i en broswer på localhost:8001 at det er nye innslag i tabellen med de sendte meldingene. Les mer om mockløsningen her\nTest av eFormidling integrasjon i testmiljø Det oppfordres til grundig testing av eFormidlingsintegrasjonen i applikasjonene. Det er lagt inn sikringer og retry mekanismer for å få en forsendelse fram til mottaker dersom feil skyldes svakheter i nettverksforbindelse. I tilfellet ugyldige forsendelser, herunder manglende vedlegg eller feil i arkivmelding, vil forsendelsen feile uten eksplisitt varsling til sluttbruker eller tjenesteeier.\rIntegrasjonspunktet eksponerer endepunkter der man kan følge statusen for en forsendelse. https://platform.altinn.no/eformidling/api/conversations?messageId={instanceGuid}\nBytt ut {instanceGuid} med guiden til instansen som er blitt innsendt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/events/",
	"title": "Events",
	"tags": [],
	"description": "Hvordan lage egendefinerte events for en app.",
	"content": "Aktivere generering av events i applikasjonen din For at applikasjonen din skal kunne generere events må den referere til nugetversjon \u0026gt;= 1.2.4. Se hvordan du oppdaterer nugetreferanser for applikasjonen din her.\rGenerering og lagring av events er ikke enablet som default i applikasjonene per 22.10.2020. Det må derfor et manuelt steg til for at applikasjonen din skal generere events.\nI filen appsettings.json i mappen App må følgende legges til i seksjonen AppSettings\n\u0026#34;RegisterEventsWithEventsComponent\u0026#34;: true Pushe egendefinerte events i applikasjonen din Servicen IEvents er eksponert i applikasjonen og kan dependency injectes i den klassen der du har behov for å generere et egendefinert event.\nMetoden AddEvent krever navnet på eventypen og instansen som input.\nKodeeksempel I denne seksjonen finner du et eksempel på hvordan man kan generere et egendefinert event ved instansiering av applikasjonen.\nLogikken er implementert i InstantiationHandler.cs\nusing Altinn.App.Services.Interface; using Altinn.App.PlatformServices.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; using System.Threading.Tasks; // using Altinn.App.Models; // Uncomment this line to refer to app model(s) namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; private IEvents _eventsService; /// \u0026lt;summary\u0026gt; /// Set up access to profile and register services /// \u0026lt;/summary\u0026gt; public InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; } /// \u0026lt;summary\u0026gt; /// Run validations related to instantiation /// \u0026lt;/summary\u0026gt; /// \u0026lt;example\u0026gt; /// if ([some condition]) /// { /// return new ValidationResult(\u0026#34;[error message]\u0026#34;); /// } /// return null; /// \u0026lt;/example\u0026gt; /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;validationResults\u0026#34;\u0026gt;\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;The validation result object (null if no errors) \u0026lt;/returns\u0026gt; public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { return await Task.FromResult((InstantiationValidationResult)null); } /// \u0026lt;summary\u0026gt; /// Run events related to instantiation /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt; /// For example custom prefill. /// \u0026lt;/remarks\u0026gt; /// \u0026lt;param name=\u0026#34;instance\u0026#34;\u0026gt;Instance information\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data object created\u0026lt;/param\u0026gt; public async Task DataCreation(Instance instance, object data) { await _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance); await Task.CompletedTask; } } } Den private variabelen for servicen inkluderes i klassen\nprivate IEvents _eventsService; Namespce for IEvents må inkluderes i klassen. Legg til linjen nedenfor blant de andre using-statements øverst i filen.\nusing Altinn.App.PlatformServices.Interface; IEvents servicen dependency injectes inn i klassen. Og den private variabelen blir assignet en verdi.\npublic InstantiationHandler(IProfile profileService, IRegister registerService, IEvents eventsService) { _profileService = profileService; _registerService = registerService; _eventsService = eventsService; } I metoden der man har behov for å genere et event kaller man på servicen.\nHer har det egendefinerte eventet fått navnet app.test.event, i tillegg sendes instansen med. Denne brukes til å populere resterende metadata om eventet.\nawait _eventsService.AddEvent(\u0026#34;app.test.event\u0026#34;, instance); Dersom du prøver å bygge løsningen nå vil det feile.\nIEvents vil mangle der InstantiationHandler instansieres. Naviger til App.cs og dependency inject servicen inn i konstruktøren til App.\nVidere må tjenesten legges til i kallet der InstantiationHandler instansieres som vist nedenfor.\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IEvents eventsService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService, eventsService); } Applikasjonen din er nå klar til å generere et egendefinert event under instansiering. Dette er mulig å teste lokalt før det evt. deployes til et testmiljø.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/prefill/instantiation/",
	"title": "Preutfylling med http post",
	"tags": [],
	"description": "Hvordan konfigurere prefill for en app ved bruk av http post requests.",
	"content": "Altinn apper støtter instansiering med prefill. Skjemadataen legges ved i en multipart i instansieringsrequesten som sendes til appen. Nedenfor ser du et eksempel på en request for å instansiere en app med prefill for partyId 12345.\nContent-Type: multipart/form-data; boundary=\u0026#34;abcdefg\u0026#34; Body: --abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;PartyId\u0026#34; : \u0026#34;12345\u0026#34; } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;Endring-av-navn\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;1533\u0026#34; spesifikasjonsnummer=\u0026#34;11172\u0026#34; blankettnummer=\u0026#34;RF-1453\u0026#34; tittel=\u0026#34;Endring av navn\u0026#34; gruppeid=\u0026#34;9308\u0026#34;\u0026gt; \u0026lt;Innledning-grp-9309 gruppeid=\u0026#34;9309\u0026#34;\u0026gt; \u0026lt;NavneendringenGjelderFor-grp-9310 gruppeid=\u0026#34;9310\u0026#34;\u0026gt; \u0026lt;SubjektFornavnFolkeregistrert-datadef-34730 orid=\u0026#34;34730\u0026#34;\u0026gt;Ola Nordmann\u0026lt;/SubjektFornavnFolkeregistrert-datadef-34730\u0026gt; \u0026lt;/NavneendringenGjelderFor-grp-9310\u0026gt; \u0026lt;Kontaktinformasjon-grp-9311 gruppeid=\u0026#34;9311\u0026#34;\u0026gt; \u0026lt;MelderFultnavn orid=\u0026#34;34735\u0026#34;\u0026gt;LANGØY MADS\u0026lt;/MelderFultnavn\u0026gt; \u0026lt;/Kontaktinformasjon-grp-9311\u0026gt; \u0026lt;/Innledning-grp-9309\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/data/attachments/",
	"title": "Vedlegg",
	"tags": [],
	"description": "I en applikasjon kan man legge til rette for opplasting av filvedlegg både via GUI og API.",
	"content": "Metoder for opplasting av vedlegg I en Altinn app har man to alternativer for opplasting av vedlegg:\nvedleggskomponent i skjema API-kall mot app backend Førstnevnte vil være et godt alternativ for all data der det er forventet at en sluttbruker vil laste opp via brukergrensesnitt i skjema. Sistnevnte anbefales brukt dersom det kun er forventet at systemer skal laste opp vedlegget. Det er ingen begrensning på hvor mange vedlegg som kan inkluderes i en applikasjon og begge opplastingsmetoder kan brukes innad i samme applikasjon.\nNedenfor følger en enkel beskrivelse av hvordan du kan legge til rette for at applikasjonen din kan ta imot vedlegg.\nInnsending av vedlegg med vedleggskomponent i skjema Når man setter sammen skjemaet sitt i Altinn Studio har man en vedleggskomponent tilgjengelig. Det er mulig å laste opp flere vedlegg på en enkelt komponent, og hvor mange vedleggskomponenter du benytter i din applikasjon vil avgjøres av egenskapene til dokumentene du forventer at skal lastes opp og eventuelle begrensninger du selv ønsker å sette (se konfigurasjon av vedlegg for mer informasjon om dette).\nNB! Det vil også være mulig å laste opp vedlegg av typen definert i vedleggkomponenten via API.\nBildet over viser vedleggskomponenten i Altinn Studio. Det er mulig å sette en del av konfigurasjonenen for vedleggene som lastes opp alledere her.\nEgendefinerte filtyper kan spesifiseres dersom man vil begrense filtypene som kan sendes inn. En bruker vil i så fall hindres under opplastning dersom filtypen ikke er blant den godkjente listen. Minst/maks antall filvedlegg kan spesifiseres dersom man ønsker et bestemt antall vedlegg lastet opp via komponenten. Ved å sette \u0026lsquo;0\u0026rsquo; på minst antall filvedlegg vil det ikke være påkrevd å laste opp en fil. Maks filstørrelse spesifiseres i MB. Ytterligere konfigurasjoner som kan settes for vedlegg inkluderer: tillatte bidragsytere og beskrivelse. Dette gjøres i applicationMetadata.json som ligger under App/config i applikasjonsrepoet.\nVedleggskomponent med merking Det finnes også en egen komponent der man får brukeren til å merke filen med hjelp av en nedtrekksliste. Dette settes opp ganske likt som med den vanlige filopplastingskomponenten, med tillegget av en kodeliste-ID og navnet man vil gi merkingen.\nHer under kan du se den i bruk\nInnsending av vedlegg med API-kall For å legge til rette for å kunne sende inn vedlegg uten å ha støtte for dette i GUI må man legge inn et datatype-objekt i applicationMetadata.json (filen ligger under App/config i applikasjonsrepoet). Det vil da kun være mulig å sende inn vedlegg av denne typen via API-kall. For en nærmere beskrivelse av de tilgjengelige feltene se konfigurasjon av vedlegg.\nKonfigurasjon for vedlegg I applicationMetadata.json (ligger under App/config i applikasjonsrepoet) vil man finne en property som heter dataTypes. Her er ligger konfigurasjonen for alle datatyper knyttet til applikasjonen, både skjemadata (app model data) og vedlegg. Feltet appLogic som man også vil se blant noen av objektene i listen skal kun brukes for skjemadata.\nNedenfor er det to eksempler på dataTypes-instanser i en applikasjon fra en deployet applikasjon.\n\u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;53a50f0d-2345-448d-9fba-f18e6bbe71f8\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;allowedContentTypes\u0026#34;:[\u0026#34;application/pdf\u0026#34;] }, { \u0026#34;id\u0026#34;: \u0026#34;attest\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 0, \u0026#34;allowedContributers\u0026#34;: [\u0026#34;org:nav\u0026#34;, \u0026#34;orgNo:XXXXXXXXXX\u0026#34;], \u0026#34;grouping\u0026#34;: \u0026#34;Attester\u0026#34;, } ] Id på vedleggstypen. Denne vil settes som en GUID dersom man bruker vedleggskomponent fra Altinn Studio slik man ser i det første elementet i dataTypes-listen. Skulle det være ønskelig å endre verdien til et mer fornuftig navn må man også være obs på at denne endringen må gjøres to steder: applicationMetadata.json og FormLayout.json. (Kun relevant dersom man bruker filopplaster i GUI)\ntaskId betegner hvilket steg i prosessen det er forventet at dette vedlegget skal lastes opp på. Denne verdien må tilsvare en id på en av taskene i process.bpmn.\nmaxSize betegner maks tillat størrelse på vedlegget.\nmaxCount betegner en øvre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans.\nminCount betegner en nedre grensen for hvor mange vedlegg av denne typen som skal lastet opp i tilknytning til en instans. Dersom verdien er 0 er det ikke påkrevt å laste opp vedlegg av denne typen.\nallowedContributers spesifiserer hvem som får lov til å lage og/eller endre vedlegg av denne typen. Dette spesifiseres på formatet {nøkkelord}:{verdi}. Tillatte nøkkelord inkluderer: \u0026lsquo;org\u0026rsquo;; trebokstavsforkortelse på organisasjon og \u0026lsquo;orgNo\u0026rsquo;; organisasjonsnummer. Det er per nå ikke mulig å spesifisere en organisasjon som ikke er registrert som tjenesteeier.\nallowedContentTypes spefisiserer hvilke vedleggstyper man tillater. De hyppigst brukte inkluderer: application/pdf, text/xml, image/jpeg. Dersom man ikke ønsker å sette begrensning på typen vedlegg trenger man ikke definere denne parameteren. Les mer om mime types her.\ngrouping betegner gruppen som vedleggene i av denne typen skal grupperes etter. Dette er en valgfri egenskap, hvor vedlegg med samme grouping vil havne i samme liste. Grouping kan både være en streng (f.eks \u0026ldquo;Attester\u0026rdquo;) eller en tekstnøkkel om man ønsker å støtte flere språk (f.eks \u0026ldquo;skjema.vedleggsgruppering). Her er et eksempel hvor grouping \u0026ldquo;Demogruppe\u0026rdquo; satt på en vedleggstype:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/settings/",
	"title": "Settings og miljøvariabler",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon- og miljøspesifikke verdier slik at de er tilgjengelig fra app-koden.",
	"content": "Standard .NET konfigurasjon Altinn 3 sin App template baserer seg på en ASP.Net Core applikasjon og har med dette en rekke muligheter for å styre konfigurasjon av en App. Denne dokumentasjonen er derfor i stor grad utdrag fra eller linker til Microsoft sin egen dokumentasjon. Det er derimot ikke alt som er mulig i en App da det er litt begrenset hva Altinn 3 gir av tilganger til miljøet en App kjører i.\nappsettings.json Første og enkleste kilde til konfigurasjonsinformasjon er appsettings filene. En hver ny app som blir laget vil komme med en eksisterende appsettings.json fil. Denne filen blir lest inn av en App under oppstart uavhengig av hvilke miljø Appen kjører i. Det vil si at den bør inneholde standarinnstillinger og innstillinger som er lik i alle miljøer. Filen har allerede en del innstillinger som er i bruk og verdiene er i stor grad beregnet for et utviklingsmiljø hvor man kjører LocalTest.\nI appsettings.json filene organiseres verdier i ulike seksjoner. Det anbefales å ikke legge til nye verdier i de eksisterende seksjonene, men isteden lage nye seksjoner. Følgende seksjoner er reservert for å unngå kollisjoner: Kestrel, AppSettings, GeneralSettings, PlatformSettings, PEPSettings, ApplicationInsights, kvSettings.\n{ \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn i alle miljøer, men kanskje overstyrt av miljøspesifikke kilder\u0026#34; }, \u0026#34;AppSettings\u0026#34;: { ... }, \u0026#34;GeneralSettings\u0026#34;: { ... }, \u0026#34;PlatformSettings\u0026#34;: { \u0026#34;ApiStorageEndpoint\u0026#34;: \u0026#34;http://localhost:5101/storage/api/v1/\u0026#34;, \u0026#34;ApiRegisterEndpoint\u0026#34;: \u0026#34;http://localhost:5101/register/api/v1/\u0026#34;, ... }, \u0026#34;ApplicationInsights\u0026#34;: { \u0026#34;InstrumentationKey\u0026#34;: \u0026#34;retrieved from environment at runtime\u0026#34; } } I fremtiden vil en ny App få med en egen seksjon som det skal være enkelt å utvide. I mellomtiden refereres det til Microsoft sin dokumentasjon for hvordan dette kan gjøres.\nMiljøspesifikke appsettings En ny app vil også inneholde et set med miljøspesifikke appsettings filer: appsettings.Development.json, appsettings.Staging.json og appsettings.Production.json. Disse filene blir lest inn kun i det aktuelle miljøet. TT02-miljøet er definert som Staging og produksjonsmiljøet er definert som Production.\nHver fil skal altså ha verdier som er unike eller anderledes i minst ett annet miljø. Et eksempel på en type verdi som kan variere fra miljø til miljø er \u0026ldquo;timeout\u0026rdquo; verdier. Hvis man ønsker at en App skal vente lengre på respons fra et eksternt API under utvikling enn det man ønsker å tillate i produksjon.\nappsettings.Development.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for utviklingsmiljø\u0026#34; } } appsettings.Staging.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for TT02\u0026#34; } } appsettings.Production.json { \u0026#34;ExampleSection\u0026#34;: { \u0026#34;ExampleValue\u0026#34;: \u0026#34;Verdi lest inn kun for produksjon\u0026#34; } } Miljøvariabler Standard oppførsel til en ASP.Net applikasjon er å lese inn miljøvariabler. Dette gjøres også for en App, men det er ikke mulig for en Apputvikler å lage eller endre noen verdier per i dag. Altinn 3 mener at denne måten å styre miljøspesifikke verdier på dekkes av appsettings og KeyVault.\nKommandolinjeargumenter Det er teknisk mulig å overstyre alle andre data kilder ved hjelp av kommandolinjeargumenter. Det er derimot ikke mulig å bruke dette til å endre verdier fra et miljø til et annet.\nAzure KeyVault Hver applikasjonseier skal få tilgang til sitt eget Azure KeyVault for lagring av sensitive verdier. Altså verdier man ikke ønsker å ha synlig i kode eller konfigurasjonsfiler. Noen naturlig eksempler på dette er ting som brukernavn og passord for eksterne APIer en App skal benytte. Et sertifikat, privat nøkkel eller lignende.\nPer i dag blir ikke verdier fra KeyVault lest inn i konfigurasjonsstyringen av en App. Isteden må man benytte Secrets komponenten. Dette er dokumentert under hemmeligheter.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/startup/",
	"title": "Konfigurer appens oppførsel under oppstart",
	"tags": [],
	"description": "Hvordan konfigurere applikasjonens oppførsel under oppstart av app-frontend",
	"content": "I applicationmetadata.json har man mulighet til å styre hva applikasjonen viser i det brukeren går mot en direktelenke. Dette gjøres under feltet onEntry.show, hvor man har mulighet til å sette verdiene new-instance (default) eller select-instance. Standard oppførsel om dette feltet ikke er satt er at det lages en ny instans for brukeren som besøker applikasjonen.\nVelge fra aktive instanser MERK: for å benytte denne funksjonaliteten må man ha versjon \u0026gt;= 4.15.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\rOm man setter feltet til onEntry.show til select-instance vil brukeren bli presentert med en liste av aktive instanser for den valgte avgiver når man navigerer seg til en applikasjon.\nEksempel Følgende konfigurasjon legges til i applicationmetadata.json for å sette opp valg av aktive instanser.\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/demo-app\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;Starte fra aktiv instans\u0026#34; }, ... \u0026#34;onEntry\u0026#34;: { \u0026#34;show\u0026#34;: \u0026#34;select-instance\u0026#34; } } For brukere som ikke har noen aktive instanser vil det automatisk bli opprettet en instans. Brukere som har aktive instanser vil bli presentert med følgende brukergrensesnitt:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/stateless/",
	"title": "Stateless applikasjon (innsynstjeneste)",
	"tags": [],
	"description": "Hvordan legge inn konfigurasjon for å styre oppførsel ved applikasjonens oppstart",
	"content": "Introduksjon til stateless applikasjoner En stateless, eller tilstandsløs, applikasjon skiller ser fra standard applikasjoner ved at den ikke lagrer noe data, verken skjemadata eller metadata om instanser av applikasjonen. Derfor passer stateless applikasjoner godt som innsynstjenester der en sluttbruker eller et system gjør et oppslag mot en eller annen ressurs evt. presenterer data fra en tredjepart basert på hvem brukeren er. Det er også mulig å konfigurere en stateless applikasjon til å tillate bruk av anonyme brukere, altså brukere som ikke er pålogget.\nKonfigurasjon Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre.\nMERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.5.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\nI applikasjonsmetadataen er det mulig styre oppførselen en applikasjonen har under oppstart. Om man ønsker at applikasjonen skal oppføre seg som en tilstandsløs applikasjon vil det nå være mulig. For en slik applikasjon vil det ikke bli lagret noe data eller metadata, og applikasjonen vil heller ikke havne i meldingsboksen til sluttbruker. Dette tilsvarer en innsynstjeneste i Altinn 2.\nKonfigurasjonen av dette gjøres i applicationmetadata.json. Eksempel:\n{\r\u0026#34;id\u0026#34;: \u0026#34;ttd/stateless-app-demo\u0026#34;,\r\u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;,\r\u0026#34;title\u0026#34;: {\r\u0026#34;nb\u0026#34;: \u0026#34;Stateless App Demo\u0026#34;\r},\r\u0026#34;dataTypes\u0026#34;: [\r{\r\u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;,\r\u0026#34;allowedContentTypes\u0026#34;: [\r\u0026#34;application/pdf\u0026#34;\r],\r\u0026#34;maxCount\u0026#34;: 0,\r\u0026#34;minCount\u0026#34;: 0\r},\r{\r\u0026#34;id\u0026#34;: \u0026#34;Stateless-model\u0026#34;,\r\u0026#34;allowedContentTypes\u0026#34;: [\r\u0026#34;application/xml\u0026#34;\r],\r\u0026#34;appLogic\u0026#34;: {\r\u0026#34;autoCreate\u0026#34;: true,\r\u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.StatelessV1\u0026#34;\r},\r\u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;,\r\u0026#34;maxCount\u0026#34;: 1,\r\u0026#34;minCount\u0026#34;: 1\r}\r],\r...\r\u0026#34;onEntry\u0026#34;: { \u0026#34;show\u0026#34;: \u0026#34;stateless\u0026#34; } // legg til denne linjen\r} I feltet onEntry.show har man mulighet til nå å referere til et layout-set som man ønsker skal vises under oppstarten av applkasjonen. Les mer om layout-sets her.\nLayout-settet man referer til her blir så benyttet som visningen brukeren blir presentert for i det man navigerer til applikasjonen.\nKonfigurasjonsfilen layout-sets.json kan opprettes dersom den ikke finnes fra før av. Den skal ligge i mappen App/ui. I layout-sets.json legger man så inn det aktuelle settet man referer til fra applicationmetadata.json, eksempel:\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;stateless\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;Stateless-model\u0026#34; } ] } I eksempelet over så referer layout-settet stateless til datamodellen Stateless-model. Eksempel app-struktur på en applikasjon som har satt opp på denne måten:\n├───App ├───config ├───logic ├───models │ Stateless-model.cs │ Stateless-model.metadata.json │ Stateless-model.schema.json │ Stateless-model.xsd ├───ui │ layout-sets.json │ └───stateless | RuleConfiguration.json │ RuleHandler.js │ Settings.json │ └───layouts FormLayout.json FormLayout.json vil så kunne settes opp på samme måte som en vanlig applikasjon, og vil støtte samtlige komponenter som er mulig å sette opp i en vanlig app, med unntak av:\nFilopplaster Knapp App frontend vil så skjønne ut fra konfigurasjonen i applicationmetadata.json at den ikke skal instansiere, og hente ned de aktuelle layout-filene og den tilkoblede datamodellen og presentere dette til sluttbrukeren.\nKonfigurere tilgang uten innlogging OBS! Skjemakomponenter som påvirker prosess (knapp for innsending eller instansiering) er ikke støttet for anonyme brukere!\nMERK: for å benytte denne funksjonaliteten må man bruke versjon \u0026gt;= 5.1.0 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\nFor å tillate bruk av appen for bruker som ikke er innlogget, må man følge stegene som beskrevet over. I tillegg må man definere at den datatypen som er satt opp til å brukes for stateless visningen tillater anonym (ikke innlogget) bruk. Dette gjøres ved å modifisere det aktuelle dataType-elementet i applicationMetadata.json. Datatypen sitt appLogic-objekt må få en ny innstilling, \u0026quot;allowAnonymousOnStateless\u0026quot;: true. Se eksempel under:\n{\r\u0026#34;id\u0026#34;: \u0026#34;ttd/stateless-app-demo\u0026#34;,\r\u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;,\r\u0026#34;title\u0026#34;: {\r\u0026#34;nb\u0026#34;: \u0026#34;Stateless App Demo\u0026#34;\r},\r\u0026#34;dataTypes\u0026#34;: [\r{\r\u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;,\r\u0026#34;allowedContentTypes\u0026#34;: [\r\u0026#34;application/pdf\u0026#34;\r],\r\u0026#34;maxCount\u0026#34;: 0,\r\u0026#34;minCount\u0026#34;: 0\r},\r{\r\u0026#34;id\u0026#34;: \u0026#34;Stateless-model\u0026#34;,\r\u0026#34;allowedContentTypes\u0026#34;: [\r\u0026#34;application/xml\u0026#34;\r],\r\u0026#34;appLogic\u0026#34;: {\r\u0026#34;autoCreate\u0026#34;: true,\r\u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.StatelessV1\u0026#34;,\r\u0026#34;allowAnonymousOnStateless\u0026#34;: true,\r},\r\u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;,\r\u0026#34;maxCount\u0026#34;: 1,\r\u0026#34;minCount\u0026#34;: 1\r}\r],\r...\r\u0026#34;onEntry\u0026#34;: { \u0026#34;show\u0026#34;: \u0026#34;stateless\u0026#34; } } Datapopulering Når man benytter en stateless datatype så vil man kunne populere datamodellen i det app-frontend spør om skjemadataen.\nDatapopuleringen skjer i to steg på det initielle kallet fra frontend (GET):\nPrefill, les mer om dette her. Dataprossesering, les mer om dette her. På påfølgende oppdateringer på samme skjemadata (POST) så vil man ikke kjøre prefill en gang til, men kalkuleringen trigges. Dette muligjør manipulering av dataen basert på brukerens input selv i en stateless tilstand.\nEksempel på en kalkulering som populerer datamodellen nevnt i eksempelet over:\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data) { if (instance.GetType() == typeof(StatelessV1)) { StatelessV1 form = (StatelessV1) data; // Her kan du gjøre det du ønsker, f.eks et API-kall // om tjenesten skal oppføre seg som en innsynstjeneste. form.Fornavn = \u0026#34;Test\u0026#34;; form.Etternavn = \u0026#34;Testesten\u0026#34;; return true } return false; } Autorisasjon med tredjepartsløsninger Tilgangsstyring for stateless applikasjoner kan løses med standard app-autorisasjon der man hved hjelp av Altinn-roller definerer hvem som har tilgang til å benytte tjenesten. Dersom man har behov for ytteligere sikring av tjenesten kan man implementere logikk for autorisasjon av brukere med tredjepartløsninger. Dette kan være API-er som er eksponert innenfor egen virksomhet eller åpne API fra andre tilbydere.\nI eksempelet nedenfor benyttes Finanstilsynets API til å fastslå om virksomheten som repesenteres av en bruker i Altinn har tilstrekkelige lisenser til å benytte tjenesten.\nKildekoden til applikasjonen som eksempelet er basert på finnes her. (Krever bruker i Altinn Studio.)\nVidere i eksempelet vil betegnelsen bruker være synonymt med en virksomhet representert ved en person i Altinn.\nUtvid datamodellen med felter for autorisasjon\nI tillegg til et felt for å ta input fra bruker og et felt for å vise fram resultatet, har vi i dette eksempelet et felt for å holde på infomasjon om hvorvidt brukeren er autentisert og et felt for å holde på en dynamisk feilmelding.\n\u0026lt;xs:sequence\u0026gt; \u0026lt;xs:element name=\u0026#34;searchString\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;result\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;userAuthorized\u0026#34; type=\u0026#34;xs:boolean\u0026#34; /\u0026gt; \u0026lt;xs:element name=\u0026#34;errorMessage\u0026#34; type=\u0026#34;xs:string\u0026#34; /\u0026gt; \u0026lt;/xs:sequence\u0026gt; Hopp til steg 4 dersom applikasjonen kun skal benyttes via API.\nLegg til felt for å vise feilmelding i brukergrensesnittet\nI brukergrensesnittet til applikasjonen er det tre komponenter. Et søkefelt for brukerinput, et tekstfelt dedikert til å vise fram søkeresultatet og en paragraf som er reservert for feilmeldinger.\nKomponentene er koblet til datamodell og tekstressurs på følgende måte i FormLayout.json\n\u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;SearchString\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;searchString\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: false }, { \u0026#34;id\u0026#34;: \u0026#34;resultatBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;TextArea\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Result\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;result\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;errorBoks\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;ErrorMessage\u0026#34; }, \u0026#34;required\u0026#34;: false, \u0026#34;readOnly\u0026#34;: true } ] Legg inn dynamikkregler for å vise/skjule felter\nVi bruker dynamikkregler til å vise/skjule felter avhengig av om en bruker en autorisert eller ikke.\nDet er lagt inn en dynamikkregel i RuleHandler.js som sjekker om et felt i datamodellen har verdien false. Konfigurasjon av regler er beskrevet nærmere her.\nI RuleConfiguration.json ser man hvordan regelen benyttes. Dersom inputverdien fra datamodellen userAuthorized er false, så vises errorBoks-komponenten, mens det motsatte skjer med søke- og resultatfeltene, disse skjules.\nDefault oppførsel vil være det motsatte, altså at søk og resultat er synlig, mens error feltet er skjult.\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c260\u0026#34;: \u0026#34;errorBoks\u0026#34; } }, \u0026#34;e2dd8ff0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;isFalse\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;userAuthorized\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Hide\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c261\u0026#34;: \u0026#34;sokeBoks\u0026#34;, \u0026#34;e2dd68e0-f8f1-11eb-b2bc-5b40a942c262\u0026#34;: \u0026#34;resultatBoks\u0026#34; } } } } } Legg til tekstressurser\nI tillegg til navnet på tjenesten er det lagt inn tre tekstressurser.\nTekstressursen for feilmelding inneholder en placeholder for navnet på brukeren. Variabelen errorMessage vil populeres i datamodellen når det registreres at en bruker ikke er autorisert til å bruke tjenesten.\n{ \u0026#34;id\u0026#34;: \u0026#34;ErrorMessage\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;{0} mangler rettigheter til å bruke denne tjenesten.\u0026#34;, \u0026#34;variables\u0026#34;: [ { \u0026#34;key\u0026#34;: \u0026#34;errorMessage\u0026#34;, \u0026#34;dataSource\u0026#34;: \u0026#34;dataModel.lookup\u0026#34; } ] }, { \u0026#34;id\u0026#34;: \u0026#34;Result\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Resultat\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;SearchString\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Legg inn søkeord her:\u0026#34; }, Implementér autorisasjonslogikk\nAlt av dataprosessering for stateless applikasjoner ligger i filen App\\logic\\DataProcessing\\DataProcessingHandler.cs, og det er her autorisasjonslogikken skal plasseres.\nLogikk for å slå opp data og autorisere brukeren ligger i metoden ProcessDataRead. Denne kalles hver gang en bruker åpner applikasjonen eller sendes inn noe input data.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data)\r{\rlookup lookup = (lookup)data;\r// Check if user is authorized to use service\rParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)); if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber))\r{\rlookup.userAuthorized = false;\rlookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;;\rreturn true;\r} // logic for looking up data\rif (!string.IsNullOrEmpty(lookup.searchString))\r{\rlookup.result = $\u0026#34;You typed \\\u0026#34;{lookup.searchString}\\\u0026#34;. This is the result.\u0026#34;;\rreturn true;\r}\rreturn false;\r} Metoden starter med logikk for å hente ut skjemadataen slik at denne kan benyttes videre i metoden.\nlookup lookup = (lookup)data Videre kommer logikken for å sjekke om brukeren er autorisert.\n// Check if user is authorized to use service Party party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) if (string.IsNullOrEmpty(party.OrgNumber) || !await _finanstilsynet.HasReqiuiredLicence(_settings.LicenseCode, party.OrgNumber)) { lookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; } For å vite hvem brukeren er, benyttes identifikatoren instance.InstanceOwner.PartyId, denne får vi som input til metoden. Vi slår opp i Altinn sitt register for å hente ut party-objektet som representerer brukeren. Dette kan inneholde en organisasjon eller en person.\nParty party = await _register.GetParty(int.Parse(instance.InstanceOwner.PartyId)) Det gjøres to sjekker for å avgjøre om en bruker er autorisert eller ikke. Først verifiseres det at party-objektet har definert et organisasjonsnummer, dersom dette ikke er tilfellet er brukeren en person, og dermed ikke autorisert.\nDen andre sjekken kaller _finanstilsynet.HasReqiuiredLicence(), en metode som slår opp i finanstilsynets API for å avgjøre om en organisasjonen har en gitt lisens. Implementasjonen av servicen er tilgjengelig her.\nDersom ingen av sjekkene er vellykkede populeres to felter i datamodellen;\nen indikator på at brukeren ikke er autorisert en feilmelding, her kun navnet til brukeren og true returneres for å indikere at dataverdier har blitt oppdatert.\nlookup.userAuthorized = false; lookup.errorMessage = $\u0026#34;{party.Name}\u0026#34;; return true; Helt til slutt kommer logikken for å vise fram et resultat basert på søkestrengen.\n// logic for looking up data if (!string.IsNullOrEmpty(lookup.searchString)) { lookup.result = $\u0026#34;You typed \\\u0026#34;{lookup.searchString}\\\u0026#34;. This is the result.\u0026#34;; return true; } return false; lookup.result populeres med verdien av oppslaget, i dette tilfellet skriver vi bare søkestrenger tilbake til bruker. Igjen returneres true for å indikere at en dataverdi er blitt endret, og false dersom dette ikke er tilfellet.\nStarte instans fra et stateless skjema Dette er helt ny funksjonalitet. Oppsett må gjøres manuelt inntil videre og vil ikke være støttet i Altinn Studio.\nMERK: for å benytte denne funksjonaliteten må man versjon \u0026gt;= 4.17.2 av nugetpakkene Altinn.App.PlatformServices, Altinn.App.Common og Altinn.App.Api.\nFra en tilstandsløs applikasjon har man mulighet til å benytte InstantiationButton-komponenten til å starte en instans. Enn så lenge støtter vi kun å starte en instans innad i samme applikasjonen som stateless skjema vises i. Det å starte en instans i en annn applikasjon er funksjonalitet som kommer.\nDet er laget en eksempel applikasjon som er satt opp som en innsynstjeneste hvor sluttbruker kan velge å starte en instans på den aktuelle applikasjonen. Denne kan brukes til inspirasjon for videre utvikling. Applikasjonen med kildekode finnes her.\nInstansiere med prefill Et bruksområde for det å starte en instans fra et stateless view kan være at man først ønsker at appen skal oppføre seg som en innsynstjeneste hvor brukeren blir presentert for gitte data som er aktuell. Fra denne informasjonen kan brukeren velge å agere videre på dataen som listes opp, og da er man over på en vanlig innsendingstjeneste.\nFor å få til en slik flyt er man først avhengig av å sette opp applikasjonen som en stateless appliksjon som står beskrevet under konfigurasjon. Når dette er gjort kan man utvide stateless viewet til å inkludere InstantiationButton som kan vil starte en ny instans i det brukeren klikker på knappen. Standard oppførsel for denne knappen er å sende inn hele datamodellen som brukeren har benyttet inn som en del av instansieringn under feltet prefill. Om man ønsker å velge ut deler av datamodellen som er benyttet i det tilstandsløse steget vil det også være mulig ved å legge til mapping på InstantiationButton-komponenten. F.eks\n{ \u0026#34;id\u0026#34;: \u0026#34;instantiation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;InstantiationButton\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Start instans\u0026#34; }, \u0026#34;mapping\u0026#34;: { \u0026#34;some.source.field\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;some.other.field\u0026#34;: \u0026#34;id\u0026#34; } } Når brukeren da velger å starte en instans så vil app-frontend hente ut feltene some.source.field og some.other.field fra datamodellen i det tilstandsløse steget og mappe disse mot feltene name og id som sendes med i instansieringskallet for applikasjonen. Eksempel request som vil gå mot backend som man kan mappe over datamodellen man benytter i datamodellen man benytter i innsendingsdelen av applikasjonen:\n{ \u0026#34;prefill\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Ola Nordmann\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;12345\u0026#34; }, ... } Denne prefill verdien kan man så benytte seg av i metoden DataCreation i InstantiationHandler.cs for å mappe mot de feltene man trenger som en del av innsendsingsdelen av applikasjonen under instansieringen. Eksempel:\npublic async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { if (data.GetType() == typeof(MessageV1)) { string name = \u0026#34;\u0026#34;; string id = \u0026#34;\u0026#34;; if (prefill.ContainsKey(\u0026#34;name\u0026#34;)) { name = prefill[\u0026#34;name\u0026#34;]; } if (prefill.ContainsKey(\u0026#34;id\u0026#34;)) { id = prefill[\u0026#34;id\u0026#34;]; } MessageV1 skjema = (MessageV1)data; skjema.Sender = name; skjema.Reference = id; } await Task.CompletedTask; } Instansiere fra en repeterende gruppe Om man i det tilstandsløse steget ønsker at brukeren f.eks velger et element fra en repeterende gruppe å jobber videre på et gitt element kan man sette opp InstantiationButton-komponenten som en del av den repeterende gruppen. Her kan man så konfigurere instansierings-knappen til å mappe felter fra den gitte indeksen brukeren velger å starte en instans fra. Dette krever at man setter opp mapping-feltene med en indeks på den aktuelle gruppen. Eksempel:\n{ \u0026#34;id\u0026#34;: \u0026#34;instantiation-button\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;InstantiationButton\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Start ny instans\u0026#34; }, \u0026#34;mapping\u0026#34;: { \u0026#34;people[{0}].name\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;people[{0}].age\u0026#34;: \u0026#34;age\u0026#34; } } I den repeterende gruppen vil så {0} bli erstattet med den aktuelle indeksen på gruppen brukeren ønsker å starte fra.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/deployment/",
	"title": "Deployment",
	"tags": [],
	"description": "Konfigurering av deploy og kjøretids oppsett",
	"content": "Fra versjon 2.0.0 av deployment helm-charten er autoskalering tilgjengelig og aktivert som standard.\nAutoskalering benytter Horizontal Pod Autoscaler) for å automatisk skalere opp og ned en app basert på CPU forbruk.\nNår man skal konfigurere hvordan autoskaleringen oppfører seg må man ta hensyn til to seksjoner i deployment/values.yaml.\nresources cpu/minne garantier og grenser for app pods under kjøring, se: Resources konfigurasjon autoscaling konfigurerer når din applikasjon skal skaleres opp eller ned. Vi setter noen standard verdier basert på tester vi har utført og erfaringer vi har gjort oss, disse kan endre seg etter hvert som vi får mer erfaringer over tid.\nStandard verdiene kan du se her\nEt eksempel på hvordan du overskriver verdier:\nI values.yaml i den sentrale helm-charten er replicaCount definert som følger:\nreplicaCount: 2 ... For å overskrive dette i den app endrer du filen deployment/values.yaml og legger replicaCount under deplyoment:\ndeployment: replicaCount: 3 ... Legg merke til at \u0026ldquo;deployment:\u0026rdquo; er lagt til i forhold til det sentrale charten sin values.yaml. replicaCount er også indentert med to mellomrom. I yaml skal indents være mellomrom og ikke tab, benytter du tab vil ikke din yaml være gyldig.\rSkalering Initial skalering Initial skalering er konfigurerbart med feltet replicaCount. Hvis autoskalering er aktivert vil autoskalerings logikken overstyre denne verdien. Eksempel hvor initial skalering er satt til 2:\ndeployment: replicaCount: 2 Autoscaling konfigurasjon Autoscaling seksjonen konfigurerer når en applikasjon automatisk skal skaleres. Dette er håndtert av Horizontal Pod Autoscaler i kubernetes.\nFor å lese mer og Horizontal Pod Autoscaler kan du lese kubernetes sin dokumentasjon her.\nStandard verdier hvis ikke overstyrt i deployment/values.yaml\ndeployment: autoscaling: enabled: true replicas: min: 2 max: 10 avgCpuUtilization: 70 behavior: stabilizationWindowSeconds: scaleUp: 0 scaleDown: 120 deployment.autoscaling.replicas min: Det laveste antall pods autoskaleringen har lov til å sette. max: Det høyeste antall pods autoskalering har lov til å sette.\ndeployment.autoscaling.avgCpuUtilization Terskelen for prosent av cpu request som er utnyttet før opp eller ned skalering skal skje.\nOppskaleringen er ikke umiddelbar siden en ny pod trenger tid på å starte (1-2 min i de fleste tilfeller). Hvis alle ressursene i et cluster er reservert må en ny node startes opp i azure (5-10 min i de fleste tilfeller). Det er derfor lurt å ha en liten buffer sånn at applikasjonen kan håndtere lasten frem til kapasiteten er utvidet.\ndeployment.autoscaling.behavior.stabilizationWindowSeconds Stabiliserings vindu er benyttet for å begrense blafring av replikaer når metrikkene som er brukt for skalering svinger.\nSom standard vil en oppskalering skje så fort forbruket er over terskelverdiene. Nedskalering vil vente i to minutter.\nscaleUp: Antall sekunder kubernetes skal vente etter siste skalering før den gjør en ny evaluering om oppskalering. scaleDown: Antall sekunder kubernetes skal vente etter siste skalering før den gjør en ny evaluering om nedskalering.\nResources konfigurasjon For å sette gode requests og eventuelt limits er kjennskap til appen viktig da koden og oppgavene applikasjonen utfører har stor innvirkning på dette. Vi forsøker å sette kode standard verdier som fungerer for så mange av alle appene i Altinn som mulig, men det er ikke sikkert de passer for din app.\nStandard verdier hvis de ikke blir overskrevet i deployment/values.yaml\ndeplyoment: resources: requests: cpu: 300m memory: 256Mi Verdier som er mulige å konfigurere (verdiene under er kun som et eksempel og på ingen måte en fasit)\ndeplyoment: resources: requests: cpu: 200m memory: 256Mi limits: cpu: 1000m memory: 512Mi deployment.resources.requests Denne seksjonen i values.yaml definerer ressursene som din app vil få reservert av kubelet i clusteret.\nRequests er brukt av kubernetes sin skedulerer for å finne noden den skal plassere appen sine pods på. Dette vil begrense hvor mange pods en node kan kjøre før den er full.\nRequests er også brukt av Horizontal Pod autoscaler for å avgjøre om det skal skalere opp eller ned antall replikaer av appen.\nGitt et cluster med noder som har 2 cores (2000 millicores) og 4Gi minne hvor alle pods har requests satt til 200m (200 millicores) og 256Mi.\nAntall pods en node kan kjøre basert på CPU request er: 2000 / 200 = 10\nAntall pods en node kan kjøre basert på minne request er: 4096Mi / 256Mi = 16\nAntall pods en node kan kjøre, med eller uten last i løsningen er da: 10.\nRequests begrenser ikke hvor mye CPU eller minne en applikasjon kan bruke dersom mer er tilgjengelig, men blir det lite ressurser og en pod bruker mer enn requests kan denne blir \u0026ldquo;kastet ut\u0026rdquo; av noden.\ndeployment.resources.limits Denne seksjonen i values.yaml definerer hvor mye en pod kan maksimalt bruke.\nHvis en pod forsøker å benytte mer CPU en det som er satt som limit vil denne bli strupet.\nHvis en pod forsøker å allokere mer minne en det som er satt som limit vil den bli terminert med en Out Of Memory (OOM) error.\nLinkerd Alle applikasjoner som deployes er som standard innlemmet i Linkerd sitt service mesh.\nVi anbefaler på det sterkeste å ikke endre denne innstillingen da den legger på mutual TLS som krypterer all intern kommunikasjon mellom tjenester i klusteret før det forlater en maskin.\ndeployment: ... linkerd: enabled: true ... Volumes and VolumeMounts Disse delene gjør det mulig å mounte opp forskjellige ressurser til filsystemet til en applikasjon. Det er to predefinerte mounts som benyttes av standard funksjonalitet for å blant annet kommunisere med Altinn Platform.\ndeployment: ... volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken På gjeldende tidspunkt er det kun en use case for å legge til andre volumer: Hente hemmeligheter fra Azure Key Vault\nService Service konfigurasjonen gjør det mulig å endre hvilke port som eksponeres internt i clusteret og hvilken intern port dette skal mappes til. Det er sjelden disse verdiene må endres. Hvis din applikasjon kjører på annen port enn 5005 så endrer du internalPort. EksternalPort må ikke endres Standard oppsett er:\ndeployment: ... service: name: deployment type: ClusterIP externalPort: 80 ## If your application is running on another port, change only the internal port. internalPort: 5005 ... Deler som blir overskrevet ved deploy image ingressRoute Disse områdene blir overskrevet ved deploy så endringer her vil ha liten til ingen effekt.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/deployment/",
	"title": "Produksjonssetting av apper",
	"tags": [],
	"description": "Tjenesteeier kan selv produksjonssette sine applikasjoner, og gjøre vedlikehold av kode og avhengigheter.",
	"content": "Få tilgang til et produksjonsmiljø Første gang man skal gjøre deploy av en applikasjon til produksjonsmiljøet er det behov for at det er satt opp et eget tjenesteeier-cluster. For å få dette gjelder følgende prosess:\nSend en e-post med en beskjed om hvilken/hvilke apps du har klar til produksjonssetting. Vent på beskjed om at cluster er opprettet. Denne rutinen trenger bare å følges en gang. Når clusteret er satt opp, er løsningen selvbetjent etterpå.\nProduksjonssette en app Produksjonssetting av applikasjonen gjøres på samme måte som for testmiljøer.\nDatabehandleravtale for behandling av personopplysninger i Altinn Du må fylle ut Vedlegg til Bilag 2 og sende dette til tjenesteeier@altinn.no\nBestille Om skjema-side Altinn vedlikeholder en oversikt over alle tjenester i løsningen. For at Altinn brukerservice skal kunne hjelpe brukerne med en tjeneste, må informasjon legges inn her. Bestillingsskjemaet heter \u0026ldquo;Publiser informasjon om tjeneste på Altinn PROD og TT02\u0026rdquo;, og finnes etter innlogging på altinndigtal.no.\nMerk! Bestillingsskjemaet er inntil videre optimalisert for Altinn II-tjenester. Gjør derfor følgende:\nI feltet \u0026ldquo;Tjenestekode\u0026rdquo;, oppgi 9999 og i feltet \u0026ldquo;Utgavekode\u0026rdquo; oppgi 9999 I feltet \u0026ldquo;Hvem skal bruke skjemaet\u0026rdquo; husk å angi hvilke roller som er satt på tjenesten i tillegg til beskrivelsen av hvem tjenesten er for. Kjøremiljø\rBeskrivelse av kjøremiljøet for en Alttin 3 applikasjoner for en tjenesteeier.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/",
	"title": "Vedlikehold av app i produksjon",
	"tags": [],
	"description": "Applikasjoner i produksjon krever jevnlig vedlikehold og oppdateringer.",
	"content": "Når applikasjonen er satt i produksjon, vil det oppstå behov for å vedlikeholde applikasjonen. Den vanligste vedlikeholdstypen vil være å oppdatere avhengigheter.\nFor å gjøre en ny versjon av applikasjonen tilgjengelig, produksjonssetter man den på samme måte som vanlig.\nInstanser av appen i brukers innboks vil automatisk oppdateres til å bruke siste versjon av applikasjonen, så det er viktig at man ikke innfører endringer som knekker eksisterende instanser.\nOppdatere avhengigheter i app\rHvordan oppdatere avhengigheter i en app.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authentication/",
	"title": "Konfigurasjon av autentisering",
	"tags": [],
	"description": "Når det gjelder autentisering er det noen konfigurasjoner som kan være aktuell",
	"content": "Autentiseringsnivå Påkrevd autentiseringsnivå settes i XACML Policy som obligation.\nID-provider Det er mulig å sette at app skal bruke en spesiell ID-provider som ikke er standardvalget. Standarvalg betyr ID-porten / Altinn pålogging.\nDe eneste godkjente ID-providerene for øyeblikket er\nFEIDE UIDP Bruk av OIDC provider settes i appSettings\n\u0026#34;AppOidcProvider\u0026#34;: \u0026#34;uidp\u0026#34; Les mer om OIDC støtten under arkitektur.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/",
	"title": "Lanserte tjenester",
	"tags": [],
	"description": "Noen av tjenestene som allerede er i produksjon, til informasjon og inspirasjon.",
	"content": "September 2022 Skjema for innrapportering av gjenopprettingsplan (KRT-1226) (Finanstilsynet)\nInfo | Repo | Kjørende tjeneste Brudd på gjenopprettingsindikatorer (KRT-1228) (Finanstilsynet)\nInfo | Repo | Kjørende tjeneste Melding om sikkerhetsrådgiver (Direktoratet for samfunnssikkerhet og beredskap)\nInfo | Repo | Kjørende tjeneste Juli 2022 Oppstartveileder for enkeltpersonforetak (Brønnøysundregistrene)\nInfo | Repo | Kjørende tjeneste Oppstartveileder for enkeltpersonforetak uten innlogging (Brønnøysundregistrene)\nInfo | Repo | Kjørende tjeneste Juni 2022 Søk om godkjenning av virksomhet som tilbyr bilpleie, hjulskift og hjullagring (Arbeidstilsynet)\nInfo | Repo | Kjørende tjeneste Mai 2022 Veileder for kvalitet i læremidler (Utdanningsdirektoratet)\nInfo | Repo | Kjørende tjeneste Invitasjonsverktøy for vurdering av læremidler (Utdanningsdirektoratet)\nInfo | Repo | Kjørende tjeneste April 2022 Nasjonalt arbeidstidsregister (STAMI).\nInfo | Repo | Kjørende tjeneste Mars 2022 Transportløyvegarantier (Statens vegvesen).\nInfo | Repo | Kjørende tjeneste Bestilling av tilgang til Medarbeiderundersøkelsen i staten (STAMI).\nInfo | Repo | Kjørende tjeneste Avtalevilkår for Medarbeiderundersøkelsen i staten (STAMI).\nInfo | Repo | Kjørende tjeneste Mva-meldingen (Skatteetaten).\nInfo | Repo Skattemeldingen (Skatteetaten).\nInfo | Repo Februar 2022 Algeskjema (Havforskningsinstituttet).\nInfo | Repo | Kjørende tjeneste Søk om tillatelse til å arbeide med asbest (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Januar 2022 Behovskartlegging for opprettelse av vergemål (Statens sivilrettsforvaltning).\nInfo | Repo | Kjørende tjeneste Forespørsel om endring av vergefullmakt (Statens sivilrettsforvaltning).\nInfo | Repo | Kjørende tjeneste August 2021 Valgkort (Valgdirektoratet).\nInfo | Repo | Kjørende tjeneste Juni 2021 Forhåndsgodkjenning av innreise for kjærestebesøk (UDI).\nInfo | Repo | Kjørende tjeneste Mai 2021 Søknad for unntak om opphold på karantenehotell ved sterke velferdsgrunner når du reiser til Norge fra utlandet (UDI).\nInfo | Repo | Kjørende tjeneste Melding om registrering av bemanningsforetak (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Årlig melding – Register over bemanningsforetak (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste April 2021 Skattemelding med næringsspesifikasjon - pilot (Sirius) (Skatteetaten).\nInfo | Repo | Kjørende tjeneste Februar 2021 Søknad om forhåndsgodkjenning av innkvartering i forbindelse med innreisekarantene (Arbeidstilsynet).\nInfo | Repo | Kjørende tjeneste Digital pliktavlevering (Nasjonalbiblioteket).\nInfo | Repo | Kjørende tjeneste Desember 2020 Søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste Vedlegg til søknad om autorisasjon som landmåler (Kartverket).\nInfo | Repo | Kjørende tjeneste Juni 2020 Ledige stillinger (RA0678) (SSB).\nInfo | Repo | Kjørende tjeneste Bestill tilgang til REST API (Digdir).\nInfo | Repo | Kjørende tjeneste Be om å bli tjenesteeier (Digdir).\nInfo | Repo | Kjørende tjeneste Godkjenning av bruksvilkår for skytjenester fra Altinn (Digdir).\nInfo | Repo | Kjørende tjeneste Apper fra Digdir\rDokumentasjon for apper utviklet av Digitaliseringsdirektoratet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/",
	"title": "Roadmap for Altinn",
	"tags": [],
	"description": "Høynivå roadmap og funksjonell beskrivelse for Altinn.",
	"content": "Altinn er under kontinuerlig videreutvikling. Du får vite mer om hva vi har gjort og hva vi planlegger å gjøre her. Enn så lenge er det kun roadmap for Altinn Studio og relatert funksjonalitet som er tilgjengelig her. All annen funksjonalitet har en egen roadmap.\nSe diagram nedenfor for detaljert feature oversikt med status for Altinn 3. Hver boks har en link til nærmere forklaring på feature.\nKlikk for åpne diagram i fullskjerm\nRoadmap for Altinn Studio\rHøynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/",
	"title": "Roadmap for Altinn Studio",
	"tags": [],
	"description": "Høynivå roadmap og funskjonelle beskrivelser for Altinn Studio og funksjonalitet som understøtter apper utviklet der.",
	"content": "\rFor informasjon om hvordan man bruker funksjonalitetene beskrevet her, se seksjonene om apper og API.\nApplikasjonseierfunksjonalitet in Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\nSluttbrukerfunksjonalitet i Altinn 3\rDette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_altinn/altinn_roles_administration/",
	"title": "Altinn roller som brukes til admnistrasjon av tilganger",
	"tags": [],
	"description": "Denne siden beskriver hvilke Altinn roller som kan benyttes for å gi tilgang til å administrere roller og rettigheter på vegne av en virksomhet",
	"content": "Administrator roller skal IKKE benyttes i autorisasjonsregler for en applikasjon. Det er allikevel nyttig å vite at de er tilgjengelig for aktøren og at det er nødvendig for bruker som skal styre tilganger for aktøren å ha disse.\nTilgangsstrying Beskrivelse: Denne rollen gir administratortilgang til å gi videre rettigheter til andre.\nHovedadministrator Rollen kan kun benyttes for virksomheter, ikke for personer Beskrivelse: Denne rollen gir mulighet for å delegere alle roller og rettigheter for en aktør, også de man ikke har selv. Hovedadministrator-rollen kan bare delegeres av daglig leder, styrets leder, innehaver og bestyrende reder.\nParallell signering Rollen kan kun benyttes for virksomheter, ikke for personer Beskrivelse: Denne rollen gir rettighet til å signere elementer fra andre avgivere.\nKlientadministrator Rollen kan kun benyttes for virksomheter, ikke for personer Beskrivelse: Tilgang til å administrere klientroller for regnskapsførere og revisorer\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_altinn/",
	"title": "Roller fra Altinn",
	"tags": [],
	"description": "Denne siden beskriver Altinn roller som kan benyttes til å gi tilgang til en applikasjon.",
	"content": "Altinn har definert et sett med generiske roller som aktøren (person/virksomhet) kan benytte til å gi andre fullmakt til å utføre tjenester på dere vegne. Beskrivelsen av Altinn rollen setter begreninger og angir hvilke trinn i arbeidsprosessen for hvilke typer tjenester som bør knyttes til denne.\nSom applikasjonsutvikler må du derfor alltid vurdere om intensjonen bak rollebeskrivelsen fallen innenfor din applikasjons tjenesteområde eller ikke. Vi oppfordrer sterkt til å ta kontakt med Altinn for veilednig i valg av rollekrav på tjenesten.\nAltinnrollene kan deles opp i to hovedkategorier: roller som benyttes for tilgangstyring på vegne av virksomheter og roller som benyttes for tilgangsstyring på vegne av personer\nAltinn Roller for virksomheter Disse rollene kan benytts i autorisasjonsregler for applikasjoner som skal benyttes av virksomheter Les mer om hvilke roller dette er her\nAltinn Roller for personer Disse rollene kan benytts i autorisasjonsregler for applikasjoner som skal benyttes av personer Les mer om hvilke roller dette er her\nAltinn roller for administrasjon av tilganger Disse rollene kan ikke benyttes i autorisasjonsregler for applikasjoner. Les mer om hvilke roller dette er her\n"
},
{
	"uri": "https://docs.altinn.studio/nb/",
	"title": "Altinn Studio docs",
	"tags": [],
	"description": "Lær om Altinn Studio",
	"content": "Altinn Studio docs "
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/open-source/",
	"title": "Altinn og åpen kildekode",
	"tags": [],
	"description": "Altinn 3 er åpen kildekode, med en åpen backlog, åpen dokumentasjon og åpen dialog og diskusjoner.",
	"content": "Det er flere som har fått med seg at Altinn har tatt en fundamentalt ny og åpen retning de siste årene.\nVi har fått litt spørsmål om hvorfor vi har gjort dette, og tenker det kan være interessant at vi deler våre tanker om åpen kildekode, som en sentral nasjonal felleskomponent.\nDeling og gjenbruk Det finnes mange gode grunner til å dele kode som åpen kildekode.\nNAV, en av de virkelig store inne åpen kildekode i Norge, er også inne på flere av de samme punktene, men særlig dette med viktigheten av gjennomsiktighet og tillit i forhold til løsninger finansiert av det offentlige.\nVi applauderer når NAV skriver dette:\nOffentlig finansierte løsninger bør være offentlig tilgjengelig.\nMotivasjonen er da ikke hovedsakelig gjenbruk, selv om det selvsagt er en heldig bieffekt. Motivasjonen er først og fremst åpenhet og gjennomsiktighet i de digitale løsningene.\nGjenbruk er derimot noe vi i Altinn anser som en helt sentral motivasjon. Og vi er ikke alene om å tenke slik:\ngov.uk sin Open Source, Open Standards and Re­Use (PDF) beskriver gjenbruk som både en policy og et prinsipp. EU har lenge hatt en tydelig open source strategi (PDF) som sier at kildekode skal deles, og ikke bare det, men at man også bør bidra tilbake. Vi legger til rette for gjenbruk og deling på alle nivåer i arkitekturen til Altinn 3, fra våre prinsipper til hele plattformen og infrastrukturen, ned til design og GUI-komponenter, kode og konfigurasjon.\nDette er også en av flere grunner til at Altinn nå er et digitalt fellesgode (DPG), der målsettingen er å kunne gjenbruke det vi utvikler ikke bare på nasjonalt nivå, men også globalt for å understøtte FNs bærekraftsmål.\nVi oppfordrer også alle de som lager tjenester med Altinn Studio til å dele sine apper, og alt er tilrettelagt for at det skjer automatisk. Faktisk så må tjenesteeierne gjøre et aktivt valg for å ikke dele, siden deling og gjenbruk på tvers i det offentlige er helt sentralt i Altinn 3.\nSamarbeid Den beste måten å få til et godt samarbeid på tvers av organisasjoner og prosjekter er åpenhet og gjennomsiktighet, at alle kan bidra, gi input, bli hørt, følge med på det som skjer.\nDet er dette som har vært helt sentralt i \u0026ldquo;revolusjonen\u0026rdquo; med åpen kildekode, som har blitt den nye normalen for store deler av programvareutvikling i verden. Det er nå 40 millioner utviklere og over 28 millioner åpne repos på GitHub.\nSiden alle våre verktøy og avhengigeheter ligger åpent på GitHub så kan også vi i Altinn følge med, samarbeide og bidra tilbake til programvare som vi benytter.\nEksempler på dette er .NET, Kubernetes, React, Linkerd og Gitea.\nOg vår issue #5992 er et godt eksempel på hvordan vi kan spore og enkelt lenke til saker på tvers av programvare.\nOg siden Altinn er åpen kildekode på GitHub, så er det like enkelt for alle andre å gjøre det samme mot oss. Både det å opprette nye issues, bidra i diskusjoner eller bidra med kode, noe labelen external-contribution-❤️ illustrerer godt.\nLeverandørbindinger Altinn som felleskomponent har tidligere fått store utfordringer ved å basere seg på lukket proprietær programvare. Programvare fra Adobe i Altinn 1 og fra Microsoft i Altinn 2.\nEnd-of-life for proprietær programvare er faktisk hovedårsaken til behovet for å lage Altinn 3.\nNår du bygger en løsning på toppen av proprietær programvare så har du i praksis mistet kontroll over egen fremtid, f.eks. om leverandøren velger å fase ut produktet. Om man baserer seg på åpen kildekode så kan man i en slik situasjon lage en fork, om ikke noen andre gjør det.\nAltinn 3 er derfor basert på programvare og biblioteker som er åpen kildekode.\nVi tenker at dette naturlig nok også er veldig viktig for de som vurderer om man skal ta i bruk Altinn.\nHvilke bindinger innfører vi til Altinn som teknisk løsning og Digdir som \u0026ldquo;leverandør\u0026rdquo;? Selv om Altinn er et samarbeid, så vil dette være viktige spørsmål.\nAltinn 3 er derfor helt åpen kildekode med liberal lisensiering, og alt som utvikles kjører som vanlige containere.\nDe beste verktøyene For å utvikle god programvare så er det viktig å ha tilgang til gode verktøy.\nEn ting som mange kanskje ikke tenker på er at når du deler det du utvikler som åpen kildekode, så blir mange av de aller beste verktøyene der ute tilgjengelig - helt gratis.\n\u0026ldquo;Del, og du blir delt med\u0026hellip;\u0026rdquo;\nHer er noen av de fantastiske SaaS-verktøyene som vi benytter:\nGitHub - Håndtering av kildekode, backlogs, boards, automatisering, CI/CD, etc. ZenHub - Epos, estimering, avhengigheter, rapporter. Cypress - Dashboards og automatisert testing av GUI. SonarCloud - Statisk analyse av kildekode. LGTM - Sikkerhetsanalyse av kildekode. Og dette er bare et lite utvalg\u0026hellip;\nAlle verktøy og rammeverk som vi bygger Altinn på toppen av, er åpen programvare som er veldig godt likt.\nDe beste folkene Det er et gjennomgående tema at folk liker å jobbe med ny teknologi og de beste verktøyene. De beste utviklerne foretrekker også å jobbe med åpen kildekode, føle at man bidrar til noe større, at man setter spor.\nI tiden som har gått siden vi lanserte Altinn 3 så har vi ansatt en del veldig dyktige folk, og et gjennomganstema i intervjuer og diskusjoner er at de beste kandidatene er tydelige på at de synes det er viktig med åpen kildekode, og at dette er noe de ønsker å være med på.\nVi ønsker å bygge et stort community, der alle kan bidra, og da er det ekstremt viktig at vi har teams med dyktige og fornøyde utviklere som kan hjelpe til med å få det til å skje.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/api/",
	"title": "api",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/",
	"title": "Testing av app API-er lokalt",
	"tags": [],
	"description": "Hvordan teste app-APIer lokalt.",
	"content": "\rAPI test org\rNår man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.\nAPI bruk som sluttbruker\rNår man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/app/",
	"title": "app",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/",
	"title": "App API",
	"tags": ["api"],
	"description": "Standard API&#39;er eksponert av apper i Altinn 3.",
	"content": "Overview De API funksjonene som er dokumentert her er standard funksjoner i en app basert på app malen i Altinn Studio. Applikasjonseiere kan fritt gjøre endringer, men det er relativt trygt å annta at fjerning av funksjoner vil være ekstremt skjeldent. Enhver app med tillegg eller endringer skal ha sin egen dokumentasjon publisert av applikasjonseieren.\nAlle app API adresser starter med samme navn og filsti, men de varierer fra en app til en annen basert på eier av app og app navn.\nTest miljø (TT02)\nhttps://{org}.apps.tt02.altinn.no/{org}/{appname} Produksjon\nhttps://{org}.apps.altinn.no/{org}/{appname} URL\u0026rsquo;en identifiserer app eier spesifikt domene ved hjelp av applikasjonseier sitt kortnavn org, og identifiserer spesifikk app ved hjelp av både kortnavnet til applikasjonseier og navnet på appen; org/appname.\nApp metadata\rApp API for å få metadata informasjon for appen.\nInstanser\rApp API å jobbe med forekomster av en app.\nData-elementer\rAPI å jobbe med dataelementene knyttet til en app instans.\nTilstandsløse data\rAPI til å arbeide med dateelementer uten tilstand som ikke er knyttet til en instans.\nProsess\rAPI endepunkter for å lede en instans gjennom prosessen som er definert.\nValidering\rValidering API-endepunktene for instanser og dataelementer.\nOpenAPI (swagger) for Apps\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/appowner/",
	"title": "Applikasjonseierfunksjonalitet in Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio og API.\nTjenesteutvikling i GUI I brukergrensesnittet til Altinn Studio kan du gjøre følgende:\nOpprette (og finne igjen) en app Laste opp datamodell Legge inn tekster Lage et enkelt skjema (en eller flere sider), med kobling mellom elementer, tekster og datamodell Legge inn dynamikkregler (NB! Kodes i JavaScript) Deploye app til test- og produksjonsmiljø Tjenesteutvikling via kode Ved å hente ned applikasjonskoden (via Git) lokalt (eller ved å redigere på app-filene i repository-visning) kan du gjøre alle mulige endringer av appen. Dette inkluderer blant annet standardfunksjonalitet for å:\nLage kalkulerings- og valideringsregler Koble på forhåndsutfylling Legge inn API-oppslag Redigere på prosessen/arbeidsflyten i appen Redigere på autorisasjonsreglene for appen, samt lage egendefinert instansieringslogikk Lage egendefinerte hendelser/events Teste lokalt Når du har applikasjonskoden lokalt, kan du også benytte deg av muligheten til å ha et lokalt testmiljø for å gjøre de fleste typer testing.\nIntegrasjon med tjenesteeier Altinn 3 har standardiserte API-er som tjenesteeier kan bruke for å hente og laste opp data. For nedlasting bygger Altinn 3 på at tjenesteeier gjør spørringer og laster ned data (pull). I tillegg kan tjenesteeier benytte app-enes API-er for å instansiere eller gjøre endringer på instanser.\nMan kan redusere mengden spørringer ved bruk av push av events - at tjenesteeier varsles når det er data til nedlasting (Q2 2021) (#4728) ✔️\nFor å benytte API-ene som tjenesteeier må man autentisere seg med Maskinporten.\nForvaltning av apper Det er lagt opp til tilgang til overvåking av egne applikasjoner, slik at man kan ha oversikt over hvordan appene fungerer. Se også sidene om vedlikehold av apps.\nMulighet for å lage en ny app som kopi av en tidligere (Q3 2021) (#5923) ✔️ Kommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles.\nTjenesteutvikling i GUI For all kommende funksjonalitet gjør vi vurderinger av om det er egnet å løse det i GUI. På et senere tidspunkt (2023 eller senere) vil vi gjøre et løft for at mer funksjonalitet skal være tilgjengelig via GUI.\nStøtte for branching i Altinn Studio (Q4 2021) (#985) Datamodellering Den avhengigheten vi i dag har til at datamodellering skal gjøres i et eksternt system vil forsvinne. Noen høydepunkter i planene for datamodellering i Altinn 3 er:\nÅ kunne jobbe med en datamodell i et GUI (Q4 2021) (#5551) Integrasjoner med Felles datakatalog (Q1 2022) (#3811) Å kunne få automatisk generert datamodell fra det man bygger av brukergrensesnitt Å kunne få automatisk generert forslag til brukergrensesnitt ut fra datamodellen Forvaltning av tjenester Vi ønsker å gjøre tjenesteeiere i stand til å selv forvalte sine applikasjoner i Altinn 3. For å få til dette kommer blant annet:\nMulighet for å avpublisere en applikasjon (Q4 2021) (#3717) Webanalyse for applikasjonene Integrasjon med tjenesteeier Pull av data vil fortsatt være grunnmønsteret for at tjenesteeier får tilgang til data, men det kommer et par unntak:\nMulighet for å bruke eFormidling som grensesnitt for å få data direkte fra en Altinn 3-app til tjenesteeiers systemer (Q4 2021) (#4788) Splitt av data - flere tjenesteeiere kan motta data fra samme tjeneste (Q3 2022) (#4274) "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/apps/",
	"title": "apps",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/apps/",
	"title": "Apps",
	"tags": [],
	"description": "Team Apps sitt hovedansvar er å assistere tjenesteeiere i migrering av tjenester fra Altinn 2 og utvikling av nye tjenester på Altinn 3.",
	"content": "Ansvarsområder Roadmap og planer for migrering av eksisterende tjenester Kartlegge og forstå eksisterende Tjenesteeiernes tjenester, behov og krav Oppfølging og gjennomføring av migrering for og sammen med Tjenesteeiere Behov og kravstiller til Studio og Plattform Nøkkelpartnere "
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/",
	"title": "Authentication API",
	"tags": [],
	"description": "Beskrivelse av hvordan systemer og tjenesteeiere kan benytte Maskinporten eller ID-porten for å få tilgang til APIer i Altinn 3.",
	"content": "\rAutentisere med Maskinporten\rBeskrivelse av hvordan tjenesteeiers systemer kan benytte Maskinporten for å få tilgang til APIer.\nAutentisere med virksomhetsbruker\rBeskrivelse hvordan man kan benytte virksomhetsbrukere i Altinn 3\nAutentisere med ID-porten\rBeskrivelse av hvordan systemer kan benytte ID-porten for å få tilgang til APIer i Altinn 3.\nDelegere API-tilganger til en leverandør\rBeskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.\nOpenAPI (swagger) for Authentication\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/auto-delete/",
	"title": "Automatisk sletting",
	"tags": [],
	"description": "En applikasjon kan konfigureres til å slette alle spor når prosessen er slutt.",
	"content": "Dersom man ønsker å begrense sluttbrukers tilgang til en instans eller data i etterkant av innsending kan dette gjøres ved å konfigurere automatisk sletting. I praksis vil ressursen gjøres utilgjengelig for sluttbruker etter innsending, mens tjenesteeier enda har tilgang i tråd med applikasjonens autorisasjonsregler.\nHvis sluttbruker forsøker å aksessere en hard deleted ressurs med en direkte lenke vil de få 404 - Not found i respons. Ressursen vil heller ikke vises i meldingsboks eller listes i API-responser.\nNår tjenesteeier bekrefter at instansen er mottatt på deres side (complete confirmed), så markeres instansen som klar for sletting og vil saneres fra Altinns database i løpet av 7 dager.\nKonfigurasjonen for automatisk sletting gjøres i applicationmetadata.json med flagget \u0026quot;autoDeleteOnProcessEnd\u0026quot;: true.\nAutomatisk sletting av instans Eksempel på konfigurasjon i applicationmetadata.json for instanser:\n{ \u0026#34;id\u0026#34;: \u0026#34;ttd/apps-test-prod\u0026#34;, \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, \u0026#34;title\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;apps-test-prod\u0026#34; }, \u0026#34;dataTypes\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.Skjema\u0026#34; }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0 }, { \u0026#34;id\u0026#34;: \u0026#34;6aa7d237-f20f-4d42-9361-0c84cf1a8ed0\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [], \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 1, \u0026#34;maxCount\u0026#34;: 3, \u0026#34;minCount\u0026#34;: 1 } ], \u0026#34;partyTypesAllowed\u0026#34;: { \u0026#34;bankruptcyEstate\u0026#34;: false, \u0026#34;organisation\u0026#34;: false, \u0026#34;person\u0026#34;: false, \u0026#34;subUnit\u0026#34;: false }, \u0026#34;created\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601284Z\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-06-04T12:11:36.9601305Z\u0026#34;, \u0026#34;lastChangedBy\u0026#34;: \u0026#34;someone\u0026#34;, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true } Automatisk sletting av data Eksempel på konfigurasjon i applicationmetadata.json for data type:\n\u0026#34;dataTypes\u0026#34;:[ { \u0026#34;id\u0026#34;: \u0026#34;Skjema\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: true, \u0026#34;classRef\u0026#34;: \u0026#34;Altinn.App.Models.skjema\u0026#34;, \u0026#34;allowAnonymousOnStateless\u0026#34;: false, \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;enablePdfCreation\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;ref-data-as-pdf\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/pdf\u0026#34; ], \u0026#34;maxCount\u0026#34;: 0, \u0026#34;minCount\u0026#34;: 0, \u0026#34;enablePdfCreation\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;vedleggA\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;enablePdfCreation\u0026#34;: true, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true } } ] "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/autorisasjon/",
	"title": "autorisasjon",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/authorization/",
	"title": "Autorisasjon",
	"tags": [],
	"description": "Autorisasjon DevOps team har hovedsaklig ansvar for løsninger som leverer Autentisering og Autorisasjonsfunksjonalitet i Altinn 2 og Altinn 3 løsningen",
	"content": "Ansvar i Altinn 3: Autorisasjonsteamet har ansvar for følgende tjenester på Altinn 3 plattformen. Dette inkluderer oppgaver som utvikling av ny funksjonalitet, feilretting, drift og support.\nAutentisering Autentiseringskomponenten sørger for å autentisere brukere og systemer som får tilgang til Altinn Apps og Altinn-plattformen.\nRepository\nAutorisasjon Autorisasjonskomponentene gir tilgangsstyring og tilgangskontroll for tjenester til offentlige tjenester. Dette gjelder tjenester på og utenfor Altinn-plattformen. Løsningen er dokumenterthere\nRepository for authorization\nRepository for access policies\nRepository for access groups\nRepository for resource registry\nRepository for access management\nRepository for access management frontend\nRepository for Design system used in access management frontend\nRegister Registerapplikasjonen gir Altinn 3 tilgang til registerdata om personer og organisasjoner i Norge.\nRepository\nAnsvar i Altinn 2: Autorisasjonsteamet har ansvar for følgende tjenester på Altinn 2 plattformen. Dette inkluderer support, feilretting og nødvendig videreutvikling for å sikre migering av tjenester fra Altinn 2 til Altinn 3. Hendelser av kritisk karakter (support saker eller feilretting) håndteres ikke av Autorisasjonsteamet på Altinn 2.\nSamtykketjenesten Med samtykke/fullmakt kan du be om lov til å hente/dele data det offentlige har om en innbygger eller virksomhet, eller utføre noe på vegne av dem. Du får da midlertidig innsyns- eller handlingsrett på et spesifikt sett med opplysninger eller tjenester fra brukeren. Dette kan for eksempel være ligningsdata fra Skatteetaten. Les mer her\nStyring av tilgang Altinn kan benyttes til autorisasjon og tilgangskontroll for eksterne tjenester, altså tjenester på andre nettsteder enn i Altinn-plattformen. Altinn Autorisasjon kan benyttes av tjenesteeiere som ønsker å tilgjengeliggjøre informasjon og tjenester på egen plattform og nettsted, men ikke kan utføre en full autorisasjon av brukers tilganger. Les mer her\nStyring av tilgang til API Maskinporten er delen av den felles nasjonale innloggingsløsningen som Digdir tilbyr for sikring av API-tilganger via maskin-til-maskin-autentisering og en OAuth2-scope basert autorisasjonsmekanisme. I Altinn er det utvklet en løsning som gjør det mulig for virksomheter som er gitt tilgang til et API gjennom Maskinporten å gi denne videre til for eksempel en leverandør som skal utføre den tekniske implementasjonen på deres vegne. Les mer her\nBrukere og autentisering av disse Altinn 2 tilbyr følgende brukertyper: personer (pnr/dnr), organisasjoner (orgnr), virksomhetsbrukere, selvidentfiserte brukere, datasystem (systemID) Autentisering via Portal og i API inkl integrasjon mot IDporten, Maskinporten og Altinn-spesifikke autentiseringsløsninger\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/maintainance/dependencies/",
	"title": "Oppdatere avhengigheter i app",
	"tags": [],
	"description": "Hvordan oppdatere avhengigheter i en app.",
	"content": "Appen er avhengig av flere ressurser som ligger utenfor selve appen. Dette inkluderer støttebiblioteker med felles funksjonalitet for alle apper og referanse til appen sin frontend.\nDisse avhengighetene er definert noen forskjellige steder i appen, og hver avhengighet refereres til med en spesifikk versjon. Når ressursene oppdateres, publiseres de på nytt som en ny versjon. En ny versjon kommer ofte med ny funksjonalitet eller forbedringer. For at appen skal kunne ta dette i bruk, må man oppdatere hvilken versjon av ressursene appen henter.\nNuget Nuget er .NET sin package manager, hvor vi publiserer kodebibliotek som brukes av alle appene.\nAppen bruker flere støttebiblioteker, som oppdateres fortløpende med forbedringer og ny funksjonalitet. En app refererer til konkrete versjoner av de forskjellige bibliotekene, og disse referansene må oppdateres for å hente inn siste versjon.\nOppgradere til nyeste versjon Tips: Installer Version Lens-utvidelsen for Visual Studio Code.\nDa kan du automatisk se hva som er nyeste versjon av alle pakker når du åpner App.csproj. Støtter også npm.\nFinn fram referansene til bibliotekene i appen. Referansene til biblioteker ligger i filen App/App.csproj i appens repo. F.eks.:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.Extensions.Logging.Debug\u0026#34; Version=\u0026#34;3.1.3\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Microsoft.VisualStudio.Web.CodeGeneration.Design\u0026#34; Version=\u0026#34;3.1.2\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; Sjekk om det har kommet en oppdatert versjon av bibliotekene: Altinn.App.Api Altinn.App.Common Altinn.App.PlatformServices Oppdater de aktuelle referansene til den siste versjonen og lagre filen. Sjekk om det er noen breaking changes ifm endringer i bibliotekene, og gjør ev. endringer som beskrives for å løse ev. problemer. Bygg og deploy appen på nytt. App frontend App frontend lastes inn av appen runtime, via en lenke til javascript-filen som er app frontend. Denne javascript-filen versjoneres ihht. Semantic Versioning:\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, and PATCH version when you make backwards compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\nApp\u0026rsquo;en refererer som standard til en major versjon av app frontend, f.eks. versjon 1.x.y. Med mindre det kommer en ny major versjon vil alle oppdateringer med ny minor eller patch versjoner komme med automatisk. Om det kommer en ny major versjon må man eksplisitt oppdatere appen til å referere til denne.\nDersom man ønsker å referere til en spesifikk versjon av app frontend (f.eks. 1.2.3) så kan dette spesifiseres direkte i url\u0026rsquo;en som peker på app frontend.\nOppgradere til nyeste versjon / spesifisere versjon Referansen til app frontend ligger i App/views/Home/Index.cshtml.\nDet er 2 referanser som må oppdateres:\nReferansen til altinn-app-frontend.js-filen som er app frontend koden. \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Referansen til altinn-app-frontend.css som inneholder styling for app frontend. \u0026lt;script src=\u0026#34;https://altinncdn.no/toolkits/altinn-app-frontend/\u0026lt;VERSJONSNUMMER\u0026gt;/altinn-app-frontend.css\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; Søk etter filnavnet (altinn-app-frontend.js eller altinn-app-frontend.css) og erstatt versjonsnummeret (f.eks. 1) med ønsket versjonsnummer (f.eks. 2).\nHusk: Dersom man setter kun major versjon (f.eks. 2), så vil alle oppdateringer innenfor denne major versjoner (bugfix, ny funksjonalitet som ikke er breaking) komme med automatisk. Dersom man setter en spesifikk versjon (f.eks. 2.0.0) så vil appen hente akkurat denne versjonen, helt til referansen evt. oppdateres til å bruke en annen versjon.\nDeployment Deployment utføres ved hjelp av helm charts. Standard deployment oppsett for apps hentes fra altinn-studio sitt helm repository.\nEr du i tvil om du benytter siste deployment strategi kan du følge migreringsguiden her\nFor å finne siste versjon av helm-charten kan du enten sjekke releases av charten deployment her eller legge inn helm repoet lokalt og søke i dette på følgende måte:\n# Legg til helm altinn-studio helm repo helm repo add altinn-studio https://charts.altinn.studio # Søk for versjoner av altinn-studio/deployment charten helm search repo -l altinn-studio/deployment Hvis det er ny versjon av helm charten sjekk changelog for å se hva som er oppdatert i versjonen.\nFor å ta i bruk en ny versjon oppdater versjon under dependencies i deployment/Chart.yaml\napiVersion: v1 description: A Helm chart for Kubernetes name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 \u0026lt;--- Oppdater her "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/bekreftelsessteg/",
	"title": "bekreftelsessteg",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/bli-tjenesteeier/",
	"title": "Bli tjenesteeier",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å bli tjenesteeier i Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\nInfo Repo Kjørende tjeneste "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/bpmn/",
	"title": "bpmn",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i app frontend i v3.0.0",
	"content": "As of v3.0.0 of app frontend, the font Altinn-DIN replaces the Roboto font that was used previously.\nOnce an app is upgraded to use v3 of the app frontend, all CSS expects the Altinn-DIN font to be loaded. In order for the app to display fonts as expected, the font that is loaded with the app must be updated.\nIn App/views/Home/Index.cshtml, replace the line\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/roboto/latin/roboto.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; with\n\u0026lt;link href=\u0026#34;https://altinncdn.no/fonts/altinn-din/altinn-din.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34;\u0026gt; The updated file, referring to v3 of app frontend, should reflect the changes of the file on the right:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v3.0.0.",
	"content": "We have added a new PDF handler to make it possible to hide pages and components in PDF.\nThe new version of the Altinn.App.* packages have breaking changes:\nUpdating to this version will require changes in multiple files.\nUpdated package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.0. \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.0\u0026#34; /\u0026gt; Create a new file for a new class called PdfHandler in the logic/Print folder File from template using System.Threading.Tasks; using Altinn.App.Common.Models; namespace Altinn.App.AppLogic.Print { /// \u0026lt;summary\u0026gt; /// Handler for formatting PDF. /// \u0026lt;/summary\u0026gt; public class PdfHandler { /// \u0026lt;summary\u0026gt; /// Method to format PDF dynamic /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;the layoutsettings\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;data object\u0026lt;/param\u0026gt; public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await Task.FromResult(layoutSettings); } } } Changes to the App.cs file\nAdd using using Altinn.App.AppLogic.Print; using Microsoft.Extensions.Options; using Microsoft.AspNetCore.Http; using Altinn.App.Services.Configuration; Add a new private field below InstantiationHandler private readonly PdfHandler _pdfHandler; Change constructor from: public App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService) to: public App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService, IOptions\u0026lt;GeneralSettings\u0026gt; settings, IText textService, IHttpContextAccessor httpContextAccessor) : base( appResourcesService, logger, dataService, processService, pdfService, prefillService, instanceService, registerService, settings, profileService, textService, httpContextAccessor) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); _pdfHandler = new PdfHandler(); } Add method /// \u0026lt;summary\u0026gt; /// Hook to run logic to hide pages or components when generatring PDF /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;The layoutsettings. Can be null and need to be created in method\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;The data that there is generated PDF from\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;Layoutsetting with possible hidden fields or pages\u0026lt;/returns\u0026gt; public override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v4.0.0.",
	"content": "Altinn.App.* librarires target .Net 5 now, which requires that the application does the same.\nIn addition, all references to app and platform services have been moved from Startup.cs and should be replaced with two method calls.\nFollow the instructions below to ensure that the app is compatible with version 4 of the Altinn.App.* packages.\nUpdate target framework and package dependencies\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate target framework to .Net 5 by replacing\n\u0026lt;TargetFramework\u0026gt;netcoreapp3.1\u0026lt;/TargetFramework\u0026gt; with\n\u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; In the same file, update the Altinn.App.* package references to version 4.0.0.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;4.0.0\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;4.0.0\u0026#34; /\u0026gt; The changes in the file should match the image below:\nUpdate Dockerfile to use .Net 5 images\nThe Dockerfile can be found in the root folder of the application repository.\nUpdate build image by replacing\nFROM mcr.microsoft.com/dotnet/core/sdk:3.1-alpine AS build with\nFROM mcr.microsoft.com/dotnet/sdk:5.0-alpine AS build And update the runtime image by replacing\nFROM mcr.microsoft.com/dotnet/core/aspnet:3.1-alpine AS final with\nFROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine AS final The changes in the file should match the image below:\nReplace references to services with call to extension method\nIn the App folder you will also find Startup.cs\nSeveral lines of code will be removed and replaced with the two lines below.\nservices.AddAppServices(Configuration, _env); services.AddPlatformServices(Configuration, _env); The code that should be removed from the file is marked in pink in the pictures below, which cover one section of the file each.\nDepending on how many custom changes you have made in your file the line numbers might not match. Do not worry, the services should still be grouped togheter roughly as shown in the picture. The application will run even if not all services are removed, so just do your best.\nStart by removing referenes to the Altinn App services.\nRemove references to all the Altinn Platform services.\nRemove all loading of configuration files.\nRemove logic to configure Application insights.\nRemove private method for retrieving the key for Application Insights.\nAs previously stated the removed references are now replaced by calls to two new methods that will load all existing and future platform and app services into your application.\nservices.AddPlatformServices(Configuration, _env); loads all configurations and services that the app requires to use Altinn Platform functionality, and services.AddAppServices(Configuration, _env); loads all remaining configurations and services that the app requires such as Authorization and Prefill services.\nEnsure that these lines are added withing the ConfigureServices fuction.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v5/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Overview of breaking changes introduced into app nuget packages in v5.0.0.",
	"content": "1. PDF generation implementation moved out from AppBase/IAltinnApp All code related the generation of Pdf has been extracted from AppBase.cs and moved into PdfService.cs which in turn implements IPdfService. This opens up and allows us as service developers to replace the default Pdf implementation entirely.\nSince App.cs passes parameteres to AppBase.cs you need to remove thos no longer in use in the call to base(...) in the cosntructor:\nprocessService settings textService Your App constructor should then look something like this:\npublic App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPdfService pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IInstance instanceService, IOptions\u0026lt;GeneralSettings\u0026gt; settings, IText textService, IHttpContextAccessor httpContextAccessor) : base( appResourcesService, logger, dataService, pdfService, prefillService, instanceService, httpContextAccessor) It might be that you don\u0026rsquo;t use any of the removed services in you app code either, then you should remove those from the App constructor as well.\nIf you have implemented custom code to control Pdf generation, and depending on how you have done this, you have a couple options when it comes to what you need to do to resolve the breaking change. However the end result should be the same.\nCustom code in PdfHandler.cs\nThis is when you have added custom code in PdfHandler.cs. You should continue to use this class but it needs to implement an interface by following the steps below:\nMake sure the PdfHandler class implements the ICustomPdfHandler interface.\nNavigate to PdfHandler.cs and add : ICustomPdfHandler after the class name. The class should allready have the method defined in the interface. When adding the ICustomPdfHandlerinterface you also need to add a using statement using Altinn.App.PlatformServices.Interface;.\n/// \u0026lt;summary\u0026gt; /// Handler for formatting PDF. /// \u0026lt;/summary\u0026gt; public class PdfHandler : ICustomPdfHandler { /// \u0026lt;summary\u0026gt; /// Method to format PDF dynamic /// \u0026lt;/summary\u0026gt; /// \u0026lt;example\u0026gt; /// if (data.GetType() == typeof(Skjema) /// { /// // need to create object if not there /// layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;a23234234\u0026#34;); /// } /// \u0026lt;/example\u0026gt; /// \u0026lt;param name=\u0026#34;layoutSettings\u0026#34;\u0026gt;the layoutsettings\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;data\u0026#34;\u0026gt;data object\u0026lt;/param\u0026gt; public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { // Your code here return await Task.FromResult(layoutSettings); } } Register the PdfHandler implementation in Startup.cs\nAdd the following line\nservices.AddTransient\u0026lt;ICustomPdfHandler, PdfHandler\u0026gt;(); You should add it above the registration of your application\nservices.AddTransient\u0026lt;ICustomPdfHandler, PdfHandler\u0026gt;(); // Altinn App implementation service (The concrete implementation of logic from Application repository) services.AddTransient\u0026lt;IAltinnApp, AppLogic.App\u0026gt;(); Your custom implementation will now be injected into the PdfService implementation and be called during the Pdf generation process. When adding a custom PdfHandler you also need the using Altinn.App.AppLogic.Print; statement.\nCustom code in FormatPdf method\nThis the old way when you have your code directly in the overridden FormatPdf method in App.cs in your application.\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { // You have code here... } Create a new class PdfHandler.cs and have it implement the ICustomPdfHandler interface\nMove your custom code to the FormatPdf method of the new class. You should then have a implementation similar to the example in step 1.1 above:\npublic class PdfHandler : ICustomPdfHandler { public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { // Your code here return await Task.FromResult(layoutSettings); } } 2. Obsolete method GetOptionId removed from App/AppBase/IAltinnApp In version 4.24.0 we introduced a new way of supporting dynamic options making the GetOptionId methods in obsolete. The methods have now been removed and you should use the new way of implementing options as described in the documentation\nWhen you update you app you should then remove the following from App.cs as this method is removed from AppBase.cs:\n/// \u0026lt;inheritdoc /\u0026gt; #pragma warning disable CS0672 // Member overrides obsolete member public override Task\u0026lt;AppOptions\u0026gt; GetOptions(string id, AppOptions options) #pragma warning restore CS0672 // Member overrides obsolete member { return Task.FromResult(options); } 3. Obsolete method RunAppEvent removed from App/AppBase/IAltinnApp The RunAppEvent method is a old construct for hooking into various application events. This have been made obsolete by having concrete method overrides for each type of event as described in the documentation. The RunAppEvent method was passed in an AppEventType enum which specified the type of event that was fired. You would then need to have code checking the type and performing the logic needed. The table below shows the old enum values and their corresponding new methods that should be used instead.\nEnum Corresponding method Calculation RunProcessDataRead or RunProcessDataWrite Instantiation RunDataCreation ValidateInstantiation RunInstantiationValidation Validation RunDataValidation DataRetrieval RunProcessDataRead BeforeProcessChange OnStartProcess AfterProcessChange OnEndProcess AppModelCreation CreateNewAppModel The AppEventType.cs has been removed. This was referenced and used in App.cs - both the using reference and usage needs to be removed.\nDelete the following:\nusing Altinn.App.Common.Enums; and\n/// \u0026lt;summary\u0026gt; /// Run app event /// \u0026lt;/summary\u0026gt; /// \u0026lt;remarks\u0026gt;DEPRECATED METHOD, USE EVENT SPECIFIC METHOD INSTEAD\u0026lt;/remarks\u0026gt; /// \u0026lt;param name=\u0026#34;appEvent\u0026#34;\u0026gt;The app event type\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;model\u0026#34;\u0026gt;The service model\u0026lt;/param\u0026gt; /// \u0026lt;param name=\u0026#34;modelState\u0026#34;\u0026gt;The model state\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;True if the event was handled\u0026lt;/returns\u0026gt; public override async Task\u0026lt;bool\u0026gt; RunAppEvent(AppEventType appEvent, object model, ModelStateDictionary modelState = null) { _logger.LogInformation($\u0026#34;RunAppEvent {appEvent}\u0026#34;); return await Task.FromResult(true); } The RunAppEventmethod should be replaced with the appropriate methods as described above.\n4. Obsolete methods RunCalculation removed from AppBase/IAltinnApp In version 4.7.0 the RunCalculation method was replaced with the methods RunProcessDataRead and RunProcessDataWrite. RunCalculation has now been removed and those that have code in this method needs to move this to either RunProcessDataRead or RunProcessDataWrite.\nThe process to update is:\nAdd the DataProcessing folder and DataProcessingHandler class from our app template to your app. Update App.cs. Add a class field for DataProcessingHandler and copy new methods (RunProcessDataRead and RunProcessDataWrite) from App.cs Move logic from calculation handler to DataProcessingHandler Remove RunCalculation method from App.cs Remove CalculationHandler when code has been moved to DataProcessingHandler. Compile and test your app. "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v6/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v6.0.0.",
	"content": "Altinn.App.* librarires target .Net 6 now, which requires that the application does the same.\nIn addition, all references to app and platform services have been moved from Startup.cs and should be replaced with two method calls.\nFollow the instructions below to ensure that the app is compatible with version 6 of the Altinn.App.* packages.\nUpdate target framework and package dependencies\nInstall .Net 6 SDK before you start changing code.\nNavigate to you application repository and find App.csproj in the App folder.\nUpdate target framework to .Net 6 by replacing\n\u0026lt;TargetFramework\u0026gt;net5.0\u0026lt;/TargetFramework\u0026gt; with\n\u0026lt;TargetFramework\u0026gt;net6.0\u0026lt;/TargetFramework\u0026gt; In the same file, update the Altinn.App.* package references to version 6.0.0.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;6.0.0\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;6.0.0\u0026#34; /\u0026gt; Update Dockerfile to use .Net 6 images\nThe Dockerfile can be found in the root folder of the application repository.\nUpdate build image by replacing\nFROM mcr.microsoft.com/dotnet/sdk:5.0-alpine AS build with\nFROM mcr.microsoft.com/dotnet/sdk:6.0-alpine AS build And update the runtime image by replacing\nFROM mcr.microsoft.com/dotnet/aspnet:5.0-alpine AS final with\nFROM mcr.microsoft.com/dotnet/aspnet:6.0-alpine AS final Update program.cs\nThe structure of program.cs has changed for dot net 6. Copy code from this file.\nAdd custom service referances\nIf you have already added custom services and other changes to startup.cs and program.cs you need to add it to program.vs\nDelete startup.cs\nThis is no longer needed\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v7/breaking-changes/",
	"title": "Breaking changes",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over breaking changes introdusert i App Nuget-pakker i v7.0.0.",
	"content": "If your application still is on version v5 or lower you should read the breaking changes guides until your application is updated to v6.\rUpdating Altinn.App.* PackageReferences from v6 to v7 As mentioned here we have moved the code around and reduced the number of nugets to two.\nTo upgrade from v6 nuget to v7 nugets the Altinn.App.* PackageReferences in App/App.csproj needs to be changed from:\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;6.0.2\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;6.0.2\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;6.0.2\u0026#34; /\u0026gt; \u0026lt;!-- Additional PackageReferences --\u0026gt; \u0026lt;/ItemGroup\u0026gt; to\n\u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;7.0.0\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml\u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Core\u0026#34; Version=\u0026#34;7.0.0\u0026#34; /\u0026gt; \u0026lt;!-- Additional PackageReferences --\u0026gt; \u0026lt;/ItemGroup\u0026gt; Once you or your IDE has completed the dotnet restore process your code will have multiple compilation warnings. Work your way through the rest of this page and you will remove them one at a time.\nUpgrading Program.cs It\u0026rsquo;s highly recommended to follow the migration guide to v6 if your application still hasn\u0026rsquo;t been upgraded to v6 from v4 or v5.\nIn previous versions Altinn provided code and registration of custom/override services which were hard to separate. As an attempt to make it easier to see customer provided services, we have extracted most of our code and introduced a new method at the top of Program.cs\nSteps:\nIdentify the custom services your application has registered in Program.cs. Take a note of these as we will have to register them again later. Copy and paste the version 7 of Program.cs from our template at altinn/app-template-dotnet into your App/Program.cs (replacing existing code) Register your apps custom services from step 1 in the method RegisterCustomAppServices Replacing or upgrading old classes to implement new Interfaces Upgrade and register DataProcessingHandler Custom logic while performing DataWrite or DataRead are from v7 handled by registering a service class implementing Altinn.App.Core.Features.DataProcessing.IDataProcessor\nIf your App/logic/DataProcessing/DataProcessingHandler.cs is similar to the following code, you can delete the file and move on Replace InstantiationHandler.cs and register new service.\nusing System; using System.Threading.Tasks; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.DataProcessing { public class DataProcessingHandler { public async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data) { return await Task.FromResult(false); } public async Task\u0026lt;bool\u0026gt; ProcessDataWrite(Instance instance, Guid? dataId, object data) { return await Task.FromResult(false); } } } If you have custom code in this class complete the steps below:\nCreate a new class named DataProcessor in the folder App/logic/DataProcessing, make the class implement the interface Altinn.App.Core.Features.IDataProcessor. The file should now look something like this: using System; using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.DataProcessing; public class DataProcessor : IDataProcessor { public async Task\u0026lt;bool\u0026gt; ProcessDataRead(Instance instance, Guid? dataId, object data) { } public async Task\u0026lt;bool\u0026gt; ProcessDataWrite(Instance instance, Guid? dataId, object data) { } } Note that you might have to add the async keyword if they aren\u0026rsquo;t added by default. You only need to add them if you do async calls within your code. Move your code from the file App/logic/DataProcessing/DataProcessingHandler.cs to the file you just created. Register DataProcessor in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IDataProcessor, DataProcessor\u0026gt;(); // Other custom services } Remember to add the necessary usings. (In VSC you should be able to use Ctrl + . (windows-version with C# plugin installed) to get using-suggestions) Delete the old DataProcessingHandler.cs file Replace InstantiationHandler.cs and register new service The logic that previously was defined in App/logic/InstantiationHandler.cs is now defined by implementing two interfaces\nIInstantiationProcessor is used to do custom data/instance manipulation during instantiation. Replaces the method DataCreation in InstantiationHandler IInstantiationValidator is used to do custom validation during Instantiation. Replaces the method RunInstantiationValidation in InstantiationHandler If your App/logic/InstantiationHandler.cs looks like the code below, you have no custom code here and can delete the class now and move on to Upgrade ValidationHandler.cs and register new service\nusing System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Services.Interface; using Altinn.App.Services.Models.Validation; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic { public class InstantiationHandler { private IProfile _profileService; private IRegister _registerService; public InstantiationHandler(IProfile profileService, IRegister registerService) { _profileService = profileService; _registerService = registerService; } public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { return await Task.FromResult((InstantiationValidationResult)null); } public async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await Task.CompletedTask; } } } If you have custom code in the method DataCreation complete these steps:\nCreate a new Class named InstantiationProcessor.cs in App/logic/DataProcessing and implement the interface Altinn.App.Core.Features.IInstantiationProcessor. The class can be named or placed where you like, this is only a suggestion. The file should look something like this now: using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.DataProcessing; public class InstantiationProcessor : IInstantiationProcessor { public async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { } } Note that you might have to add the async keyword if they aren\u0026rsquo;t added by default. You only need to add them if you do async calls within your code. Move all the code from DataCreation in ÌnstantiationHandler.cs into the method DataCreation in the class you just created. Register InstantiationProcessor in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IInstantiationProcessor, InstantiationProcessor\u0026gt;(); // Other custom services } Remember to add the necessary usings. If you have custom code in the method RunInstantiationValidation complete the steps below, if not delete App/logic/InstantiationHandler.cs and move on to Upgrade ValidationHandler.cs and register new service:\nCreate a new Class named InstantiationValidator.cs in App/logic/Validation and implement the interface Altinn.App.Core.Features.IInstantiationValidator. The class can be named or placed where you like, this is only a suggestion. The file should look something like this now: using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.App.Core.Models.Validation; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.Validation; public class InstantiationValidator : IInstantiationValidator { public async Task\u0026lt;InstantiationValidationResult\u0026gt; Validate(Instance instance) { } } Move all the code from RunInstantiationValidation in ÌnstantiationHandler.cs into the method Validate in the class you just created. Register InstantiationValidator in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IInstantiationValidator, InstantiationValidator\u0026gt;(); // Other custom services } Remember to add the necessary usings. You can now delete the file App/logic/InstantiationHandler.cs\nUpgrade ValidationHandler.cs and register new service Custom data and task validation is in v7 handled by registering a service class implementing Altinn.App.Core.Features.IInstanceValidator.\nIf your App/logic/Validation/ValidationHandler.cs looks like the code below, you have no custom code and can delete the file and move on to Upgrading custom PdfFormatting.\nusing System.Threading.Tasks; using Altinn.Platform.Storage.Interface.Models; using Microsoft.AspNetCore.Http; using Microsoft.AspNetCore.Mvc.ModelBinding; namespace Altinn.App.AppLogic.Validation { public class ValidationHandler { private IHttpContextAccessor _httpContextAccessor; public ValidationHandler(IHttpContextAccessor httpContextAccessor = null) { _httpContextAccessor = httpContextAccessor; } public async Task ValidateData(object data, ModelStateDictionary validationResults) { await Task.CompletedTask; } public async Task ValidateTask(Instance instance, string taskId, ModelStateDictionary validationResults) { await Task.CompletedTask; } } } If you have custom code here complete the steps below:\nCreate a new class named InstanceValidator in the folder App/logic/Validation, make the class implement the interface Altinn.App.Core.Features.IInstanceValidator. The file should now look something like this: using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.Platform.Storage.Interface.Models; using Microsoft.AspNetCore.Mvc.ModelBinding; namespace Altinn.App.AppLogic.Validation; public class InstanceValidator : IInstanceValidator { public async Task ValidateData(object data, ModelStateDictionary validationResults) { } public async Task ValidateTask(Instance instance, string taskId, ModelStateDictionary validationResults) { } } Move the code in ValidateData method in the old class ValidatorHandler to the new one in InstanceValidator class. Move the code in ValidateTask method in the old class ValidatorHandler to the new one in InstanceValidator class. Register InstanceValidator in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IInstanceValidator, InstanceValidator\u0026gt;(); // Other custom services } Remember to add the necessary usings. Delete the ValidationHandler.cs file. Upgrading Custom PDF formatting logic In previous versions dynamic customization was handled by registering a service implementing ICustomPdfHandler. In v7 this is done by registering a service implementing Altinn.App.Core.Features.Pdf.IPdfFormatter.\nIf your App/logic/Pdf/PdfHandler.cs looks like the following code, you have no custom code and can delete the file and move on to Updating PageOrder logic\nusing System.Threading.Tasks; using Altinn.App.Common.Models; using Altinn.App.PlatformServices.Interface; namespace Altinn.App.AppLogic.Print { public class PdfHandler: ICustomPdfHandler { public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await Task.FromResult(layoutSettings); } } } If not, complete the steps below:\nCreate a new class named PdfFormatter in the folder App/logic/Pdf. Make the class implement the interface Altinn.App.Core.Features.IPdfFormatter. The file should new look something like this: using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.App.Core.Models; namespace Altinn.App.AppLogic.Print { public class PdfHandler: IPdfFormatter { public async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { } } } Move youre code from ICustomPdfHandler to the newly created PdfFormatter class. Register PdfFormatter in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IPdfFormatter, PdfFormatter\u0026gt;(); // Other custom services } Remember to add the necessary usings. Delete the old file Remove the transient service registration of the old class from Program.cs. Should look something like this: services.AddTransient\u0026lt;ICustomPdfHandler, PdfHandler\u0026gt;(); (remove it by deleteing the line) Upgrading PageOrder.cs In v5 of the nugets tracks or pageorder was extracted in a non-breaking way from App.cs. The old way was deprecated in v6 and now removed in v7.\nThe new way of defining page order in v5 has not really changed in v7, but some interfaces have been moved to a different namespace.\nIf you don\u0026rsquo;t have any classes implementing IPageOrder, you can safely move on to Moving code form App.cs and removing it\nIf you do have a class implementing IPageOrder here are some changes in namespace that might be helpful to know:\nThe namespace for IPageOrder has changed from Altinn.App.Services.Interfaces to Altinn.App.Core.Features.PageOrder The namespace for AppIdentifier has changed from Altinn.App.PlatformSerices.Models to Altinn.App.Core.Models The namespace for IAppResources has changed from Altinn.App.PlatformSerices.Interface Altinn.App.Core.Interface Moving eFormidling code This next chapter only applies to applications which integrates with eFormidling. If yours don\u0026rsquo;t you can move on to Moving code from App.cs and removing it\nTo determine if your app is integrated against eFormidling, check if you have defined the method GenerateEFormidlingMetadata defined in App/logic/App.cs\nMove code from GenerateEFormidlingMetadata in App.cs Create a new class named EFormidlingMetadata in the folder App/logic/EFormidling. You can name and place the file whatever and wherever you like, this is just a suggestion. Make the newly created class implement the interface Altinn.App.Core.EFormidling.Interface.IEFormidlingMetadata. The file should look something like this now: using System.IO; using System.Threading.Tasks; using Altinn.App.Core.EFormidling.Interface; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.logic.EFormidling; public class EFormidlingMetadata : IEFormidlingMetadata { public Task\u0026lt;(string MetadataFilename, Stream Metadata)\u0026gt; GenerateEFormidlingMetadata(Instance instance) { } } Move the code from the method GenerateEFormidlingMetadata in App/logic/App.cs to the method GenerateEFormidlingMetadata in the class you just created. Move code from GetEFormidlingReceivers in App.cs If you have no definition of GetEFormidlingReceivers in App/logic/App.cs, you can move on to Register Eformidling implementation. If it is defined complete the following steps:\nCreate a new class named EFormidlingReceiversin App/logic/EFormidling. You can name and place the file whatever and wherever you like, this is just a suggestion. Make the new class implement the interface Altinn.App.Core.EFormidling.Interface.IEFormidlingReceivers. The file should look something like this now: using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Core.EFormidling.Interface; using Altinn.Common.EFormidlingClient.Models.SBD; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.logic.EFormidling; public class EFormidlingReceivers : IEFormidlingReceivers { public Task\u0026lt;List\u0026lt;Receiver\u0026gt;\u0026gt; GetEFormidlingReceivers(Instance instance) { } } Move the code from the method GetEFormidlingReceivers in App/logic/App.cs to the method GetEformidlingReceivers in the class you just created. Register Eformidling implementation This step depends on the previous steps. Whether your code has custom logic for GetEFormidlingReceivers or not.\nIn the method RegisterCustomAppServices in Program.cs you need to register the eFormidling implementation.\nTo add eFormidling services and your implementation EFormidlingMetadata add this to your RegisterCustomAppServices.\nvoid RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddEFormidlingServices\u0026lt;EFormidlingMetadata\u0026gt;(config); } This will register the default implementation of IEFormidlingReceivers\nIf you have a custom implementation of IEFormidlingReceivers you should add your implementation as the second type parameter:\nvoid RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddEFormidlingServices\u0026lt;EFormidlingMetadata, EFormidlingReceivers\u0026gt;(config); } Moving code from App.cs and removing it As we are going to extract code from App.cs and eventually remove it, there is no need to pay attention to compilation error.\nThe next sections will extract custom code from App.cs, if any, and move it to its new home.\nMoving custom code in RunProcessDataRead and RunProcessDataWrite If RunProcessDataRead and RunProcessDataWrite in App/App.cs looks like the code below, you have no custom code and can safely move on to Moving custom code in RunDataValidation and RunTaskValidation. If not, complete the steps below:\npublic override async Task\u0026lt;bool\u0026gt; RunProcessDataRead(Instance instance, Guid? dataId, object data) { return await _dataProcessingHandler.ProcessDataRead(instance, dataId, data); } public override async Task\u0026lt;bool\u0026gt; RunProcessDataWrite(Instance instance, Guid? dataId, object data) { return await _dataProcessingHandler.ProcessDataWrite(instance, dataId, data); } Move custom code in RunProcessDataRead to the method ProcessDataRead in App/logic/DataProcessing/DataProcessor.cs that was created and registered in the step Upgrade and register DataProcessingHadler Move custom code in RunProcessDataWrite to the method ProcessDataWrite in App/logic/DataProcessing/DataProcessor.cs Moving custom code in RunDataValidation and RunTaskValidation If RunDataValidationand RunTaskValidation looks like the code below, you have no custom code and can safely move on to Moving custom code in RunInstantiationValidation and RunDataCreation. If not, complete the steps below:\npublic override async Task RunDataValidation(object data, ModelStateDictionary validationResults) { await _validationHandler.ValidateData(data, validationResults); } public override async Task RunTaskValidation(Instance instance, string taskId, ModelStateDictionary validationResults) { await _validationHandler.ValidateTask(instance, taskId, validationResults); } Move custom code in RunDataValidation to the method ValidateData in App/logic/Validation/InstanceValidator.cs that you created and registered here Upgrade ValidationHandler.cs and register new service. Move custom code in RunTaskValidation to the method ValidateTask in App/logic/Validation/InstanceValidator.cs Moving custom code in RunDataCreation If RunDataCreation looks like the code below you have no custom code and can safely move on to Moving custom code in RunInstantiationValidation. If not, complete the steps below:\npublic override async Task RunDataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await _instantiationHandler.DataCreation(instance, data, prefill); } If you haven\u0026rsquo;t already: Create a new class named InstantiationProcessor.cs in App/logic/DataProcessing and implement the interface Altinn.App.Core.Features.IInstantiationProcessor. The class can be named or placed where you like, this is only a suggestion. The file should look something like this now: using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.DataProcessing; public class InstantiationProcessor : IInstantiationProcessor { public async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { } } Move custom code in DataCreation to the method DataCreation in App/logic/DataProcessing/InstantiationHandler.cs that you created and registered here Replace InstantiationHandler.cs and register new service Register InstantiationProcessor in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IInstantiationProcessor, InstantiationProcessor\u0026gt;(); // Other custom services } Remember to add the necessary usings. Moving custom code in RunInstantiationValidation If RunInstantiationValidation looks like the code below, you have no custom code and can safely move on to Moving custom code in RunProcessTaskEnd. If not, complete the steps below:\npublic override async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { return await _instantiationHandler.RunInstantiationValidation(instance); } If you haven\u0026rsquo;t already: Create a new Class named InstantiationValidator.cs in App/logic/Validation and implement the interface Altinn.App.Core.Features.IInstantiationValidator. The class can be named or placed wherever you like, this is only a suggestion. The file should look something like this now: using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.App.Core.Models.Validation; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.Validation; public class InstantiationValidator : IInstantiationValidator { public async Task\u0026lt;InstantiationValidationResult\u0026gt; Validate(Instance instance) { } } Move all the code from RunInstantiationValidation in ÌnstantiationHandler.cs into the method Validate in the class you just created. Register InstantiationValidator in the method RegisterCustomAppServices App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IInstantiationValidator, InstantiationValidator\u0026gt;(); // Other custom services } Remember to add the necessary usings. Moving custom code in RunProcessTaskEnd If RunProcessTaskEnd looks like the code below, you have no custom code and can safely move on to Moving custom code in GetPageOrder. If not, complete the steps below:\npublic override async Task RunProcessTaskEnd(string taskId, Instance instance) { await Task.CompletedTask; } Create a new class implementing the Interface Altinn.App.Core.Features.IProcessTaskEnd. You can name and place this class wherever you like, but as a suggestion you can create and place it in the folder App/logic/TaskProcessors and name the file TaskProcessor. The class should look something like this after the interface is implemented: using System.Threading.Tasks; using Altinn.App.Core.Features; using Altinn.Platform.Storage.Interface.Models; namespace Altinn.App.AppLogic.TaskProcessors; public class ProcessTaskEnd: IProcessTaskEnd { public Task End(string taskId, Instance instance) { return Task.CompletedTask; } } Move code from RunProcessTaskEnd to the method HandleTaskEnd in the class implementing IProcessTaskEnd Register your custom implementation of IProcessTaskEnd in the method RegisterCustomAppServices inside App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IProcessTaskEnd, ProcessTaskEnd\u0026gt;(); // Other custom services } Remember to add the necessary usings. Moving custom code in GetPageOrder If GetPageOrder in App/logic/App.cs is not present, you have no custom code and can safely move on the Removing App.cs. If not, complete the steps below:\nCreate a new class implementing the interface Altinn.App.Core.Features.IPageOrder. You can name and place this class wherever you like in your project, but a suggestion is to name it PageOrder and place it in the folder App/logic/PageOrder. The file should look something like this now: using System.Collections.Generic; using System.Threading.Tasks; using Altinn.App.Models; using Altinn.App.Core.Features; using Altinn.App.Core.Interface; using Altinn.App.Core.Models; namespace Altinn.App.AppLogic.PageOrder; public class PageOrder : IPageOrder { public async Task\u0026lt;List\u0026lt;string\u0026gt;\u0026gt; GetPageOrder(AppIdentifier appIdentifier, InstanceIdentifier instanceIdentifier, string layoutSetId, string currentPage, string dataTypeId, object formData) { } } Move the code from GetPageOrder to the mehod GetPageOrder in the class you just created. Register your custom implementation of IPageOrder in the mehtod RegisterCustomAppServices inside App/Program.cs void RegisterCustomAppServices(IServiceCollection services, IConfiguration config) { services.AddTransient\u0026lt;IPageOrder, PageOrder\u0026gt;(); // Other custom services } Remember to add the necessary usings. Removing App.cs Now all your custom code should be moved out of App.cs. Take a look in the file and check if there is any code left that you need to move.\nSee the old default App.cs here\nIf you don\u0026rsquo;t see any code worth keeping, go ahead and delete the file App.cs. All the logic Altinn used to have in this file, is moved elsewhere in our code and should not leak into your application code.\nNoteable namespace changes This is truly not a complete list of alle the changes to namespace we have done in v7, for that see the actual PR on Github\nThe following list is some of the namespaces that have changed that we think will affect most of the applications:\nInterfaces that service owners naturally overrides/customize is moved from Altinn.App.PlatformServices.Interfaces to Altinn.App.Core.Features Altinn.App.Common.Models namespace is moved to Altinn.App.Core.Models Altinn.App.PlatformServices.Interface.ICustomPdfHandler interface is moved and renamed to: Altinn.App.Core.Features.Pdf.IPdfFormatter Recomended plugin for Visual Studio Code There are a lot of changes to namespaces so we strongly recommend using Visual Studio Code with the C# plugin installed. This will give you code help for importing and locating new or changed interfaces.\nPlugin information: Name: C# Id: ms-dotnettools.csharp Description: C# for Visual Studio Code (powered by OmniSharp). Publisher: Microsoft VS Marketplace Link: https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/breaking-changes/",
	"title": "Breaking changes",
	"tags": [],
	"description": "Oversikt over breaking changes introdusert i deployment i v1.1.0",
	"content": "Helm chart flyttet til eksternt repository. Følg migreringsguiden\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/breaking-changes/",
	"title": "Breaking changes",
	"tags": [],
	"description": "Oversikt over breaking changes introdusert i deployment i v2.0.0",
	"content": " Endring på navnet til deployment i kubernetes fører til en nedetid opp til tiden applikasjonen bruker på å starte Standard antall replikas ved start er endret fra 1 til 2 og autoskalering påskrudd som standard (min: 2, max: 10) Hvis din applikasjon kun kan ha en replika må overstyres i deployment/values.yaml deployment: replicaCount: 1 autoscaling: enabled: false "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/build/",
	"title": "build",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/case/",
	"title": "case",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/confirmation/",
	"title": "confirmation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/datamodel/",
	"title": "datamodel",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/dataprosessering/",
	"title": "dataprosessering",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dataprocessing/",
	"title": "Dataprosessering",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer og annen dataprosessering?",
	"content": "Dataprosessering kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Dataprosessering kan være kan være rent matematiske kalkuleringer, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nDataprosessering kjøres hver gang data lagres og når data hentes ut fra API. Med auto-lagring på (dette er standard) vil dataprosessering kjøres hver gang en bruker har gjort en endring.\nFor å sikre optimal opplevelse og kontroll er applikasjonstemplaten to forskjellige hendelser hvor logikk kan plasseres.\nProcessDataWrite kjøres når data lagres ProcessDataRead kjøres når data leses fra databasen VIKTIG: Når en dataprosessering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn. For å gjøre dette, må ProcessDataWrite-metoden returnere true om det er noen av dataene som har blitt oppdatert. Hvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\rv4, v5, v6\rDataprosessering kodes i C#, i filen DataProsessingHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nEksempel på kode fra app som prosesserer og populerer forskjellige data under lagring.\npublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite( Instance instance, Guid? dataId, object data) { bool edited = false; if (data is SoknadUnntakKaranteneHotellVelferd model) { string org = instance.Org; string app = instance.AppId.Split(\u0026#34;/\u0026#34;)[1]; int partyId = int.Parse(instance.InstanceOwner.PartyId); Guid instanceGuid = Guid.Parse(instance.Id.Split(\u0026#34;/\u0026#34;)[1]); // handling mapping of multiple choice velferdsgrunner if (!string.IsNullOrEmpty(model.velferdsgrunner?.sammenstilling)) { model.velferdsgrunner.helseproblemer = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;helseproblemer\u0026#34;); model.velferdsgrunner.barnefodsel = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnefodsel\u0026#34;); model.velferdsgrunner.begravelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;begravelse\u0026#34;); model.velferdsgrunner.naerstaaende = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;naerstaaende\u0026#34;); model.velferdsgrunner.adopsjon = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;adopsjon\u0026#34;); model.velferdsgrunner.sarligeOmsorg = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;sarligeOmsorg\u0026#34;); model.velferdsgrunner.barnAlene = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnAlene\u0026#34;); model.velferdsgrunner.hjemmeeksamen = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;hjemmeeksamen\u0026#34;); model.velferdsgrunner.arbeidunntak = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;arbeidunntak\u0026#34;); model.velferdsgrunner.andreVelferdshensyn = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;); model.velferdsgrunner.andreVelferdshensynBeskrivelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;) ? model.velferdsgrunner.andreVelferdshensynBeskrivelse : null; edited = true; } else { model.velferdsgrunner = null; } // set data for receipt if not set if (string.IsNullOrEmpty(model.applogic?.altinnRef)) { model.applogic ??= new Applogic(); Party party = await _registerService.GetParty( int.Parse(instance.InstanceOwner.PartyId)); model.applogic.avsender = $\u0026#34;{instance.InstanceOwner.PersonNumber}-{party.Name}\u0026#34;; model.applogic.altinnRef = instance.Id.Split(\u0026#34;-\u0026#34;)[4]; } } return await Task.FromResult(edited); } v7\rI versjon 7 har vi endret måten preutfylling med egendefinert kode gjøres på. Vi benytter nå dependency injection i stedet for overstyring av metoder. Hvis du tidligere plasserte koden din i ProcessDataRead og ProcessDataWrite metodene in DataProcessingHandler.cs klassen så vil du erfare at det er mer eller mindre det samme som nå gjøres.\nOpprett en klasse som implementerer IDataProcessor grensesnittet som ligger i Altinn.App.Core.Features.DateProcessing navnerommet.\nDu kan navngi og plassere filene i den mappestrukturen du selv ønsker i prosjektet ditt. Men vi anbefaler at du benytter meningsfulle navnerom som i et hvilket som helst annet .Net prosjekt. Eksempel på kode fra app som prosesserer og populerer forskjellige data under lagring. public async Task\u0026lt;bool\u0026gt; ProcessDataWrite( Instance instance, Guid? dataId, object data) { bool edited = false; if (data is SoknadUnntakKaranteneHotellVelferd model) { string org = instance.Org; string app = instance.AppId.Split(\u0026#34;/\u0026#34;)[1]; int partyId = int.Parse(instance.InstanceOwner.PartyId); Guid instanceGuid = Guid.Parse(instance.Id.Split(\u0026#34;/\u0026#34;)[1]); // handling mapping of multiple choice velferdsgrunner if (!string.IsNullOrEmpty(model.velferdsgrunner?.sammenstilling)) { model.velferdsgrunner.helseproblemer = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;helseproblemer\u0026#34;); model.velferdsgrunner.barnefodsel = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnefodsel\u0026#34;); model.velferdsgrunner.begravelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;begravelse\u0026#34;); model.velferdsgrunner.naerstaaende = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;naerstaaende\u0026#34;); model.velferdsgrunner.adopsjon = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;adopsjon\u0026#34;); model.velferdsgrunner.sarligeOmsorg = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;sarligeOmsorg\u0026#34;); model.velferdsgrunner.barnAlene = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;barnAlene\u0026#34;); model.velferdsgrunner.hjemmeeksamen = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;hjemmeeksamen\u0026#34;); model.velferdsgrunner.arbeidunntak = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;arbeidunntak\u0026#34;); model.velferdsgrunner.andreVelferdshensyn = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;); model.velferdsgrunner.andreVelferdshensynBeskrivelse = model.velferdsgrunner.sammenstilling.Contains(\u0026#34;annet\u0026#34;) ? model.velferdsgrunner.andreVelferdshensynBeskrivelse : null; edited = true; } else { model.velferdsgrunner = null; } // set data for receipt if not set if (string.IsNullOrEmpty(model.applogic?.altinnRef)) { model.applogic ??= new Applogic(); Party party = await _registerService.GetParty( int.Parse(instance.InstanceOwner.PartyId)); model.applogic.avsender = $\u0026#34;{instance.InstanceOwner.PersonNumber}-{party.Name}\u0026#34;; model.applogic.altinnRef = instance.Id.Split(\u0026#34;-\u0026#34;)[4]; } } return await Task.FromResult(edited); } Registrer din implementering i Program.cs klassen services.AddTransient\u0026lt;IDataProcessor, DataProcessor\u0026gt;(); Dette sørger for at din kode er kjent for applikasjonen og at koden blir kjørt når den skal. "
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/debug/",
	"title": "Debugging av app",
	"tags": [],
	"description": "Når man kjører appene lokalt kan man debugge ved hjelp av ulike verktøy.",
	"content": "Følgende beskrivelse forutsetter at du har clonet applikasjonen fra Altinn Studio Repositories og har filene liggende på lokal harddisk.\nDebugging i Visual Studio Code For å debugge applikasjonen lokalt må du åpne applikasjonsprosjektet i Visual Studio Code. Velg åpne folder og bla deg frem til hvor repostoriet er lagret på din maskin.\nVelg debugging knappen til venstre i vertikal meny.\nDet er to måter å starte debugging av en applikasjon lokalt:\nStarte appen fra Visual Studio Code (.NET Core Launch) Denne metoden er den enkleste. Her vil Visual Studio Code starte applikasjonen og koble seg til i en og samme prosess\nVelg .NET Core Launch og trykk på den grønne \u0026ldquo;play\u0026rdquo; knappen.\nApplikasjonen vil da starte og han vil spørre om du skal starte en browser. Velg bare close.\nÅpne et browservindu og gå til http://local.altinn.cloud (forutsetter at du har startet lokal utviklingsplattform).\nStarte appen fra commando vindu Dette forutsetter at du har startet applikasjonen allerede. Gå til folderen hvor applikasjonen ligger og kjør kommando for å starte dotnet prosessen.\nI Visual Studio Code ha åpnet folderen med applikasjonsprosjektet. Attach deg til prosessen som heter Altinn.App.exe\nLegg til Breakpoints og analysere kode Sett breakpoints i code der du vil at debugger skal stoppe\nDer debugger stopper kan du analysere lokale verdier på objekter for å finne ut hvordan kode fungerer og eventuelt finne feil.\nLes mer om debugging i Visual Studio Code i dokumentasjonen til code.\nEndre frontend-versjon Hvis du har et lokalt utviklingsmiljø for frontend-applikasjonen, eller om du ønsker å teste med en spesifikk versjon av frontend, kan dette gjøres ved å endre den kjørende frontend-versjonen fra lenken på forsiden av local.altinn.cloud:\nBEMERK: Dette virker bare dersom du har beholdt standardstien for lasting av frontend-applikasjonen sin JavaScript-fil in Index.cshtml-filen i appen du jobber med. Om du har endret til å bruke en annen sti, vil dette overstyre eventuelle endringer du gjør via local.altinn.cloud.\nSe og lagre redux tilstandshistorikk Frontend-applikasjonen bruker redux til å holde styr på tilstandsendringer. For enkelte typer feil i frontend-applikasjonen kan historikken fra disse tilstandsendringene være veldig nyttig for å feilsøke og fikse et problem som ellers kan være vanskelig å reprodusere. Denne tilstandshistorikken gjør det mulig å spole frem og tilbake i tid, og lagrer rekkefølgen på alt du har gjort i applikasjonen.\nBEMERK: Dette virker bare i frontend-versjoner fra 3.50.5 og nyere, eller ved lasting fra et lokalt utviklingsmiljø.\nTilstandshistorikken inneholder alle tilstandsendringer i applikasjonen (hvilket inkluderer alt du har skrevet, og alle endringer du har gjort siden siden ble lastet). Ikke lagre eller send denne historikken dersom du jobber med sensitiv informasjon.\rStart med å installere Redux Devtools-utvidelsen i nettleseren din (Chrome eller Firefox)\nBruk applikasjonen som normalt. Når problemet du vil lagre tilstandshistorikk for har inntruffet, åpne utviklerverktøyene i nettleseren din (trykk F12).\nGå til Redux-flaket i utviklerverktøyene. Her pleier applikasjonsinstansen din å bli automatisk valgt, og visningen ligner på denne:\nKlikk eksport-knappen nederst i venstre hjørne for å lagre tilstandshistorikken: Legg ved den eksporterte filen når du oppretter en feilrapport, eller send filen til en utvikler\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/pre-post-hooks/",
	"title": "Definer egendefinerte prosess hooks",
	"tags": [],
	"description": "Definer egendefinert kode som skal kjøres før eller etter en task er startet eller avsluttet",
	"content": "Funksjonaliteten beskrevet på denne siden krever minimum version 7 av Altinn nugets.\rDet er mulig å skrive egendefinert kode som eksekveres når en task i prosessen starter, avsluttes eller forlates. Alle registrerte klasser vil bli eksekvert for hver task som starter eller avsluttes, det er derfor viktig at du tar høyde for dette hvis du kun øsnker at koden skal kjøres i forbindelse med spesifike tasker.\nKjør egendefinert kode før en task starter For å få egendefinert kode eksekvert når en task i prosessen startes må du opprette en klasse som implementerer Altinn.App.Core.Features.IProcessTaskStart og registrere denne som en transient.\nDet er mulig å legge til flere klasser som implementerer dette interfacet, alle vil ble kjørt for hver gang en task i prosessen starter.\nSe interfacet her\nExecute custom code when tasks is ended For å få egendefinert kode eksekvert når en task i prosessen avsluttes må du opprette en klasse som implementerer Altinn.App.Core.Features.IProcessTaskEnd og registrere denne som en transient.\nDet er mulig å legge til flere klasser som implementerer dette interfacet, alle vil ble kjørt for hver gang en task i prosessen avsluttes (videre til neste steg).\nSe interfacet her\nExecute custom code when tasks are abandoned For å få egendefinert kode eksekvert når en task i prosessen avbrytes må du opprette en klasse som implementerer Altinn.App.Core.Features.IProcessTaskAbandon og registrere denne som en transient.\nDet er mulig å legge til flere klasser som implementerer dette interfacet, alle vil ble kjørt for hver gang en task i prosessen blir avbrutt.\nSe interfacet her\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/definition-of-ready/",
	"title": "Definition of Ready",
	"tags": ["needstranslation"],
	"description": "What needs to be in place before a team starts on a user story/issue",
	"content": "Definition of Ready (DoR) Definition of Ready (DoR) is used to determine whether work on a user stories is ready to be started. It means it\u0026rsquo;s sufficiently well described and understood by the team to a level where they can provide an estimate and what needs to be done in order to complete the story.\nStories at the top of the product backlog that the team will be pulling into the sprint backlog, must be Ready to avoid misunderstandings and wasted time further down the development process. It does not mean it will be described in 100% detail, but good enough - think 80/20 rule.\nThe Product Owner is responsible for putting the features and stories in the backlog. However, the Team must work with the Product Owner during Backlog Refinement to help them get the stories into actionable shape.\nWhile the focus is on user stories, most of these also applies to technical tasks as well, just remove the bullets not needed (user story format, UX, WCAG). Another difference is that the PO is not responsible for bringing the issue to the table, that\u0026rsquo;s on the development team.\nThe following defines our Definition of Ready Short descriptive title Description Consider starting with the format As a [role] I [need] in order to [goal] Consider the INVEST qualities when writing the story Add more details to the story description as needed and as the discussion progresses User experience and other pre-analysis work is done (if big consider this as separate issues) Technical considerations evaluated Performance Scalability Cost (licenses, transactions, resource usage) Data volume Azure resources needed Monitoring and alarms UX/design sketches is provided Security issues discussed and considered WCAG and ELMER requirements are discussed and considered Acceptance criterias is defined and the story is testable Dependecies to other tasks and user stories is considered Discussed with the team Story points added by the team "
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/delegate-scopes/",
	"title": "Delegere API-tilganger til en leverandør",
	"tags": [],
	"description": "Beskrivelse av hvordan tjenesteier kan delegere API-tilganger (scopes) til en underleverandør.",
	"content": "Enkelte tjenesteeiere ønsker at en underleverandør skal kunne agere på vegne av dem, f.eks. leverandører av fagsystemer. For å få til det, så må disse API-tilgangene delegeres til leverandøren ved bruk av Altinn.\nDet er tjenesteeiers ansvar å selv fjerne delegeringene om behovet for tilgang hos leverandør forsvinner.\nDelegering av API-tilganger til leverandør Som en bruker som er nøkkelrolleinnehaver for tjenesteeier (typisk daglig leder aka DAGL), åpne \u0026ldquo;Andre med rettigheter til virksomheten\u0026rdquo;.\nSå må de nødvendige rettighetene gis.\nAltinn tjenesteeier-API: Appinstanser (full tilgang) - gir tilgang til scopes for både read og write. Altinn tjenesteeier-API: Appinstanser (lesetilgang) - gir kun tilgang til read. Fjerning av delegering Delegeringer som er gjort kan også fjernes. Om en leverandør ikke lenger har behov for API-tilganger så er det tjenesteeier sitt ansvar å fjerne disse.\nScopes Delegering gir tilgang til disse scopene for leverandør:\naltinn:serviceowner/instances.read altinn:serviceowner/instances.write "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/deploy/",
	"title": "deploy",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/authorization/designfrontendprocess/",
	"title": "Desgin/Frontend prosess",
	"tags": [],
	"description": "Slik jobber vi med design og frontendutvikling",
	"content": "Bli enig om hovedfunksjonalitet og konsept Oppstart – tverrfaglig (backend, frontend, funksjonell) Skaffe innsikt Presentere case Lande «rammer» for utvikling. Diskutere tverrfaglig: utvikling i Altinn2 eller Altinn 3? kartlegge begrensninger i forhold til migrering? skal funksjonalitet i Altinn 2 videreføres i Altinn 3? UX – konseptskisser Diskutere tverrfaglig Brukerteste konsept Prototype Skissere i Figma - UX Tegne brukerflyt - UX Diskutere tverrfaglig – (teksnisk, frontend, test, funksjonell) Lage prototype - UX Brukerteste prototype – UX Detaljskisse Tegne «ferdig» skisser i figma Diskutere tverrfaglig Identifisere nye komponenter i Designsystemer Oppdatere skisser Definition of Prepared før neste trinn: Overordnet beskrivelse av UI som skal utvikles foreligger Alle designelementer er skissert Beskrive avhengigheter mellom elementer som skal brukes Detaljert beskrivelse av hva som skal utvikles gjennom skjermdumper og beskrivende tekst (funksjonelt design) Beskrive eventuelle uavklarte punkter Feilmeldinger skal være beskrevet QA av skisser opp mot Designsystem – Marianne/Lasse (ansvarlig designsystem) I henhold til overordnet Altinn-design (designsystem-team) Komponenter i Designsystem Lage skisser i Figma av enkelskomponenter til designsystem - UX QA av skisser opp mot Designsystem – Marianne/Lasse (ansvarlig designsystem) Definition of Prepared før neste trinn: Farge, font, navngivning av komponent, hoverover, ikoner, ?, ? Gjennomgått med ansvarlig for designsystem Implementere i Designsystem - frontend Review av kode designkomponenter - annen frontend utvikler Ferdigstille skisser som skal implementeres i frontend Oppdatere skisser Diskutere tverrfaglig – UX, frontend, test, teksnisk Ferdigstille skisser Definition of Prepared før neste trinn: Alle designelementer finnes i skisser Alle komponenter i skissen er designimplementert Forklaring på skisser hvordan de skal fungere, hva skjer når man gjør ulike ting Feilsitusajoner og feilmeldinger skal være beskrevet Implementere skisser Gjennomgang av skisse mellom - UX og frontend Implementere skisser i frontend Review av implementasjon – annen frontendutvikler "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/development/",
	"title": "development",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/",
	"title": "DevOps",
	"tags": [],
	"description": "Hvordan vi gjør DevOps.",
	"content": "\rFullscreen\nDefinition of Ready\rWhat needs to be in place before a team starts on a user story/issue\nRoadmap prosess\rHvordan jobber vi med vår roadmap\nTeams\rVåre DevOps-teams\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/",
	"title": "Apper fra Digdir",
	"tags": [],
	"description": "Dokumentasjon for apper utviklet av Digitaliseringsdirektoratet.",
	"content": "\rBli tjenesteeier\rDokumentasjon av appen for å bli tjenesteeier i Altinn.\nGodkjenning av bruksvilkår for skytjenester fra Altinn\rDokumentasjon av appen for å godkjenne bruksvilkår for Altinn.\nOppgjør etter dødsfall\rDokumentasjon av arkitektur, design, funksjonalitet og apper relatert til oppgjør etter dødsfall.\nBestill tilgang til REST API\rDokumentasjon av appen for å bestille API-nøkler for bruk i Altinn.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/dynamics/",
	"title": "dynamics",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/dynamikk/",
	"title": "dynamikk",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/dynamic/",
	"title": "Dynamikk",
	"tags": [],
	"description": "Hvordan legge til dynamikk?",
	"content": "\r⚠️ Dynamikk er et område under aktiv utvikling. Logikk-filer skrevet i JavaScript fases etterhvert ut og blir erstattet av dynamiske uttrykk. Foreløpig gjelder dette dynamikk for vis/skjul, men etterhvert skal uttrykk også kunne brukes for å utføre beregninger og styre valideringsmeldinger.\nIntroduksjon Dynamikk er hendelser som skjer på klient-siden. Disse kan deles opp i to kategorier:\nBeregning - kjøre beregninger på klient-side, og oppdatere felter med ny verdi Vis/skjul felter - bestemme om felter skal vises eller skjules basert på verdier i skjema. Det er to måter å legge til og endre dynamikkregler for en Altinn App.\nDirekte i Altinn Studio under Lage-fanen. Velg Rediger dynamikk i høyre-menyen. I lokalt utviklingsmiljø ved å jobbe i filen RuleHandler.js som finnes i App/ui-mappen . All dynamikk skrives som funksjoner i JavaScript i RuleHandler-filen. Funksjonene som er definert i denne filen kan videre konfigureres til å kjøres for feltene i skjemaet.\nKoden som definerer beregninger eller regler for vis/skjul bør settes opp slik at den håndterer eventuell feil i input. Blant annet bør de håndtere å motta et tomt felt, eller tekst der man forventer et tall, uten å kræsje. Dersom dynamikken ikke fungerer som forventet, ta en titt på koden som definerer beregninger eller regler for vis/skjul for å se om det er noe feilhåndtering som mangler.\rMERK: for å støtte beregning/vis-skjul felter på eldre nettlesere må man skrive javascript koden man legger i RuleHandler.js i den versjonen av ECMA-script som den aktuelle nettleseren støtter. For IE11 vil dette være ECMA-script 5.\rLegg til/rediger funksjoner for beregninger eller vis/skjul I filen RuleHandler.js er det satt opp 2 javascript-objekter:\nruleHandlerObject - funksjoner for beregninger conditionalRuleHandlerObject - funksjoner med regler for vis/skjul Det er inne i disse at de forskjellige funksjonene skal defineres. I tillegg er det satt opp to hjelpe-objekter (ruleHandlerHelper og conditionalRuleHandlerHelper), hvor man skal sette opp hva slags input de forskjellige funksjonene forventer å få inn. Dette gjør det mulig å konfigurere opp reglene i Altinn Studio senere. For at en funksjon skal være tilgjengelig for å konfigureres som dynamikk, må selve funksjonen være definert i hoved-objektet (ruleHandlerObject eller conditionalRuleHandlerObject), og parametrene den forventer å få inn må være satt opp i det tilhørende hjelpe-objektet.\nStrukturen på hjelpe-objektet vises under:\nvar ruleHandlerHelper = { \u0026lt;name_of_rule\u0026gt;: () =\u0026gt; { return { \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34;, \u0026lt;input_param\u0026gt;: \u0026#34;\u0026lt;description\u0026gt;\u0026#34; ... }; } } Strukturen på hoved-objektet, som inneholder funksjoner som brukes i dynamikk, vises under:\nvar ruleHandlerObject = { \u0026lt;name_of_rule\u0026gt;: (\u0026lt;input_variable_name\u0026gt;) =\u0026gt; { // Do something here // Values from input parameters defined in // helper can be accessed through the object passed // into the rule, f.ex. // \u0026lt;input_variable_name\u0026gt;.\u0026lt;input_param\u0026gt; } } For eksempel, for å lage en regel som returnerer summen av to tall (beregning), vil man trenge følgende kode:\nvar ruleHandlerHelper = { sum: () =\u0026gt; { return { field1: \u0026#34;Field 1 in sum\u0026#34;, field2: \u0026#34;Field 2 in sum\u0026#34; }; } } var ruleHandlerObject = { sum: (data) =\u0026gt; { // Check if data is available if (!data) return; // Check if value from input fields are available // If not, use value 0 in sum data.field1 = data.field1 ? data.field1 : 0; data.field2 = data.field2 ? data.field2 : 0; // return the sum return data.field1 + data.field2; } } Noen standard-metoder for beregniner, med hjelpe-objekt, er satt opp automatisk når app\u0026rsquo;en lages i Altinn Studio. Noen av disse er vist i eksempelet under.\nMethod name Description Parameters Defined in object/helper sum Returnerer summen av 2 verdier value1, value2 ruleHandlerObject/ruleHandlerHelper fullName Returnerer to tekster (fornavn og etternavn) satt sammen med mellomrom mellom. firstName, lastName ruleHandlerObject/ruleHandlerHelper lengthBiggerThan4 Returnerer true dersom verdien den får inn er lengre enn 4 karakterer lang. value conditionalRuleHandlerObject/conditionalRuleHandlerHelper Regler for dynamikk kjøres dersom det har skjedd en endring i input-parametrene til de forskjellige reglene. Funksjonene som da kjøres må kunne håndtere dersom det f.eks. har kommet inn kun 1 av 2 parametre eller lignende.\nEt eksempel på hvordan dette kan gjøres er vist i sum-funksjonen under, hvor man tester hvilke parametre man har fått inn, og setter verdi til 0 på den/de parametre som mangler, sånn at regelen fortsatt fungerer.\nvar ruleHandlerObject = { sum: (obj) =\u0026gt; { obj.value1 = obj.value1 ? +obj.value1 : 0; obj.value2 = obj.value2 ? +obj.value2 : 0; return obj.value1 + obj.value2; }, fullName: (obj) =\u0026gt; { return obj.firstName + \u0026#39; \u0026#39; + obj.lastName; } } var ruleHandlerHelper = { sum: () =\u0026gt; { return { value1: \u0026#34;Value 1\u0026#34;, value2: \u0026#34;Value 2\u0026#34; } }, fullName: () =\u0026gt; { return { firstName: \u0026#34;First name\u0026#34;, lastName: \u0026#34;Last name\u0026#34; }; } } var conditionalRuleHandlerObject = { lengthBiggerThan4: (obj) =\u0026gt; { if (obj.value == null) return false; return obj.value.length \u0026gt;= 4; } } var conditionalRuleHandlerHelper = { lengthBiggerThan4: () =\u0026gt; { return { value: \u0026#34;value\u0026#34; } } } Konfigurere dynamikk for skjema-komponenter Legg til de skjema-komponentene som ønskes i layout. I høyre-menyen, velg å legge til Regler for beregninger eller Regler for vis/skjul felt. Velg en tilgjengelig funksjon som gjør det du ønsker. Legg evt. til en ny funksjon, se beskrivelse over. Sett opp hvilke(t) felt som skal fungere som input til funksjonen - her er det felt i datamodellen som gjelder. Sett opp hvilke(t) felt som skal påvirkes av regelen (skal motta beregnet verdi, eller skal vises/skjules) - her er det skjemakomponent som gjelder. For regler for vis/skjul felt kan man velge flere felter som skal vises/skjules basert på samme regel. Lagre konfigurasjonen. Test at det fungerer som forventet. Eksisterende oppsett ligger synlig i høyre-menyen og kan redigeres/slettes.\nKonfigurasjonen legges i filen App/ui/RuleConfiguration.json. Denne kan også redigeres manuelt ved behov.\nEksempel på bruk av dynamikk i skjema Scenario:\nEn app med skjema som har flere felter for input. En av disse er en radioknapp-gruppe, med valgene \u0026ldquo;Ja\u0026rdquo; og \u0026ldquo;Nei\u0026rdquo;. Avhengig av hva sluttbruker velger her, skal forskjellig innhold vises i skjemaet:\nJa: Et nytt input-felt vises, sammen med ekstra informasjon om hvordan feltet skal fylles ut. Nei: En annen informasjons-tekst vises. Dette kan gjøres ved å legge inn følgende i RuleHandler.js, enten via Rediger dynamikk i Altinn Studio, eller ved å laste ned kildekoden til appen og redigere lokalt.\nvar conditionalRuleHandlerObject = { sjekkVirksomhetIDrift: (obj) =\u0026gt; { return (obj.value \u0026amp;\u0026amp; obj.value === \u0026#34;Ja\u0026#34;); }, sjekkVirksomhetIkkeIDrift: (obj) =\u0026gt; { return (!obj.value || obj.value != \u0026#34;Ja\u0026#34;); } } var conditionalRuleHandlerHelper = { sjekkVirksomhetIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } }, sjekkVirksomhetIkkeIDrift: () =\u0026gt; { return { value: \u0026#34;Verdi\u0026#34; } } } Her har to funksjoner blitt opprettet, som sjekker om verdien er henholdsvis \u0026ldquo;Ja\u0026rdquo; eller ikke. Etter at denne koden er lagt til, kan regelen konfigureres i Altinn Studio. Resultatet vises under.\nDynamikk i repeterende gruppe Det er også mulig å sette opp dynamikk innad i en repeterende gruppe. Dette krever at man først setter opp regelen som vanlig, og så redigerer på oppsettet App/ui/RuleConfiguration.json manuelt. Helt konkret, er det følgende som må endres:\nFor alle inputParams, må man legge til {0} etter gruppe-delen av data-modellen. F.eks. Datamodell.gruppe{0}.felt. Dette erstattes i koden av indeksen til hvert enkelt innslag av den repeterende gruppen. For alle selectedFields (altså feltene som påvirkes av reglen), må man legge til {0} bak felt-id\u0026rsquo;en. F.eks. skjemaFelt1{0} I tillegg må man legge enn en ny egenskap på regelen, repeatingGroup. Denne skal inneholde id\u0026rsquo;en til gruppen i layout-filen. Et eksempel på en regel som er satt opp for repeterende grupper vises under:\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;9f9f2a50-360b-11ea-b69a-8510e2e248b9\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;lengthBiggerThan4\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;Skjemainnhold.personalia.arbeidserfaring{0}.stilling\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Show\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;962e2f60-3797-11ea-bfa5-9922024b4738\u0026#34;: \u0026#34;a-e-4{0}\u0026#34;, \u0026#34;something\u0026#34;: \u0026#34;arbeidsgiver-adresse{0}\u0026#34; }, \u0026#34;repeatingGroup\u0026#34;: { \u0026#34;groupId\u0026#34;: \u0026#34;arbeidserfaring-group\u0026#34;, } } } } } Nøstede repeterende grupper Det er også mulig å sette opp dynamikk for nøstede repeterende grupper. Oppsettet likner på repeterende grupper, men man har med et ektra parameter childGroupId i repeatingGroup-objektet, samt en ekstra indeks-indikator.\nEksempel:\n{ \u0026#34;data\u0026#34;: { \u0026#34;ruleConnection\u0026#34;: {}, \u0026#34;conditionalRendering\u0026#34;: { \u0026#34;hide-nested-group-field\u0026#34;: { \u0026#34;selectedFunction\u0026#34;: \u0026#34;shouldHide\u0026#34;, \u0026#34;inputParams\u0026#34;: { \u0026#34;value\u0026#34;: \u0026#34;someGroup{0}.nestedGroup{1}.someField\u0026#34; }, \u0026#34;selectedAction\u0026#34;: \u0026#34;Hide\u0026#34;, \u0026#34;selectedFields\u0026#34;: { \u0026#34;field\u0026#34;: \u0026#34;the-component-id{0}{1}\u0026#34; }, \u0026#34;repeatingGroup\u0026#34;: { \u0026#34;groupId\u0026#34;: \u0026#34;mainGroup\u0026#34;, \u0026#34;childGroupId\u0026#34;: \u0026#34;subGroup\u0026#34; } } } } } Eksempel med mer kompleks dynamikk Example with more complex dynamics\nScenario: Et skjema med to sett med radioknapper (ja/nei) og en avkrysningsboks.\nNår skjema lastes, er kun det første settet med radioknapper synlig. Hvis brukeren velder Ja, vises det andre settet med radioknapper. Hvis brukeren velger Ja i det andre settet, blir avkrysningsboksen synlig. Hvis brukeren går tilbake til det første settet med radioknapper og velger nei, blir både det andre settet med radioknapper og avkrysningsboksen ikke lenger synlig. Alternativ 1 Dette kan settes opp ved å lage 2 forskjellige betingelser for når feltene skal vises:\nEn betingelse for det andre settet med radioknapper Vises dersom Ja er valgt i det første settet En betingelse for avkrysningsboksen Vises når Ja er valgt i begge sett med radioknapper. Koden for å løse dette kan være:\nvar conditionalRuleHandlerObject = { showField2: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1=== \u0026#34;yes\u0026#34;) { return true; } return false; }, showField3: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.field1 \u0026amp;\u0026amp; obj.field1 === \u0026#34;yes\u0026#34; \u0026amp;\u0026amp; obj.field2 \u0026amp;\u0026amp; obj.field2 === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField2: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34; }; }, showField3: () =\u0026gt; { return { field1: \u0026#34;Field 1\u0026#34;, field2: \u0026#34;Field 2\u0026#34; }; } } Alternativ 2 Dette kan også settes opp ved å bruke den samme betingelsen for å vise både det andre settet med radionkapper og avkrusningsboksen. I tillegg må man da ha en regel som sletter verdien i det andre settet med radioknapper dersom verdien i det første settet settes til Nei:\nvar ruleHandlerObject = { clearField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkValue === \u0026#34;no\u0026#34;) { return \u0026#34;\u0026#34;; } return obj.currentValue; } } var ruleHandlerHelper = { clearField: () =\u0026gt; { return { checkValue: \u0026#34;check against this value\u0026#34;, currentValue: \u0026#34;the current value\u0026#34; } } } var conditionalRuleHandlerObject = { showField: (obj) =\u0026gt; { if (obj \u0026amp;\u0026amp; obj.checkField \u0026amp;\u0026amp; obj.checkField === \u0026#34;yes\u0026#34;) { return true; } return false; } } var conditionalRuleHandlerHelper = { showField: () =\u0026gt; { return { checkField: \u0026#34;check against this value\u0026#34; }; } } Dynamikk i PDF Fra versjon 3.0.0 er det også mulig å legge inn dynamikk for PDF. Dette gjøres i PDF Handler. Her kan man ved hjelp av logikk velge å skjulte felter eller sider i print.\nAppen må inkludere ui/Settings.json filen som her.\nTeknisk er det veldlig likt hvordan man gjør det for validering.\nEksempel nedenfor som skjuler et gitt felt basert på innhold. Komponentene er basert på ID som man finner i layouts filene til skjema.\npublic async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { if (data is Skjema) { Skjema skjema = (Skjema)data; if (skjema?.Innledninggrp9342?.Kontaktinformasjongrp9344?.KontaktpersonNavndatadef2?.value.Contains(\u0026#34;tulling\u0026#34;) == true) { layoutSettings.Components = new Components(); layoutSettings.Components.ExcludeFromPdf = new System.Collections.Generic.List\u0026lt;string\u0026gt;(); layoutSettings.Components.ExcludeFromPdf.Add(\u0026#34;079f205b-c9ea-414d-9983-0d158e833e8a\u0026#34;); } } return await Task.FromResult(layoutSettings); } ``` "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/expose/",
	"title": "Eksponere APIer fra en app",
	"tags": [],
	"description": "Man kan legge til flere API enn det som er definert som standard API for applikasjoner utviklet i Altinn Studio.",
	"content": "Applikasjonene som utvikles i Altinn Studio baserer seg i dag på ASP.NET Core for back-end. Dette gir høy fleksibiltet til å endre og modifisere applikasjonene.\nLegge til API kontroller For å kunne eksponere et nytt API i applikasjonen må det legges til en eller flere API kontrollere.\nNedenfor vises et eksempel fra en API controller som er lagt til i en gitt app. Her settes det opp hvilken path API skal lytte på og logikken.\nusing System; using System.Threading.Tasks; using Microsoft.AspNetCore.Mvc; namespace Altinn.App.Api.Controllers { [ApiController] [Route(\u0026#34;{org}/{app}/CustomApi\u0026#34;)] public class CustomApiController : ControllerBase { [HttpGet(\u0026#34;TimeInfo\u0026#34;)] public async Task\u0026lt;ActionResult\u0026gt; Get() { return Ok(DateTime.Now); } } } Koden kan ses i dette repositoriet.\nI dokumentasjonen til ASP.NET kan du lese flere detaljer om mulighetene for å eksponere API.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_er/",
	"title": "Rollesr fra Enhetsregisteret",
	"tags": [],
	"description": "Denne siden beskriver roller fra Enhetsregisteret som kan benyttes til å gi tilgang til en applikasjon.",
	"content": "I Enhetsregisteret er det offisielle registeret over virksomheter i Norge. I registeret kan man registrere ulike organisasjonsformer og til de ulike typene finnes forskjellige roller.\nNår man velger roller er det derfor viktig å vurdere hvilke typer organisasjoner som skal benytte tjenesten og med det hvilke roller man må knytte til tjenesten for å gi disse tilgang\nNøkkelroller Altinn har definert et sett med nøkkelroller. Dette er roller som vurderes å ha et særskilt og overordnet ansvar for virksomheten. Nøkkelrollene vil tilsammen dekker de fleste organisasjonstypene som finnes og sikre at noen for tilgang tilgang til en gitt applikasjon på vegne av en virksomhet.\nDet bør være en særskilt grunn til f eks å ikke gi Daglig leder tilgang til en applikasjon - dette kan f eks være at tjenesten gir tilgang til personsensitiv data som daglig leder ikke har tjenslig behov for å ha tilgang til. I slike tilfeller bør roller for taushetsbelagte tjenester vurderes istedet, se Innehaver av en nøkkelrolle fra Enhetsregisteret vil også alltid får rollen hovedadministrator og tilgangsstyrer på vegne av virksomheten. Les mer om hva dette er her Daglig leder (DAGL) - kan knyttes til de fleste organisasjonstyper. Styrets leder (STYR) - kan knyttes til alle organisasjonstyper som har et styre. Bestyrende reder(BEST) - knyttes til organisasjonsformen \u0026ldquo;partsrederi\u0026rdquo; Bostyrer (BOBE) - knyttes til organisasjonsformen \u0026ldquo;konkursbo\u0026rdquo; Deltaker med delt ansvar (DTPR) - kan knyttes til organisasjonsformer hvor deltakere har proratarisk ansvar Deltaker med fullt ansvar (DTSO) - kan knyttes til organsiasjonsformer hvor deltakere har solidarisk ansvar Innehaver (INNH) - kan knyttes til organisasjonsformen \u0026ldquo;Enkeltpersonforetak\u0026rdquo; Komplementar (KOMP) - kan knyttes til orgnaisasjonsformen \u0026ldquo;Kommandittselskap\u0026rdquo; Norsk representant for utenlandsk enhet (REPR) - kan knyttes til organisasjonsformen \u0026ldquo;Norsk avdeling av utenlandsk foretak\u0026rdquo; (NUF) Rolle for norskregistert Utenlands foretak Kontaktperson for utenlandsk foretak(KNUF)\nNorsk avdeling av utenlansk foretak (NUF) er i utgangspunktet ikke et norsk selskap, men registreres i ER fordi det har aktivitet i Norge og trenger et organisasjonsnummer. Det er i dag ingen krav til at et NUF må ha registrert en daglig leder og mange har kun registrert en kontaktperson (KNUF) for Enhetsregisteret. Denne rollen har i juridisk sett i utgangspunktet begrensede fullmakter for den Norske avdelingen men kan i mange sammenhenger være den eneste som i praksis kan representere selskapet digital. Hvis dere vet at tjenesten deres benyttes av NUF så bør dere gjøre en vurdering pÃ¥ om det riktig og nødvendig at rollen \u0026ldquo;Kontaktperson for utenlansk foretak\u0026rdquo; (KNUF) også får tilgang til tjenesten.\nØvrige roller fra Enhetsregisteret som kan få tilganger via Altinn Autorisasjon I tillegg til nøkkelroller så finnes flere typer roller som kan registreres på en virksomhet. Det er ansees ikke som naturlig at disse rollene får tilgang til alle tjenesgter på vegne av en virksomhet, men i enkelt tilfeller kan det allikevel være fornuftig. Vurderingen avhenger f eks av\nav hvilken type tjeneste man tilbyr om dette er en tjeneste det er naturlig at rollen utfører applikasjonen gir tilgang til informasjon som denne rollen bør ha tilgang til Følgende øvrige roller hentes fra Enhetsregisteret: Forretningsfører (FFØR) Kontaktperson i kommune (KOMK) Kontaktperson i Administrativ Enhet - offentlig sektor (KEMN) Komplementar (KOMP) Styremedlem (STYR) Nestleder (NEST) Sameiere (SAM) Regnskapsfører (REGN) Revisor (REVI) Varamedlem (VARA) "
},
{
	"uri": "https://docs.altinn.studio/nb/api/events/",
	"title": "Events API",
	"tags": ["api", "translate-to-norwegian"],
	"description": "Platform API for hendelser.",
	"content": "Overview Events are in this context is information about events created by applications or other sources. The event itself is based on the CloudEvent standard and is a small JSON structure containing the most important information of an event. Details are found here.\nThe events APIs are used to access events created by applications in Altinn Apps and other event sources that use Altinn Platform as av \u0026ldquo;event hub\u0026rdquo;.\nSubscription The highly preferred way to use events is to set up a subscription that enables push of events to a webhook-endpoint. This is done through the subcriptions API. This API supports the following consumers\nPersons, authenticated through ID-porten Orgs, authenticated through Maskinporten The subscriptions API is described here as Swagger.\nThe webhook endpoint needs to be able to accept cloud event that is posted through HTTPS to the endpoint URL.\nThe push functionality also supports pushing events to Slack. Other platforms might be added at a later point.\nSearch API The search allows searching for events. The storage of events is limited to 90 days.\nThis is available to be used by the following consumers.\nPersons, authenticated through ID-porten Orgs, authenticated through Maskinporten The API is described in swagger here.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/exclusive-gateways/",
	"title": "Exclusive Gateways",
	"tags": ["gateways", "bpmn", "process", "prosess"],
	"description": "Definer egendefinert kode som avgjør flyt ut av en exclusive gateway",
	"content": "Funksjonaliteten beskrevet på denne siden krever minimum version 7.1.0 av Altinn nugets.\rForutsetninger Applikasjonen din benytter versjon 7.1.0 eller nyere av Altinn nugets En applikasjon med exclusive gateway(s) definert i prosessen sin Eksempel prosess med exclusive gateways \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;bpmn:definitions xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:bpmn=\u0026#34;http://www.omg.org/spec/BPMN/20100524/MODEL\u0026#34; xmlns:bpmndi=\u0026#34;http://www.omg.org/spec/BPMN/20100524/DI\u0026#34; xmlns:dc=\u0026#34;http://www.omg.org/spec/DD/20100524/DC\u0026#34; xmlns:di=\u0026#34;http://www.omg.org/spec/DD/20100524/DI\u0026#34; xmlns:altinn=\u0026#34;http://altinn.no\u0026#34; id=\u0026#34;Altinn_SingleDataTask_Process_Definition\u0026#34; targetNamespace=\u0026#34;http://bpmn.io/schema/bpmn\u0026#34; exporter=\u0026#34;bpmn-js (https://demo.bpmn.io)\u0026#34; exporterVersion=\u0026#34;10.2.0\u0026#34;\u0026gt; \u0026lt;bpmn:process id=\u0026#34;SingleDataTask\u0026#34; isExecutable=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;bpmn:startEvent id=\u0026#34;StartEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_s_t1\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;/bpmn:startEvent\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_s_t1\u0026#34; sourceRef=\u0026#34;StartEvent_1\u0026#34; targetRef=\u0026#34;Task_1\u0026#34; /\u0026gt; \u0026lt;bpmn:task id=\u0026#34;Task_1\u0026#34; name=\u0026#34;Utfylling\u0026#34; altinn:tasktype=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_s_t1\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_t1_g1\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;/bpmn:task\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_t1_g1\u0026#34; sourceRef=\u0026#34;Task_1\u0026#34; targetRef=\u0026#34;Gateway_1\u0026#34; /\u0026gt; \u0026lt;bpmn:exclusiveGateway id=\u0026#34;Gateway_1\u0026#34;\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_t1_g1\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_g1_g2\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_g1_t2\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;/bpmn:exclusiveGateway\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_g1_g2\u0026#34; sourceRef=\u0026#34;Gateway_1\u0026#34; targetRef=\u0026#34;Gateway_2\u0026#34; /\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_g1_t2\u0026#34; sourceRef=\u0026#34;Gateway_1\u0026#34; targetRef=\u0026#34;Task_2\u0026#34; /\u0026gt; \u0026lt;bpmn:task id=\u0026#34;Task_2\u0026#34; name=\u0026#34;Bekreftelse\u0026#34; altinn:tasktype=\u0026#34;confirmation\u0026#34;\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_g1_t2\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_t2_g2\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;/bpmn:task\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_t2_g2\u0026#34; sourceRef=\u0026#34;Task_2\u0026#34; targetRef=\u0026#34;Gateway_2\u0026#34; /\u0026gt; \u0026lt;bpmn:exclusiveGateway id=\u0026#34;Gateway_2\u0026#34;\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_g1_g2\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_t2_g2\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;bpmn:outgoing\u0026gt;Flow_g2_end\u0026lt;/bpmn:outgoing\u0026gt; \u0026lt;/bpmn:exclusiveGateway\u0026gt; \u0026lt;bpmn:sequenceFlow id=\u0026#34;Flow_g2_end\u0026#34; sourceRef=\u0026#34;Gateway_2\u0026#34; targetRef=\u0026#34;EndEvent_1\u0026#34; /\u0026gt; \u0026lt;bpmn:endEvent id=\u0026#34;EndEvent_1\u0026#34;\u0026gt; \u0026lt;bpmn:incoming\u0026gt;Flow_g2_end\u0026lt;/bpmn:incoming\u0026gt; \u0026lt;/bpmn:endEvent\u0026gt; \u0026lt;/bpmn:process\u0026gt; \u0026lt;!-- BPMN Diagram del er fjernet --\u0026gt; \u0026lt;/bpmn:definitions\u0026gt; Visuell representasjon av bpmn definisjonen over\nImplementer og inject egendefinert gateway kode For å velge riktig sequenceflow ut av en exclusive gateway basert på instansdataene må applikasjonen inneholde en implementasjon av Altinn.App.Core.Features.IProcessExclusiveGateway og registrere det med dependency injection systemet.\nInterfacet har en string Property GatewayId, og en metode FilterAsync\nGatewayId brukes for å identifisere gatewayen i processen som koden er koblet til.\nI eksempelet over vil en implementasjon ha propertien satt til Gateway_1 siden dette er verdien på attributtet id i gatewayen vi øsnker å skrive logikk for (eneste med to sequenceflows ut av seg).\nMetoden FilterAsync er hvor du implementerer din egendefinerte kode som skal filtrere og returnere gyldige sequenceflow(er) ut av gatewayen basert på instanses data.\nFor mer dokumentasjon av interfacet se xml dokumentasjonen på interfacet her\nEtter du har skrevet logikken din må den registreres i dependency injection systemet. Dette gjøres i metoden RegisterCustomAppServices i filen Program.cs\nEksempel:\nvoid RegisterCustomAppServices( IServiceCollection services, IConfiguration config, IWebHostEnvironment env) { services.AddTransient\u0026lt;IProcessExclusiveGateway, GatewayOne\u0026gt;(); } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/gateways/",
	"title": "gateways",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/godkjenn-bruksvilkaar/",
	"title": "Godkjenning av bruksvilkår for skytjenester fra Altinn",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å godkjenne bruksvilkår for Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\nRepo Kjørende tjeneste "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/grouping/",
	"title": "Gruppering av felter",
	"tags": [],
	"description": "Hvordan gruppere felter i skjema.",
	"content": "\rOppsett for gruppering av felter\rGenerelt oppsett for gruppering av felter i skjema.\nRepeterende grupper\rOppsett for repeterende grupper.\nInnstillinger\rInnstillinger for visning.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/contributing/handbook/",
	"title": "Utviklingshåndbok",
	"tags": ["development"],
	"description": "Utviklingshåndbok for bidrag til kodebasen i Altinn.",
	"content": "Håndbok for utvikling er foreløpig kun tilgjengelig på engelsk.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/whats-new/",
	"title": "Hva er nytt",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v1 av deployment.",
	"content": "1.1.0 Første versjon i remote repository. Templates kopiert fra apps template\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/whats-new/",
	"title": "Hva er nytt",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v2 av deployment.",
	"content": "2.3.0 Endringer innført Oppgrader HorizontalPodAutoscaler fra versjon autoscaling/v2beta2 til autoscaling/v2 autoscaling/v2beta2 er deprecated i versjon 1.23+ av kubernetes og blir fjernet i versjon 1.26+ Apps kluster vil ettervert bli oppgradert og deployment av apps som bruker eldre versjoner vil feile når clustrene blir oppgradert til 1.26+\nAKS release kalender\nSe release på Github\n2.2.0 Endringer innført Muliggjør å sette pod annotasjoner i values.yaml Hvordan sette pod annotasjoner i values.yaml deployment: podAnnotations: key1: value1 key2: value2 Se release på Github\n2.1.0 Aktivering av liveness og/elelr readiness probe krever at applikasjonen din kjører versjon 4.30.0 eller høyere av Altinn.App.* nugetpakkene.\rEndringer innført Default CPU og minne tilgjengeliggjort per pod er redusert til henholdsvis 50m og 128Mi. Konfigurerbar liveness og readiness probes er tilgjengelig. Default er at dette er disablet. Nye valgfrie felter med standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 deployment: readiness: enabled: false path: /health initialDelaySeconds: 30 failureThreshold: 3 periodSeconds: 3 timeoutSeconds: 1 liveness: enabled: false path: /health initialDelaySeconds: 3 failureThreshold: 3 periodSeconds: 10 Gjennomgang:\n3. Aktiver eller deaktiver readinessprobe for denne applikasjonen.\n4. Pathen til readiness-endepunktet i applikasjonen.\n5. Hvor mange sekunder man venter før readinessproben begynner etter at containeren har startet.\n6. Minimum antall påfølgende feil før readinessproben ansees som feilet.\n7. Frekvens for readinessprobing\n8. Hvor mange sekunder før readinessproben timer ut\n10. Aktiver eller deaktiver livenessprobe for denne applikasjonen.\n11. Pathen til liveness-endepunktet i applikasjonen.\n12. Hvor mange sekunder man venter før livenessproben begynner etter at containeren har startet.\n13. Minimum antall påfølgende feil før livenessproben ansees som feilet.\n13. Frekvens for livenessprobing\n14. Hvor mange sekunder før livenessproben timer ut\nSe release på Github\n2.0.0 Oppgradering til 2.0.0 fra 1.x.x vil føre til en kort nedetid ved første deploy. Påfølgende deployments vil gå som normalt\rHvis din apps deployment mappe fortsatt har undermappen templates vennligst følg migrerings guiden\nChanges introduced Deployment objektet får nytt navn -v2 dette på grunn av nødvendig endring på selector som ikke kan endre på et objekt. ADVARSEL fører til nedetid ved førstegangs deploy Alle applikasjoner får satt resource requests Horizontal pod autoscaler er påskrudd som default (automatisk skalering av applikasjon) Labels and selectors oppdaterte for de fleste kubernetes objekter Standard initial skalering er endret fra 1 til 2 Nye valgfrie felter med standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 deployment: autoscaling: enabled: true replicas: min: 2 max: 10 avgCpuUtilization: 70 behavior: stabilizationWindowSeconds: scaleUp: 0 scaleDown: 120 resources: requests: cpu: 300m memory: 256Mi Gjennomgang\n3. Aktiver eller deaktiver autoskalering for denne applikasjonen.\n5. Nedre grense for antall pods som kan settes av autoskaleringen.\n6. Øvre grense for antall pods som kan settes av autoskaleringen.\n7. Grensen for gjennomsnittlig CPU utnyttelse (målt i prosent av request CPU) over alle pods for når skalering skal inntreffe.\n9. Stabiliseringsvinduet brukes for å begrense unødvendige endringer i antall replikaer av applikasjonen.\n10. Antall sekunder gjennomsnittlig CPU forbruk over alle pods er over terskelverdi (cpuAvgCpuUtilization) før oppskalering starter.\n11. Antall sekunder gjennomsnittlig CPU forbruk over alle pods er under terskelverdi (cpuAvgCpuUtilization) før nedskalering starter.\n14. CPU millicores reservert av kubelet for hver pod/replica av denne applikasjonen. Benyttet av HPA for å kalkulere skalering. Pods kan bruke mer CPU enn dette hvis det er tilgjengelig.\n15. Minne reservert av kubelet for hver pod/replica av denne applikasjonen. Pods kan bruke mer minne enn dette hvis det er tilgjengelig.\nNye valgfrie felter uten standard verdier tilgjengelig for overstyring i values.yaml 1 2 3 4 5 deployment: resources: limits: cpu: 1000m memoty: 512Mi Gjennomgang\n4. Øvre grense for CPU millicores en pod kan benytte. Forsøk på bruk utover dette vil føre til CPU throttling.\n5. Øvre grense for minne en pod kan benytte. Pods som forsøker å allokere mer minne en dette vil termineres med en \u0026ldquo;Out of memory (OOM)\u0026rdquo; error.\nPull requests merged Horizontal Pod Autoscaler (PR #3) Se release på Github\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-frontend/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i v3 av app frontend.",
	"content": "Endringslogg for app-frontend er nå tilgjengelig på Github Releases.\nFor å se en oversikt over endringer som kommer snart kan du se på roadmap.\n3.37.2 (2022-05-20) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 20 av 2022.\n3.37.1 (2022-05-15) - Fiks for prefill sammen med preselectedOptionIndex Om man bruker preselectedOptionIndex på et felt som igjen brukes til å påvirke dynamiske prefill-verdier for andre felt (eller om du bare klikker veldig fort), kunne feil prefill-verdier bli vist. Issue #8255.\n3.37.0 (2022-05-15) - Støtte for sporvalg i tilstandsløse apper Tilstandsløse (stateless) apper kan nå benytte sporvalg. Krever versjon 5.1.0 eller senere av nuget-pakker. Issue #8347.\n3.36.4 (2022-05-10) - Fikset validering av tomme felter for skjulte grupper (igjen) Etter den forrige fiksen lansert i versjon 3.35.2 ble det oppdaget at problemet vedvarte om man skjulte spesifikke felter istedenfor hele gruppen. Dette problemet er nå løst. Issue #6398.\n3.36.3 (2022-05-10) - Kun referere til beskrivelse om denne finnes Fikset en feil hvor komponenter hadde satt aria-describedby til et element som ikke fantes. Issue #23.\n3.36.2 (2022-05-06) - Fikset potensiell kræsj etter valideringsfeil fra server Fikser en nylig introdusert feil hvor en feilende validering fra serversiden kunne føre til at appen stoppet. Issue #8481.\nOppdaterte eksterne avhengigheter for uke 18 av 2022.\n3.36.1 (2022-05-06) - Fikset validering av tomme felter for flerside repeterende grupper Fikser en feil hvor påkrevde felter i en flerside repeterende gruppe førte til en feilmelding selv om man ikke hadde lagt til en instans av den repeterende gruppen. Issue #7478.\n3.36.0 (2022-05-03) - Støtte for dynamikk i nøstede repeterende grupper La til støtte for dynamikk i nøstede repeterende grupper. Issue #55.\n3.35.2 (2022-05-02) - Fikset validering av tomme felter for skjulte grupper Fikser en feil hvor skjuling av en (ikke-repeterende) gruppe med obligatoriske felter kunne føre til valideringsfeil med beskjed om at noen usynlige felter ikke var fyllt ut. Issue #6398.\n3.35.1 (2022-04-28) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 17 av 2022.\n3.35.0 (2022-04-28) - Merke påkrevde felter Endret standard visning av felter til at påkrevde felter markeres med en *, mens felter som er valgfrie ikke har noen markering. Valgfrie felter kan settes opp til å markeres med (Valgfri) via labelSettings-property på feltet i form layout. Se her.\n3.34.4 (2022-04-28) - Fjernet overskrift om vedlegg når det ikke er noen vedlegg Under kvitteringen ble det vist en overskrift over listen med vedlegg. Etter det ble mulig å skru av generering av PDF ble denne overskriften fortsatt vist, men har nå blitt skjult. Issue #8296.\n3.34.3 (2022-04-28) - Fikset feil relatert til caching av sist besøkte side Fikser en feil hvor stateless-applikasjoner brukte en delt nøkkel for persistering av sist besøkte side. Fikser også en feil hvor en tom side ville vises til brukeren om den cachede side-nøkkelen ikke lenger fantes. Issues #7897 og #6975.\n3.34.2 (2022-04-25) - Fikset kantfarger for checkbox og radio Kantfargene for disse komponentene fulgte ikke kontrastkravene fra WCAG 2.1. Fargene på disse har blitt endret til å følge en standardfarge. Issue #11.\n3.34.1 (2022-04-22) - Fikset ugyldig HTML attributt i ImageComponent width attributt på img elementer kan kun være tallverdi som representerer px. Vi støtter å definere width med andre måleenheter, som f.ex %. Width deklarasjonen ble flyttet til inline styling for å løse problemet. Issue #14.\n3.34.0 (2022-04-11) - Options fra datamodellen La til støtte for å sette opp options (kodelister) fra repeterende grupper i datamodellen. Les mer på docs. Issue #7626.\n3.33.5 (2022-04-11) - Oppdaterte ekstern avhengighet Oppdatering av ekstern avhengighet grunnet sikkerhetshull. Pull request #8371.\n3.33.4 (2022-03-31) - Webpack 5 + oppdaterte avhengigheter App frontend bundles nå med webpack 5. Oppdaterte også eksterne avhengigheter. Issue #5073.\n3.33.3 (2022-03-25) - Støtte for å definere rad eller kolonne for checkbox og radio Lagt til støtte for å definere om radio/checkbox skal vises på en rad eller i kolonne. Issue #5730.\n3.33.2 (2022-03-24) - Justert høyde for inputfelter og datovelger Høyden på disse feltene var feil. Det har blitt rettet til 36px høyde. Issue #7377.\n3.33.1 (2022-03-23) - Fikset feil med dynamiske options Fikset en feil hvor kun den første option ble hentet om man hadde definert to komponenter med samme optionId men ulik mapping. Issue #8292.\n3.33.0 (2022-03-18) - Oppdatert tekst i bekreftelsessteg + mulighet til å overstyre Ny tekst for confirm.sender i bekreftelsessteget. Nå også mulighet til å overstyre denne. Issue #8243.\n3.32.10 (2022-03-18) - Fikset feil i datovelgeren Fikset en feil hvor ugyldige datoer ikke ville vise noen feilmelding. Issue #8121.\n3.32.9 (2022-03-10) - Fikset feil med vedlegg i LocalTest Er nå mulig å laste ned vedlegg i LocalTest. Pull request #7925.\n3.32.8 (2022-03-04) - Fikset feil for nedtrekkskomponent i repeterende grupper Fikset en feil hvor nedtrekkskomponenten i repeterende grupper kunne resultere i en ukjent feil. Issue #8169.\n3.32.7 (2022-03-04) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 9 av 2022. Issue #8137.\n3.32.6 (2022-03-02) - Forbedret validerings-støtte for sporvalg La til støtte for å kunne koble valideirngsmelding til data-felt som ble brukt på flere sider. Issue #8145.\n3.32.5 (2022-03-02) - Forbedringer i tekster Ulike forbedringer relatert til teksthåndtering. La også til støtte for markdown i tittel-komponentens. Issue #7874. Issue #7571.\n3.32.4 (2022-03-01) - Visuelle fikser i modalen. Justeringer i padding i modalen i mobilvisningen. Issue #8143.\n3.32.3 (2022-03-01) - Kjøre frontendregler på serversidekalkuleringer Fikset en feil der frontend regler ikke ville bli kjørt når en kalkulering på serversiden oppdaterte et felt koblet til en regel. Issue #8054.\n3.32.2 (2022-02-28) - Fikset feil i Adresse-komponenten Fikset en feil i adresse-komponenten hvor poststed enkelte ganger ikke ble oppdatert når man skrev inn postnummer. Issue #8130.\n3.32.1 (2022-02-25) - Fikset feil for layout-navn Fikset en feil hvor en app med en layout-side med navn \u0026ldquo;data\u0026rdquo; ikke ville starte. Issue #8125.\n3.32.0 (2022-02-23) - Sikrede options Er nå mulig å sette opp sikrede options. Issue #7893.\n3.31.4 (2022-02-23) - Feilretting for Bekreft-steget Fikset feil hvor spinneren ikke ble vist mens confirm request ble gjort. Viser også nå den genererte PDF\u0026rsquo;en i bekreft-steget. Issue #7824.\n3.31.3 (2022-02-17) - Fikset oppstilling av label grid Fikset oppstilling av label grid slik at den matcher en vanlig grid. Pull request #8059.\n3.31.2 (2022-02-17) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 7 av 2022. Issue #8048.\n3.31.1 (2022-02-16) - Ny styling for knapp Ny styling for knapp-komponent for å matche figma-skisser. Pull request #8057.\n3.31.0 (2022-02-16) - Lagt til støtte for å endre tekster i arkivkvittering Tekster i arkivkvittering kan nå overstyres fra applikasjonen, og tekstene støtter også markdown og variabler.\nIssue #7902.\n3.30.0 (2022-02-16) - Automatisk hente nye options når mapping endres La til funksjonalitet for å automatisk hente options på nytt når et felt i mappingen endres.\nIssue #7888.\n3.29.1 (2022-02-14) - Fikset feil hvor variables i tekster ble ignorert ved kalkulering Dette fikser en feil som ble introdusert i 3.29.0\nPull request #5893.\n3.29.0 (2022-02-11) - Lagt til Navigationbar komponent Lagt til Navigationbar komponent\nIssue #5893.\n3.28.2 (2022-02-10) - Flyttet testfiler Ingen kodeendringer\nPull request #7999.\n3.28.1 (2022-02-09) - Fikset en feil i checkboxkomponent Fikset en feil som ble introdusert i 3.27.5, hvor endringer av checkbox førte til at simplebindingverdien ble satt til ,\nPull request #7996.\n3.28.0 (2022-02-09) - Lagt til FileUploadWithTag komponent Lagt til filopplastningskomponent med mulighet for merking av filer.\nIssue #6479.\n3.27.5 (2022-02-09) - Fikset feil i checkboxkomponent Fikset feil i checkboxkomponent\nEndringen støtter under sak #7464.\n3.27.4 (2022-02-08) - Fikset feil i confirm container Fikset feil i confirm container\nEndringen støtter under sak #7464.\n3.27.3 (2022-02-07) - Fikset feil i radiobuttonkomponent Fikset feil i radiobuttonkomponent\nEndringen støtter under sak #7464.\n3.27.2 (2022-02-07) - Fikset feil i receipt container Fikset feil i receipt container\nEndringen støtter under sak #7464.\n3.27.1 (2022-02-07) - Fikset feil i datepickerkomponent Fikset feil i datepickerkomponent\nEndringen støtter under sak #7464.\n3.27.0 (2022-02-01) - Vise applikasjonseier header Applikasjonseier vil nå vises i header for å tydeliggjøre hvem som er eier av appen.\nIssue #7227.\n3.26.3 (2022-02-01) - Fikset feil i adressekomponent Fikset feil i adresse komponent\nEndringen støtter under sak #7464.\n3.26.2 (2022-02-01) - Fikset feil i dropdownkomponent Fikset feil i dropdown komponent\nEndringen støtter under sak #7464.\n3.26.1 (2022-01-31) - Fikset feil i InstantiateContainer Fikset feil i instantiate container\nEndringen støtter under sak #7464.\n3.26.0 (2022-01-30) - Designendringer for repeterende grupper \u0026ldquo;Lagre\u0026rdquo;-knappen får annereledes stil enn \u0026ldquo;Neste\u0026rdquo;-knappen. \u0026ldquo;Rediger\u0026rdquo;-knappen får samme focus-state stil som den redigerbare boksen så man enklere ser hvilken rad som redigeres. Ikon justeres til venstre for tekst i alle ikonknapper. Margen i gruppen endres slik at teksten utnytter hele bredden og flyter på samme vertikale linje som resten av innholdet i skjemaet. Endringen støtter under sak #7577.\n3.25.1 (2022-01-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 4 av 2022.\nIssue #7842.\n3.25.0 (2022-01-24) - Lagt til flere datakilder for variabler i tekst Funksjonaliteten knyttet til variabler i tekster har fått to nye datakilder. Det blir nå mulig å hente verdier fra instance og konfigurasjonsverdier fra ApplicationSettings. Støtten for konfigurasjonsverdier krever versjon 4.25.0 eller nyere av backend sine NuGet pakker.\nEndringen støtter under sak #7520.\n3.24.0 (2022-01-24) - Nøytralt design La til et mer nøytralt design for app-frontend. Issue #7234.\n3.23.1 (2022-01-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 3 av 2022. Issue #7842.\n3.23.0 (2022-01-21) - Dynamiske options (kodelister) La til støtte for første utgave av dynamiske options (kodelister). Issue #5247.\n3.22.9 (2022-01-20) - Typestabil FormData + Typescript forbedringer Gjør FormData typestabil og ulike forbedringer til typer. Pull request #7718.\n3.22.8 (2022-01-17) - Fikset ulike eslint feil Fikset ulike eslint feil, la til testdekning. Noe refaktorering av eldre komponenter. Pull request #7786.\n3.22.7 (2022-01-13) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 2 av 2022. Issue #7753.\n3.22.6 (2022-01-11) - Fikset feil med repeterende grupper Fikset feil hvor repeterende grupper staten ikke ville bli fjernet når man lastet ny formlayout. Issue #7773.\n3.22.5 (2022-01-10) - Optimalisering for SummaryGroupComponent La til manglende keys for forbedret ytelse. Pull request #7720.\n3.22.4 (2022-01-07) - Vise feilmelding for ukjent komponent App frontend viser nå en feilmelding når den prøver rendre en ukjent komponent. Pull request #7724.\n3.22.3 (2022-01-07) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 1 av 2022. Issue #7753.\n3.22.2 (2021-12-23) - Fikset feil med variabler i tekst Fikset en feil hvor variabler i tekst ikke ville bli oppdatert etter en backend kalkulering. Issue #7308.\n3.22.1 (2021-12-23) - Fikset feil for manglende rettigheter i stateless view Fikset en feil hvor manglende rettigheter ville resultere i en generisk feilmelding og ikke feilmelding om manglende rettigheter. Issue #6514.\n3.22.0 (2021-12-22) - Flere muligheter til å skreddersy repeterende gruppe La til flere muligheter til å overstyre tekster og skjule \u0026ldquo;legg til\u0026rdquo; knappen for repeterende gruppe. Issue #7164.\n3.21.1 (2021-12-17) - Fikset feil med validering på task Fikset en feil hvor feilmeldinger satt i ValidateTask i ValidationHandler.cs ikke ble vist til bruker. Issue #7333.\n3.21.0 (2021-12-17) - Mulighet for å bruke h2, h3 og h4 for størrelse i header komponenten i FormLayout Det er nå mulig å bruke h2, h3 og h4, istedenfor S, M og L som verdier for størrelse i header komponenten. Issue #7611.\n3.20.1 (2021-12-16) - Fikset feil i adressekomponenten Fikset en feil hvor adressekomponenten kræsjet uventet for tomme verdier. Issue #7658.\n3.20.0 (2021-12-14) - Støtte for egendefinert OIDC provider La til støtte i frontend for at Altinn.Apps kan ha ulike OIDC provider. Issue #7173.\n3.19.2 (2021-12-09) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 49. Issue #7590.\n3.19.1 (2021-12-09) - Endringer i bilde komponent Flere endringer for bilde-komponenten. Issue #7484.\n3.19.0 (2021-12-06) - Starte instans fra stateless visning Støtte for å starte en data instans fra stateless visning innad i samme applikasjon. Issue #6196.\n3.18.4 (2021-12-03) - Optimalisering for mobil visning Tilbakestilte endring av maxWidth fra versjon 3.18.3 da dette skapte trøbbel med fokus-visning på større skjermer. Issue #7588.\n3.18.3 (2021-12-01) - Optimalisering for mobil visning - bredde Fikset maxWidth for input-komponenter og for address component. Issue #6697.\n3.18.2 (2021-11-30) - Optimalisering for mobil visning - luft Forbedret luft for tittel og paragraf-komponentene. Issue #6697.\n3.18.1 (2021-11-30) - Optimalisering for mobil visning - bredde Endret maxWidth på valideringsmeldinger fra auto til none. Issue #6697.\n3.18.0 (2021-11-29) - Støtte for labelgrid La til støtte for labelGrid i grid som muliggjør lengre lister med korte spørsmål og svar som kan bli presentert i en tabell-liknende visning. Issue #7027.\n3.17.1 (2021-11-24) - Bugfiks DataProcessWrite. Fikset en feil hvor numeriske felter som ble satt i DataProcessWrite ikke ble oppdatert i skjema om verdien var 0. Issue #7393.\n3.17.0 (2021-11-24) - Optimalisering for mobilvisning La til forbedringer i måten skjema ser ut på mobil. Issue #6697.\n3.16.0 (2021-11-24) - Endret ikon for hjelpetekst. Endret hjelpetekst ikonet fra plus til spørsmålstegn. Issue #5722.\n3.15.1 (2021-11-18) - Ugyldige typer for reselect Fikset ugyldige typer for reselect. Pull request #7502.\n3.15.0 (2021-11-15) - Støtte for returnUrl La til støtte for returnUrl i app-frontend. Issue #7183.\n3.14.2 (2021-11-11) - Oppdatering av jsonpointer Oppdaterte ekstern avhenghighet jsonpointer. Issue #7317.\n3.14.1 (2021-11-11) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 45. Issue #7317.\n3.14.0 (2021-11-08) - \u0026ldquo;today\u0026rdquo;-flagg for datovelger min/max datoer La til et flag for å dynamisk kunne styre min/max datoer basert på dagens dato. Issue #7228.\n3.13.6 (2021-11-04) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 44. Issue #7317.\n3.13.5 (2021-10-28) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 43. Issue #7303.\n3.13.4 (2021-10-22) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 42. Issue #7303.\n3.13.3 (2021-10-15) - Høyrejustere tekst i inputfelter La til funksjonalitete for å høyrejustere tekst i inputfelter. Pull request #7034.\n3.13.2 (2021-10-14) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 41. Issue #7051.\n3.13.1 (2021-10-13) - Fiks for tilpasset validering av vedlegg Fikset validering av vedlegg som krasjet med tilpasset logikk. Issue #7107.\n3.13.0 (2021-10-11) - Start fra aktiv instans La til funksjonalitet for å starte en applikasjon fra en aktiv instans. Issue #6766.\n3.12.4 (2021-10-11) - Repeterende gruppe åpen konfigurasjon La til funksjonalitet til å styre om en repeterende gruppe skal være åpen i editeringsmodus når applikasjonen lastes. Løser deler av issue #4870.\n3.12.3 (2021-10-07) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for uke 40. Issue #7051.\n3.12.2 (2021-10-04) - Fiks for design av readonly datovelger Readonly datovelger nå har samme design som andre readonly komponenter. Issue #6253.\n3.12.1 (2021-09-30) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u39. Issue #6873..\n3.12.0 (2021-09-29) - Bildekomponent La til bildekomponent for enklere å kunne legge til bilder i applikasjonen. Issue #379.\n3.11.9 (2021-09-29) - Støtte for JSON Schema 2020-12 i app frontend Fikset bug hvor JSON Schema 2020-12 ikke var støttet i app frontend. Tilhørende issues: #6703 #6812.\n3.11.8 (2021-09-27) - Lagt til mellomrom mellom valgfri tekst og titteltekst Lagt til mellomrom mellom valgfri tekst og titteltekst i radioknapp, avkrysningsboks og adresse komponenter. Issue #6893.\n3.11.7 (2021-09-24) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u38. Issue #6873.\n3.11.6 (20201-09-21) - Fokus indikator for input-felt Fikset bug hvor fokus indikator ikke var synlig for input-felter. Issue #6801.\n3.11.5 (2021-09-21) - Content loader visning på mobil Fikset bug hvor content loader gikk over tildelt bredde for små skjermer. Issue #6876.\n3.11.4 (2021-09-20) - Fiks for tekst parse feil Fikset tekst parse feil i confirm steget av en app. Issue #6775.\n3.11.3 (2021-09-17) - Forhåndsvalgt nedtrekksliste Nedtrekksliste støtter forhåndsvalgt (preselectedOptionIndex) verdi. Issue #5255.\n3.11.2 (2021-09-16) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u37. Issue #6794.\n3.11.1 (2021-09-09) - Oppdaterte avhengigheter Oppdaterte eksterne avhengigheter for u36. Issue #6794.\n3.11.0 (2021-09-08) - Aktør valg i stateless app Stateless appene støtter aktør valg basert på innstillinger i app metadata. Issue #6443.\n3.10.3 (2021-08-23) - Added some IDs used by automated tests Non functional change. Not connected to an issue.\n3.10.2 (2021-08-19) - Dependency patching Patching of external dependencies for w33. Issue #6600\n3.10.1 (2021-08-16) - App frontend includes partyID for stateless apps App frontend includes partyID in calls for fetching stateless data. Issue #6609\n3.10.0 (2021-08-13) - Log out functionality Added functionality for log out from app frontend. Issue #6620\n3.9.9 (2021-08-12) - Dependency patching Patching of external dependencies for w32. Issue #6600.\n3.9.8 (2021-08-05) - Dependency patching Patching of external dependenecies for w31. Issue #6571.\n3.9.7 (2021-08-03) - Bugfix print view Fixed a bug where the print view for Altinn Apps would display an empty container. Issue #6578.\n3.9.6 (2021-08-02) - Dependency patching Patching of external dependenecies for w30. Issue #6571.\n3.9.5 (2021-07-28) - Bugfix for mobile view during app startup Fixed a bug where the app modal would behave inconsistent during app startup on mobile devices. Issue #6558.\n3.9.4 (2021-07-23) - Bugfix validation trigger for groups. Fix a bug where validations would not be triggered when closing a repeating group by clicking Edit button when trigger was present. Issue #6427.\n3.9.3 (2021-07-23) - Dependency patching Patching of external dependencies for w29.\n3.9.2 (2021-07-02) - Dependency patching Patching of external dependencies for w26. Issue #6385.\n3.9.1 (2021-07-01) - Support for redirect to require higher authentication level for stateless app Fix for bug that didn\u0026rsquo;t redirect user to login page with allowed authentication levels if logged in with a too low level. Issue #6506.\n3.8.0 (2021-06-29) - Several updates to validation functionality Support for adding custom error messages to client side validations (JSON schema). Support for specifying single field validation (server) as FIXED to make sure resolved validation error messages are removed. Fixes bug where single field validation that returned empty (no errors/warnings) did not remove existing validation messages. Issue #5747. 3.7.0 (2021-06-29) - Support for posting data from stateless app Issue #6194.\n3.6.14 (2021-06-22) - Bug fix for duplicated validation messages Fixed a bug that caused validation messages on a FileUpload component to be displayed twice. Issue #6400.\n3.6.13 (2021-06-18) - Bugfix for replaceAll with variables in text Fix for bug introduced in 3.6.9, where only the last variable in texts with multiple variables was replaced. The change in 3.6.9 also caused summary page to fail in some cases. Issue #6455.\n3.6.12 (2021-06-18) - Dependency patching Patching of external dependencies. Issue #6385.\n3.6.11 (2021-06-16) - Bugfix for disappearing validation messages Fixed bug for disappearing validation messages. Single field validation response would overwrite all existing validations, causing earlier triggered validation messages to disappear. Issue #5857.\n3.6.10 (2021-06-15) - Bugfix for navigation buttons with multiple triggers Fixed bug for navigation buttons configured with multiple triggers, where only the first one was actually triggered. Issue #6387.\n3.6.9 (2021-06-14) - Bugfix variables in text Fixed bug where only first occurance of a variable in a given text was replaced. Issue #6091\n3.6.8 (2021-06-11) - New endpoints for statless app New endpoints for stateless app. Issue #6227\n3.6.7 (2021-06-10) - Dependency patching Patching of external dependencies. Issue #6385\n3.6.6 (2021-06-09) - Dependency patching Updated to latest major version of react v17. Issue #5072\n3.6.5 (2021-06-02) Bugfix for stateless app Fixed bug where stateless app with onEntry.show set to new-instance would crash. Issue #6321.\n3.6.4 (2021-06-02) Bugfix for simple receipt Fixed bug where simple receipt did not parse markdown if the app overrides defult texts. Issue #6232.\n3.6.3 (2021-06-02) Bufix for content loader Fixed bug where content loader did not scale for whole view. Issue #4888.\n3.6.2 (2021-06-01) Bugfix for summary view of group with multiple pages Fixed bug that caused app frontend to crash when rendering summary component for group when the group was defined with multiple pages in edit mode. Issue #6233.\n3.6.1 (2021-05-28) Dependency patching Patching of external dependencies. Issue #6324.\n3.6.0 (2021-05-28) Support for hiding back button in apps Issue #6193.\n3.5.0 (2021-05-27) Support for number formatting Added support for formatting numbers for Input-components. Issue #5972.\n3.4.2 (2021-05-26) Improve look of summary for checkboxes component Issue #6329.\n3.4.1 (2021-05-20) Dependency patching Patching of external dependencies. Issue #6221.\n3.4.0 (2021-05-18) Support for stateless apps Issue #6124.\n3.3.5 (2021-05-14) - Dependency patching Patching of external dependencies. Issue #6221.\n3.3.4 (2021-05-11) Bugfix for calculation in groups Issue #6235.\n3.3.3 (2021-05-11) Run data validation on page switch, and fix group component mobile view Issue #6236. Issue #5977.\n3.3.2 (2021-05-06) - Dependency patching Patching of external dependencies. Issue #6011.\n3.3.1 (2021-05-06) Support for markdown in validation messages Issue #5137.\n3.3.0 (2021-05-03) Support for multiple views in repeating group edit mode Issue #5869.\n3.2.2 (2021-04-23) - Dependency patching Patching of external dependencies. Issue #6011.\n3.2.1 (2021-04-23) - Bugfix for group validations Fixed a bug where groups with validation trigger would call the instance validation api. Now calls data validation. Issue #6089.\n3.2.0 (2021-04-21) - Validation on group save Added support for running validations on a group when the user tries to save an entry. Issue #5281.\n3.1.6 (2021-04-19) - Bugfix for checkbox values in summary component Fixed bug where summary would display an empty string for checkboxes with multiple selected values. Issue #5993.\n3.1.5 (2021-04-19) - Bugfix for repeating group state on calculation Fixed bug where repeating group state would not be updated if a backend calculation had altered a repeating group. Issue #6006.\n3.1.4 (2021-04-19) - Bugfix for validations on group delete Fixed bug where validations for a given group index would not be removed on delete. Issue #5960.\n3.1.3 (2021-04-16) - Bugfix for validation Fixed bug where single field validation would validate the whole instance and not data. Issue #5885.\n3.1.2 (2021-04-12) - Dependency patching. Patching of external dependencies. Issue #5957.\n3.1.1 (2021-04-09) - Bugfix for slow calculate Fixed bug where a slow backend calculation can overwrite later entered data. Issue #5754.\n3.1.0 (2021-04-07)- Help text for paragraph and header components App now supports help text for paragraph and header components. Issue #5862.\n3.0.16 (2021-04-06) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.15 (2021-03-22) - Bugix for group component with checkboxes Fixed bug where group component summary would display an empty value for checkboxes that had several selected values. Issue #5907.\n3.0.14 (2021-03-19) - Dependency patching Patching of external dependencies. Issue #5877.\n3.0.13 (2021-03-18) - Internal typings App frontend internal typings updated to fix failing tests. No issue connected.\n3.0.12 (2021-03-17) - Bugfix for markdown support in summary and group titles Fixed bug where app frontend would not render markdown in summary and group titles. Issue #5781.\n3.0.11 (2021-03-17) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order even when no calculation trigger was present. Issue #5863.\n3.0.10 (2021-03-12) - Bugfix for page order calculation Fixed bug where app frontend would trigger call to calculate page order for single page applications. Issue #5859.\n3.0.9 (2021-03-12) - Dependency patching Patching of external dependencies. Issue #5771.\n3.0.8 (2021-03-12) - Support for dynamicly getting page order App frontend now supports dynamicly fetching the page order on next page (\u0026ldquo;sporvalg\u0026rdquo;). See docs for more information. Issue #5640.\n3.0.7 (2021-03-09) - Bugfix for page caching Fixed issue where the app would cache the first page in alphabetical order and not respect the order in Settings.json. Issue #5819.\n3.0.6 (2021-03-08) - Caching of last viewed page Introduced caching of the last viewed form page, so user is returned to this page when refreshing or coming back at a later time. Issue #5278.\n3.0.5 (2021-03-05) - Dependency patching Patching of external dependencies. Issue #5770.\n3.0.4 (2021-03-05) - Bugfix for text styling in titles/descriptions Fix issue where label and description texts would get cut off mid word. Issue #5810.\n3.0.3 (2021-03-02) - Bugfix for metadata with layoutsets Fix issue where app-frontend feched wrong metadata when using layoutsets. Issue #5624.\n3.0.2 (2021-02-26) - Dependency patching Patching of external dependencies. Issue #5676.\n3.0.1 (2021-02-25) - Horizontally aligned components \u0026amp; Bugfix for loading options App-frontend now supports horizontally aligned components. See docs for more information. Issue #1515.\nFix issue that only loaded options related to form layout in first data task - for subsequent data tasks options were not loaded. Issue #5619.\n3.0.0 (2021-02-23) - New font for App Frontend This version changes the font for the app frontend from Roboto to Altinn-DIN. For the apps to show fonts as expected, some changes need to be made. See breaking changes for the details.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v3/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 3.",
	"content": "3.5.1 (2021-03-11) - Possible to get ruleconfiguration for apps with layout sets There was a bug resulting in av 404 response whenever it is attepmpted to retrieve the ruleconfiguration for an application while specifying the layout set id in the request. This has now been fixed.\n3.5.0 (2021-03-10) - Added funcionality for pdf generation for application owner Up until now a pdf copy has not been generated for the tasks that are completed by the application owner. This has now been implemented and pdf should be generated after a task regardless if it is an end user of the app owner that completes the task.\n3.4.0 (2021-03-10) - Endpoint and functionality for get page order made available All apps now expose an endpoint for getting the current page order based on the current state of an instance. Default behavior is to return the page order as defined in Settings.json to override, add the function below in Logic/App.cs and include your own logic.\npublic override async Task\u0026lt;LayoutSettings\u0026gt; FormatPdf(LayoutSettings layoutSettings, object data) { return await _pdfHandler.FormatPdf(layoutSettings, data); } 3.3.0 (2021-03-04) - Retrieving certificate from Key Vault now uses name The ISecret service now requires certificate name as input for retrieving a certificate from key vault. Previously this has been the certificate id, but this identificator contains more information that an app developer might have available, so the service has been simplified.\n3.2.3 (2021-02-17) - Fixed duplicate key exception on options When using the same option key in an option result a duplicate key exception was thrown that crashed the app. This is now fixed, and keys that already exist in the option result will not be added.\n3.2.1 (2021-02-10) - Correctly set unread status when instantiated by end user The instance now appears as read in the messagebox if it is instantiated by an end user through api, regardless if they have opened the instance in GUI or downloaded the form data they just posted.\n3.2.0 (2021-02-02) - Options displayed with label in PDF Before this release the selected option was shown with it\u0026rsquo;s value rather than the label that the end user was presented with during form filling. This has now been fixed so the label is diplayed in the pdf.\n3.1.6 (2021-01-29) 3.1.5 (2021-01-27) 3.1.4 (2021-01-26) 3.0.4 (2021-01-26) - Swagger support for Apps We have added Swashbuckle to the App. It is a library that brings Swagger support and this is especially handy when developing an HTTP based API. It creates a form of interactive documentation based on the OpenAPI Specification. To describe the Api\u0026rsquo;s better, we use the xml documentation file.\nThis documentation will be generated automatically when the application is build. Existing api\u0026rsquo;s and new api\u0026rsquo;s created in the app will be documented.\nThe documentation will appear at https://[org].apps.altinn.no/[org]/[app]/swagger/index.html in the app.\nTo enable this, there\u0026rsquo;s some changes.\nUpdated package dependencies, generate xml documentation file and copy xml documentation for Altinn.App.Api Navigate to you application repository and find App.csproj in the App folder.\nUpdate nuget dependencies in App.csproj to version 3.0.4, add new property for Altinn.App.Api.\n\u0026lt;PackageReference Include=\u0026#34;Altinn.App.Api\u0026#34; Version=\u0026#34;3.0.4\u0026#34;\u0026gt; \u0026lt;CopyToOutputDirectory\u0026gt;lib\\$(TargetFramework)\\*.xml \u0026lt;/CopyToOutputDirectory\u0026gt; \u0026lt;/PackageReference\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.Common\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Altinn.App.PlatformServices\u0026#34; Version=\u0026#34;3.0.4\u0026#34; /\u0026gt; This is new in App.csproj\n\u0026lt;PackageReference Include=\u0026#34;Swashbuckle.AspNetCore\u0026#34; Version=\u0026#34;5.6.3\u0026#34; /\u0026gt; \u0026lt;PropertyGroup\u0026gt; \u0026lt;GenerateDocumentationFile\u0026gt;true\u0026lt;/GenerateDocumentationFile\u0026gt; \u0026lt;NoWarn\u0026gt;$(NoWarn);1591\u0026lt;/NoWarn\u0026gt; \u0026lt;/PropertyGroup\u0026gt; \u0026lt;Target Name=\u0026#34;CopyXMLFromPackagesForBuild\u0026#34; AfterTargets=\u0026#34;Build\u0026#34;\u0026gt; \u0026lt;ItemGroup\u0026gt; \u0026lt;PackageReferenceFiles Condition=\u0026#34;%(PackageReference.CopyToOutputDirectory) != \u0026#39;\u0026#39;\u0026#34; Include=\u0026#34;$(NugetPackageRoot)$([MSBuild]::Escape(\u0026#39;%(PackageReference.Identity)\u0026#39;).ToLower())/%(PackageReference.Version)/%(PackageReference.CopyToOutputDirectory)\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; \u0026lt;Copy SourceFiles=\u0026#34;@(PackageReferenceFiles)\u0026#34; DestinationFolder=\u0026#34;$(OutDir)\u0026#34; /\u0026gt; \u0026lt;/Target\u0026gt; Changes to the Startup.cs file. If you don\u0026rsquo;t have any custom code in this, copy file from here.\nAdd this to the end of the ConfigureServices method\n// Add Swagger support (Swashbuckle) services.AddSwaggerGen(c =\u0026gt; { c.SwaggerDoc(\u0026#34;v1\u0026#34;, new OpenApiInfo { Title = \u0026#34;Altinn App Api\u0026#34;, Version = \u0026#34;v1\u0026#34; }); IncludeXmlComments(c); }); Add this before app.UseRouting() in the Configure method\nstring applicationId = GetApplicationId(); if (!string.IsNullOrEmpty(applicationId)) { app.UseSwagger(o =\u0026gt; o.RouteTemplate = applicationId + \u0026#34;/swagger/{documentName}/swagger.json\u0026#34;); app.UseSwaggerUI(c =\u0026gt; { c.SwaggerEndpoint($\u0026#34;/{applicationId}/swagger/v1/swagger.json\u0026#34;, \u0026#34;Altinn App API\u0026#34;); c.RoutePrefix = applicationId + \u0026#34;/swagger\u0026#34;; }); } Add two methods\nprivate void IncludeXmlComments(SwaggerGenOptions options) { try { string fileName = $\u0026#34;{Assembly.GetExecutingAssembly().GetName().Name}.xml\u0026#34;; string fullFilePath = Path.Combine(AppContext.BaseDirectory, fileName); options.IncludeXmlComments(fullFilePath); string fullFilePathApi = Path.Combine(AppContext.BaseDirectory, \u0026#34;Altinn.App.Api.xml\u0026#34;); options.IncludeXmlComments(fullFilePathApi); } catch { // Swagger will not have the xml-documentation to describe the api\u0026#39;s. } } private string GetApplicationId() { string appMetaDataString = File.ReadAllText(\u0026#34;config/applicationmetadata.json\u0026#34;); JObject appMetadataJObject = JObject.Parse(appMetaDataString); return appMetadataJObject.SelectToken(\u0026#34;id\u0026#34;).Value\u0026lt;string\u0026gt;(); } 3.0.1 (2021-01-19) 3.0.0 (2021-01-05) - Support for dynamics in PDF We have added a new PDF handler to make it possible to hide pages and components in PDF. See breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v4/whats-new/",
	"title": "Hva er nytt?",
	"tags": ["translate-to-norwegian"],
	"description": "Oversikt over endringer som ble introdusert i versjon 4.",
	"content": "4.34.1 (06.04.2022) - Støtte for forsendelsestype på eFormidling forsendelse Denne releasen muliggjør spesifisering av forsendelsestype.\nUtvid eFormidling-seksjonen i applicationmetadata.json med den nye egenskapen dpfShipmentType som vist nedenfor.\n\u0026#34;eFormidling\u0026#34;: { ... \u0026#34;dpfShipmentType\u0026#34;: \u0026#34;altinn3.skjema\u0026#34; } 4.33.0 (15.03.2022) - Støtte for å slå av PDF generering for skjema Denne releasen gjør det mulig å slå av PDF generering for enkeltskjema i en applikasjon. Dette gjøres ved å sette flag i application metadata på en gitt datatype. Standard er true\nEksempel.\n{ \u0026#34;id\u0026#34;: \u0026#34;melding\u0026#34;, \u0026#34;allowedContentTypes\u0026#34;: [ \u0026#34;application/xml\u0026#34; ], \u0026#34;maxCount\u0026#34;: 1, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoCreate\u0026#34;: false, \u0026#34;ClassRef\u0026#34;: \u0026#34;App.IntegrationTestsRef.Data.apps.dibk.nabovarsel.Melding\u0026#34; }, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;enablePdfCreation\u0026#34; : false } 4.32.0 (14.03.2022) - Person oppslagstjeneste Register applikasjonen i platform har blitt oppdatert med et nytt endepunkt som kan brukes til å verifisere et personnummer. Denne versjonen av NuGet pakkene til en app har fått implementert en oppslagstjeneste som kan brukes til å gjøre oppslag mot dette nye endepunktet i Register.\n4.31.1 (10.03.2022) - Fikset bug relatert til prefill og berriket instance events med personnumer Denne releasen løser en bug der prefill av samme verdi til mer enn ett felt kaster en duplicate key exception. Personnummer legges nå til i platformUser objektet for instance events. 4.30.0 (07.03.2022) - Støtte for readiness og livenessprober Det er nå lagt til et endepunkt for helsesjekk i applikasjonen. Dette benyttes blant annet av Kubernetes til å vite når en applikasjonsinstans er klar til å settes inn i last.\nFor alle applikasjon opprettet før 16.03.2022 må det gjøres manuelle endringer for å aktivere readiness og liveness probene.\nI App/Startup.cs\nLegg til linjen using Altinn.App.Core.Health; blant de andre using-referansene øverst i filen.\nI metoden ConfigureServices legger du til linjen\nservices.AddHealthChecks().AddCheck\u0026lt;HealthCheck\u0026gt;(\u0026#34;default_health_check\u0026#34;); I metoden Configure legger du til linjen\napp.UseHealthChecks(\u0026#34;/health\u0026#34;); I deployment/Chart.yaml skal referansen til Studio helm charten oppdateres til versjon 2.1.0\nEndelig resultat bør likne på dette:\napiVersion: v1 description: A Helm chart for Kubernetes name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 2.1.0 I deployment/values.yaml legger du til\nreadiness: enabled: true liveness: enabled: true MERK antall innrykk er viktig i filen. readiness og liveness skal stå på nivået under deployment og på samme nivå som volumeMounts og volumes\n4.27.0 (23.02.2022) - Sikre kodelister Lagt til støtte for sikre kodelister Rettet url og parameter logik i GetInstanceEvents Endret redirect url fra string til base64 encoded string\n4.26.0 (2022-02-10) - Forbedringer knyttet til PDF og tekstressurser Nyinnførte tekstressurs appName benyttes som tittel på PDF. Lokal kopi av tekstressurser benyttes i PDF i stedet for tekstressurser fra Platform Storage.\n4.25.0 (2022-01-24) - Dynamiske konfigurasjonsverdier for frontend Det er blitt laget en ny seksjon kalt FrontEndSettings for bruk i appsetting.{miljø}.json filer. Dette eksponeres til frontendapplikasjonen som applicationSettings og er en dynamisk liste med verdier. I praksis betyr dette at FrontEndSettings kan utvides med innslag uten at man må gjøre kodeendringer i backend. Dette gjør det mulig for backend å tilby miljøspesifikke verdier til frontend.\n4.24.0 (2020-01-21) Støtte for språk og query parametre inn til dynamiske kodelister. Ny måte å implementere dynamiske kodelister ved hjelp av IAppOptionsProvider. Se dokumentasjon\n4.23.0 (2022-01-15) - Støtte for BPMN Gateways Restrukturering av prosessmotor og støtte for BPMN gateways.\n4.22.0 (2022-01-07) - Included access token generation for eFormidling integration point Integrasjonspunktet som benyttes for å sende instansdata via eFormidling krever nå et gyldig tilgangstoken. Applikasjonstemplaten er nå oppdatert til å fylle alle krav for integrasjonspunktet.\n4.21.0 (2021-12-01) - Støtte for lagring av brukernavn for instanseier Dersom en selvidentifisert bruker instansierer en instans vil dere brukernavn lagres i metadataen for instanseier.\n4.20.0 (2021-11-18) - Støtte for egendefinert redirect URL når man avslutter appen Lagt til støtte for ett spesifikt query parameter (returnUrl) for å videresende brukeren til den spesifiserte URLen når brukeren avslutter appen ved å trykke på avslutt-knappen i Altinn 3 appen. Les mer om dette her\nRelatert til 7183\n4.19.0 (2021-11-15) - Added support for instantiation based of a copy of an archived instance Lagt til støtte for å instansiere en applikasjon basert på en arkivert instans. Det nye endepunktet er dokumentert her. Merk at støtte for kopiering av instans i meldingsboksen og konfigurasjon av funksjonaliteten via Altinn Studio enda er under utvikling.\nRelatert til 6695\n4.18.0 (2021-11-10) - Støtte for OIDC konfigurasjon i App Lagt til støtte for å konfigurere opp en spesifikk OIDC provider for en app.\nRelatert til 7173\n4.17.2 (2021-10-27) - Lagt inn API for prefill i form av nøkkel-verdi par ved instansiering Det er nå mulig å angi prefill i form av nøkkel-verdi par ved instansiering av en app. Støtten for dette er innført i et nytt API endepunkt.\nDet er også mulig å bruke prefill verdiene i app spesifikk kode. Dette vil kreve at app\u0026rsquo;en implementerer siste versjon av App.cs. Legg til følgende metode:\npublic override async Task RunDataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await _instantiationHandler.DataCreation(instance, data, prefill); } I tillegg må InstansiationHandler.cs oppdateres med methoden:\npublic async Task DataCreation(Instance instance, object data, Dictionary\u0026lt;string, string\u0026gt; prefill) { await Task.CompletedTask; } 4.16.0 (2021-10-07) - Nytt app API for tagging av data elementer Det er blitt laget støtte for å lagre tags (stikkord) på et data element. I den sammenheng er det laget API endepunkter for å liste tags, legge til en tag, og sletting av tag.\nDenne endringer tilhører saken 6861 på github.\nDet er mer informasjon om endringen under app API dokumentasjon.\n4.15.2 (2021-10-04) - Nytt endepunkt for å hente ut aktive instanser Altinn Apps eksponerer nå et endepunkt for å hente ut aktive instanser for en gitt avgiver. Det nye endepunktet er tilgjengelig på {org}.apps.altinn.no/{org}/{app}/instances/{instanceOwnerPartyId}/active.\nDenne endringen tilhører issue 6767.\n4.14.1 (2021-09-22) - Fikset en bug som medførte 500 error hvis instance ikke finnes Det var en bug i koden som medførte 500 error hvis man spurte etter en ikke eksisterende instance. Dette er nå blitt fikset på en måten som gjør at API isteden nå svarer med 403. Open API spesifikasjon for aktuelt endepunkt har blitt oppdatert med mulige status koder.\n4.14.0 (2021-09-13) - Delvis støtte for navnerom(namespace) i XML Koden som deserialiserer XML inn i objekter har blitt oppdatert til å håndtere navneromsdeklarering i rotelementet til et XML-dokument.\nEksempel:\n\u0026lt;Skjema xmlns=\u0026#34;urn:no:altinn:skjema:v1\u0026#34;\u0026gt; \u0026lt;Navn\u0026gt;Altinn\u0026lt;/Navn\u0026gt; \u0026lt;/Skjema\u0026gt; Deserialisering skjer når et eksternt system bruker et app API endepunkt til å sende inn et nytt skjema, overskrive et eksisterende skjema, og når en app henter et skjema dokument fra \u0026ldquo;blob-storage\u0026rdquo;.\nEndringen blir ikke automatisk tatt i bruk i alle apps som tar i burk denne versjonen av NuGet pakkene. For at endringen skal fungere må C# klassen som representerer modellen/skjema bli oppdatert. Klassen må bli dekorert med et XmlRootAttribute hvor det er angitt et navnerom.\nEksempel:\n[XmlRoot(ElementName = \u0026#34;Skjema\u0026#34;, Namespace = \u0026#34;urn:no:altinn:skjema:v1\u0026#34;)] public class Skjema { [MaxLength(100)] [XmlElement(\u0026#34;Navn\u0026#34;)] public string Navn { get; set; } } Denne endringen må foreløpig bli utført manuelt i både gamle og nye modeller. Modeleditoren i altinn.studio har ikke blitt oppdatert til å gjøre det automatisk.\n4.13.0 (2021-09-03) - Hendelse for endring av substatus Det å endre substatus på en instanse trigger nå en event av typen app.instance.substatus.changed. Dette kan eksterne systemer abonnere på via Events tjenesten.\nDette løser sak #6691\n4.12.0 (2021-08-27) - Identitetsdata inkludert i request telemetri Logging av requests til Application Insights nå inkluderer et lite set med identifiserende data for å mer effektivt kunne spore kilden til uvanlige requester. Følgende data punkter blir registrert:\npartyId authentication level userId organisationNumber Dette løser sak #5983\n4.11.1 (2021-08-26) - Hindre caching av data for apps uten \u0026ldquo;state\u0026rdquo; Det er lagt inn kode som gir hint til nettleser om å ikke cache data som blir brukt i apps uten state.\nDette løser #6532\n4.11.0 (2021-08-03) - Support for disabling reportee selection in Altinn Portal Apps now support adding query parameter DontChooseReportee=true to disable the reportee selection when an unauthorized user accesses an app. The result being that the user will represent themselves and be routed directly to the application after login.\nThis release solves issue #6573.\n4.10.2 (2021-07-15) - Text resources are loaded locally The app will now load texts from the locally stored text resource files (config/texts/*) instead of retrieving them from Storage. Texts are still uploaded to Storage during deploy. The change is to remove unnecessary calls to Storage and to avoid an issue with caching that prevented new texts from being used immediately. #6466, #6415 Fixed a bug where a filename with space in it could lead to a crash. #6421 New apps created after the v2021.29 release will provide security headers like X-Frame-Options, X-XSS-Protection, X-Content-Type-Options, and Referer-Policy. To activate this in existing apps follow these steps: Open the App/Startup.cs file. At the top of the file add the namespace reference: using Altinn.App.Api.Middleware; Find the Configure method and add the statement: app.UseDefaultSecurityHeaders(); Add it right before existing app.Use* statements. E.g. before app.UseRouting(); 4.9.2 (2021-07-08) - Fixed messages from multipart request validation Validation messages from multipart request validation was misleading. This release solved issue #6418.\n4.9.1 (2021-07-02) - Bugfix for errors in multipart validation Fixed a bug that caused validation messages to show C# type of DataType rather than DataTypeId. Issue #6418\n4.9.0 (2021-06-29) - Support for marking a single field validation error as fixed It is now possible to mark a previous validation error as fixed by using the prefix *FIXED* in front of the original error. documentation on how to implement the functionality (in Norwegian )\n4.8.0 (2021-06-22) - Application version number available in AppSettings During app deployment an environment variable with the app version number/name is added to the app runtime environment. This version information can now be retrieved in any controller or service through the AppSettings configuration object. Just add a dependency on AppSettings into the class and access the new property called AppVersion.\n4.7.1 (2021-06-15) - Adjustments to response headers Some of the controllers exposed by the applications have been modified to not allow caching and/or storage of their responces in the client.\n4.7.0 (2021-06-08) Altinn Apps now authorize access for statless apps.\nAltinn Apps now have two new application events where application developers can add data processing logic. calculation, population, and more.\nIn this update the RunCalculate application event is made obsolete/deprecated. It\u0026rsquo;s recommended that Apps are updated to use RunProcessDataWrite and RunProcessDataRead instead. Calls to the RunCalculate method will be removed in a future update.\nThe process to update is\nAdd the DataProcessing folder and DataProcessingHandler class from our app template to your app. Update App.cs. Add a class field for DataProcessingHandler and copy new methods ( RunProcessDataRead and RunProcessDataWrite) from App.cs Move logic from calculation handler to DataProcessinghandler Remove RunCalculation method from App.cs Remove CalculationHandler when code has been moved to DataProcessingHandler. Compile and test your app. See details about data processing here\n4.6.2 (2021-06-01) - Duplicate keys in options causing crash This release has a fix for a crash related to PDF rendering when an app has options with duplicate entries. #5887\n4.6.1. (2021-05-21) Changed alternative subject Altinn Apps now uses org instead of organization as subject when publishing events.\n4.6.0 (2021-05-11) - Apps now support data fields Altinn Apps now support data fields. Data fields allows for adding data values, from either form fields or a custom source, to the instance object. Form data can be added by configuring data fields in applicationmetadata.json while custom sources require coding. Documentation on how to add data values to an instance can be found here.\n4.5.2 (2021-05-04) - Endpoints for stateless data elements exposed through app. Bug stopping local testing fixed Altinn Apps now expose endpoints for creating, prefilling and running calculations on stateless data elements. A stateless data element entails there is no link to an instance or instance owner, and the data is simply presented to the end user, but not persisted in any database.\nIn addition, a bug breaking apps running with localtest intoduced in 4.4.1 has been fixed.\nInformation on the new endpoints can be found in the swagger exposed by each application https://{org}.apps.altinn.no/{org}{app}/swagger\n4.4.1 (2021-04-30) - Ask user to upgrade security level An app would show the \u0026ldquo;unknown error\u0026rdquo; message if a user were trying to access an instance with a security level that was too low for the instance. This has been fixed. The user is now sent to authentication with the option to pick an authentication method that provides a higher security level. The fix targets the GET instance endpoint specifically.\n4.4.0(2021-04-27) - Performance fix Improved performance.\n4.3.0 (2021-04-28) - Apps now support presentation fields Altinn Apps now support presentation fields. By specifying presentation fields in applicationmetadata.json, speficied data values from the form data will be stored on the instance in order to show them along with the app title in the Altinn messagebox. Further documentation on how to configure presentation fields is found here.\nThis change is related to this epic.\n4.2.0 (2021-04-19) - Possible to integrate an app with eFormidling Altinn Apps now support integration with eFormidling. Documentation on how to set up an application to use eFormidling will be published once an integration point for eFormidling is set up in Altinn Platform.\n4.1.0 (2021-04-07) - Add new property with updated data to response for PUT to DataController During PUT of data to DataController ({org}/{app}/instances/{instanceOwnerPartyId:int}/{instanceGuid:guid}/data), any calculations that are defined by the apps are run, and data is potentially updated before being saved. Previously, the response returned only the metadata for the updated data element, and a GET to fetch the updated data was necessary. In this version, a dictionary of all the fields that have updated data from calculations is returned as a new parameter in the API response (in addition to the data element metadata), so that clients do not need to perform the additional GET request in order to get the updated data.\nThis change is related to this issue.\n4.0.3 (2021-03-23) - Fixed a bug reading filename from Content-Disposition The specification for Content-Disposition specify that filename should be in quotes. This was not supported by the app backend API, causing requests following the specification to fail. This has been fixed. Added support for filename* (FilenameStar). If Content-Disposition contain both filename and filename*, the value defined by filename* will be used. 4.0.1 (2021-03-15) - Upgraded application to .Net 5 and grouped references of Altinn App and Altinn Platform services in Startup.cs Altinn.App.* librarires target .Net 5 now, which requires that the application does the same. In addition we have created two methods for referencing all app and platform sevices in Startup.cs\nSee breaking changes for how to update you app to be compatible with this version.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v5/whats-new/",
	"title": "Hva er nytt?",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i versjon 5.",
	"content": "5.3.0 (21.06.2022) - Støtte for automatisk sletting av dataelementer Denne releasen introduserer støtte for automatisk sletting av dataelementer når prosessen avsluttes. Dette er en måte å begrense sluttbrukers tilgang på data etter at prosessen er avsluttet.\nKonfigurasjon gjøres i applicationmetadata.json. Legg til \u0026quot;autodeleteOnProcessEnd\u0026quot;:true i appLogic-seksjonen til datatypen.\nEn ferdigkonfigurert datatype vil kunne se slik ut:\n{ \u0026#34;id\u0026#34;: \u0026#34;VedleggB\u0026#34;, \u0026#34;taskId\u0026#34;: \u0026#34;Task_1\u0026#34;, \u0026#34;maxSize\u0026#34;: 25, \u0026#34;maxCount\u0026#34;: 1, \u0026#34;minCount\u0026#34;: 1, \u0026#34;appLogic\u0026#34;: { \u0026#34;autoDeleteOnProcessEnd\u0026#34;: true } } 5.2.0 (07.06.2022) - Api for hvilke språk som er tilgjengelige Features Denne releasen introduserer nye api endepunkter som gir informasjon om hvilke språk en applikasjon støtter. Ref. kommende funksjonalitet for å velge språk 5.1.0 (23.05.2022) - Support for anonymous stateless apps Features Denne releasen gir mulighet for å benytte såkalte stateless applikasjoner, dvs. applikasjoner som ikke oppretter instanser, for brukere som ikke er logget inn. Dette er spesielt nyttig når man utvikler guider hvor brukeren svarer på ulike spørsmål for å bli guidet frem til rett løsning, men hvor du som en tjenesteeier ikke trenger at det lagres en instans som resultatet av den prosessen brukeren går gjennom. Muligheten til å benytte Altinn 2 kodelister fra Altinn 3 app. Bugfixes En fiks for sporvalg som ikke virket i stateless applikasjoner. En fiks hvor det ble kastet en null pointer exception exception was thrown in /{org}/{app}/instances/{instanceOwnerPartyId}/active når instansen ble initialisert fra api. En fiks som gjør at alle typer filer er tillatt lastet opp når content type ikke er spesifisert. "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v6/whats-new/",
	"title": "Hva er nytt?",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i versjon 6.",
	"content": "6.0.2 Dependency oppdatering og bugfix Oppdatert eformidling avhengighet til 1.3.2 i #13\nFjernet autentisering på redirect endepunkt i #15\nSe release på github\n6.0.1 Feilretting for endringer i repeterende grupper Denne versjonen fikser en feil hvor endringer som legger til/fjerner rader i en repeterende gruppe via ProcessDataWrite() ville føre til en uventet verdi i changedFields-egenskapen i API-responsen. Etter denne feilrettingen skal verdier i changedFields-egenskapen vise endringer i rader i repeterende grupper, og rader som blir fjernet via ProcessDataWrite() får tidligere verdier satt til null.\n6.0.0 .Net 6 oppgradering Oppdaterer App til .Net 6. Se Breaking\nSe breaking changes for hvordan oppdatere app til å bli kompatibel med denne versjonen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/app-nuget/v7/whats-new/",
	"title": "Hva er nytt?",
	"tags": [],
	"description": "Oversikt over endringer som ble introdusert i versjon 7.",
	"content": "\rKun hovedversjonen er beskrevet her. Etter versjon 7.0.0 blir minor og patch releaser kun beskrevet i release notes på GitHub.\n7.0.0 Features Forenklet app template. Det meste av kode er flyttet ut av templaten og inn i nugets. Redusert antall Altinn nugets fra to til tre. Mulig å skrive separat logikk for når en steg i prosessen er avbrutt. Tidligere ble samme kode som når et steg var ferdig kjørt. Mulig å skrive legge til egen logikk når et steg i prosessen starter. Denne koden blir kjørt før Altinn sin standard logikk. Bugfixes PDF generering støtter nå dynamiske options i repeterende grupper "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/ux/fields/settings/",
	"title": "Innstillinger for felt",
	"tags": [],
	"description": "Innstillinger for tekster knyttet til et felt.",
	"content": "Oppsett av denne funksjonaliteten må gjøres manuelt direkte i form layout inntil videre.\nMERK: Denne funksjonaliteten krever app-frontend versjon 3. Se denne lenken.\nIndikere at felt er valgfritt Det er mulig å styre om et felt er markert som valgfritt eller ikke. Normal oppførsel er at felt som er påkrevd er markert med en *, valgfrie felter har ingen markering.\nNormal oppførsel kan overstyres ved hjelp av innstillinger knyttet til feltbeskrivelsen. Dette gjøres via labelSettings på en komponent i form layout.\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;labelSettings\u0026#34;: { \u0026#34;optionalIndicator\u0026#34;: true } } } Ved å sette optionalIndicator til true vil teksten (Valgfri) bli vist bak ledeteksten til feltet.\nDet er ikke mulig å tvinge visning av Valgfri teksten på et felt som er obligatorisk. Denne innstillingen styrer ikke feltets faktiske egenskaper.\nKonfigurasjon av automatisk lagring Input-komponenter, TextArea-komponenter og AddressComponent lagrer automatisk endringer når brukeren skriver. I utgangspunktet skjer dette 400 millisekunder etter brukeren sist stoppet å skrive. Når lagring av feltet starter, vil også valideringer og triggere kjøres. I tilfeller hvor disse valideringene og triggere bruker mye resursser kan det være ønskelig å øke tiden det tar det før data i feltet lagres automatisk - eller at denne funksjonaliteten skrus av.\nFunksjonaliteten styres av saveWhileTyping-nøkkelen til en komponent i form layout. I eksempelet under vil det ta 2 sekunder fra brukeren slutter å skrive i feltet til dataene lagres.\n{ { \u0026#34;id\u0026#34;: \u0026#34;input-felt-1\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;saveWhileTyping\u0026#34;: 2000 } } Hvis denne nøkkelen blir satt til false skrus funksjonaliteten av, og lagring vil skje først når brukeren forlater feltet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/instance/",
	"title": "Instans",
	"tags": [],
	"description": "Hvordan gjøre endringer på applikasjonsinstanser",
	"content": "Denne siden er foreløpig ikke fullstendig, mer informasjon vil komme på et senere tidspunkt.\nEn instansiert applikasjon vil ha et tilhørende instans-objekt. Dette objektet inneholder metadata om den spesifikke instansen. Om du ønsker å lære mer om instans og api\u0026rsquo;et rundt så kan du lese teknisk dokumentasjon om dette under API.\nSubstatus Som app-eier kan man sette en substatus på instansen, dette for å kunne gi sluttbruker ytterligere informasjon om hvilken tilstand instansen befinner seg i. Substatus vil vises frem både i meldingsboksen i Altinn og på kvitteringssiden.\nSubstatusen er et objekt som kan settes på instansobjektet. Hvordan dette gjøres står beskrevet under API. Substatus er et enkelt objekt som inneholder label og description. Disse feltene kan enten inneholde ren tekst, eller en tekstnøkkel som referer til applikasjonstekstene. Verdt å merke seg at vi ikke støtter variabler i tekst for disse tekstene. I meldingsboksen er det satt en begrensning på 25 tegn på label, og inneholder label mer enn 25 tegn vil bare de 22 første tegnene bli brukt og \u0026ldquo;\u0026hellip;\u0026rdquo; lagt til på slutten.\nEksempel på et substatus-objekt:\n{ \u0026#34;label\u0026#34;: \u0026#34;some.label\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Beskrivelse i klarteskst\u0026#34; } Under ser du du eksempler på hvordan substatus ser ut i meldingsboksen og i kvitteringen hvor substatusen er satt opp på følgende måte:\n{ \u0026#34;label\u0026#34;: \u0026#34;Godkjent\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Din søknad er godkjent av kongen.\u0026#34; } Automatisert sletting av utkast Som applikasjonseier kan man i noen tilfeller ønske å slette sluttbrukerens utkast av en tjeneste dersom det har gått en viss tid siden instansiering. For å oppnå dette er det tre steg som må tas.\nApplikasjonen må konfigureres slik at tjenesteeier har lov til å slette instanser Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Slette instans via endepunkt eksponert i applikasjonen Steg 1: Konfigurasjon av applikasjon Standarden for en applikasjon er at tjenesteeier ikke har lov til å slette instanser. For å få lov til dette må det legges til en ny regel i policy.xml den finnes i App/config/authorization. Regelen kan kopieres fra regelbiblioteket.\nSteg 2: Identifiser hvilke instanser som ikke er fullført v.h.a. spørring mot storage Storage eksponerer et sett med queryparametre som kan brukes når man skal hente ut et sett med instanser. i eksempelet nedenfor får man ut alle instanser som av en gitt applikasjon som er instansiert 30. september 2020 eller tidligere, og som enda står i utfyllingssteget.\nHer kan man prøve seg litt fram for å finne de rette queryparameterene for akkurat deres tjeneste.\nHTTP GET https://platform.altinn.no/storage/api/v1/instances?appId={org}/{app}\u0026amp;created=lte:2020-09-30\u0026amp;process.currentTask=Task_1\nSteg 3: Slette instans via endepunkt eksponert i applikasjone Når man har identifisert instansene som skal slettes er det en smal sak å sende et kall til applikasjonen for å få slettet disse. Da må id på instansen (instanceOwner.partyId/instanceGuid) oppgis.\nHTTP DELETE https://ttd.apps.altinn.no/ttd/apps-test/instances/{instanceOwner.partyId}/{instanceGuid}\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/instantiation/",
	"title": "Instansiering",
	"tags": [],
	"description": "Hvordan legge til logikk som skal kjøres ved instansiering?",
	"content": "Introduksjon Applikasjonslogikk knyttet til instansiering kan defineres i InstantiationHandler.cs. For en helt ny app vil det være to funksjoner implementert i denne klassen:\nRunInstantiationValidation - lag egne sjekker for å avgjøre om en bruker/avgiver får lov til å instansiere. DataCreation - lag tilpasset prefill data. Egendefinerte valideringsregler for instansiering Som tidligere nevnt, kan sjekker for instansiering defineres i RunInstantiationValidation. Tilgang til Register- og Profile-tjenester er inkludert i InstantiationHandler.cs-filen, som tillater å gjøre sjekker mot disse. Valideringsregler for instansiering kan innebære å validere tidspunkt til spesifikke brukerrestriksjoner og komplekse sjekker som krever eksterne API-kall.\nEksempel 1 - Insansiering kun tillatt før kl 15:00 på en gitt dag public async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { DateTime now = DateTime.Now; if (now.Hour \u0026lt; 15) { return new InstantiationValidationResult() { Valid = false, Message = \u0026#34;ERROR: Instantiation not possible before 3PM.\u0026#34; }; } return null; } Eksempel 2 - Instansiering kun tillatt for applikasjonseier Kodebasen som eksempelet er basert på er tilgjengelig her. (krever innlogging i altinn.studio)\nFor å kunne begrense instansiering til en gitt entitet, i dette tilfellet applikasjonseier, er det to filer som må endres: App.cs og InstantiationHandler.cs.\nI App.cs tilgjengeliggjøres http-konteksten og brukerdata (claims principals) hentes ut fra konteksten ved å kalle _httpContext.User.\nFor å validere instansieringen kan man sjekke ett av to claims i konteksten. Enten organisasjonsen trebokstavsforkortelse eller organisasjonsnummeret. Valideringen skjer i InstantiationHandler.cs og eksempelet nedenfor bruker organisasjonsforkortelsen.\nFor å validere basert på organisasjonsnummer kan du følge eksempelet nedenfor, og bytte ut AltinnCoreClaimTypes.Org med AltinnCoreClaimTypes.OrgNumber.\nom må gjøres i denne file ser du nedenfor.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance, ClaimsPrincipal user) { var result = new InstantiationValidationResult(); string org = string.Empty; if (user.HasClaim(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org)) { Claim orgClaim = user.FindFirst(c =\u0026gt; c.Type == AltinnCoreClaimTypes.Org); if (orgClaim != null) { org = orgClaim.Value; } } if (!string.IsNullOrWhiteSpace(org) \u0026amp;\u0026amp; org.Equals(\u0026#34;ttd\u0026#34;)) { result.Valid = true; } else { result.Valid = false; result.Message = \u0026#34;Only ttd is allowed to instantiate this application.\u0026#34;; } return await Task.FromResult(result); } Eksempel 3 - Instansiering kun tillatt mellom gitte datoer For å kunne begrense instansiering til en gitt tidsrom, i dette eksempelet januar 2021, er det én fil som må endres:InstantiationHandler.cs.\nMetoden RunInstantiationValidation vil kjøre hver gang noen prøver å instansiere applikasjonen, så her plasseres logikk for å verifiere at tidspunktet er innenfor den tillatte rammen.\npublic async Task\u0026lt;InstantiationValidationResult\u0026gt; RunInstantiationValidation(Instance instance) { InstantiationValidationResult result = null; DateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); if (now \u0026lt; new DateTime(2021, 01, 01)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; } else if (now \u0026gt; new DateTime(2021, 01, 31)) { result = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated after 25.1.2021\u0026#34; }; } return await Task.FromResult(result); } Det er lagt inn logikk knyttet til datohåndtering for å forsikre oss om at det er norsk tid som gjelder og som blir brukt i valideringen.\nDateTime now = TimeZoneInfo.ConvertTime(DateTime.UtcNow, TimeZoneInfo.FindSystemTimeZoneById(\u0026#34;Central European Standard Time\u0026#34;)); Videre gjøres det en enkel sjekk for å se om nåværende tidspunkt er innenfor rammene\n(now \u0026lt; new DateTime(2021, 01, 01) Dersom man ikke oppfyller kravene blir returobjektet populert med et InstantiationValidationResult objekt som inneholder to felter: Valid: en boolean som benyttes for å si om instansieringen er gyldig eller ikke Message: en string som kan inneholde en feilmelding dersom det ikke er gyldig\nresult = new InstantiationValidationResult { Valid = false, Message = \u0026#34;Application cannot be instantiated before 1.1.2021\u0026#34; }; I tillegg har man muligheten til å legge benytte property ValidParties: en liste med de partiene som kan instansiere applikasjonen.\nResultatet av en feilet validering er vist nedenfor:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/calculation/",
	"title": "Kalkuleringer",
	"tags": [],
	"description": "Hvordan legge til kalkuleringer?",
	"content": "\r⚠ ️Kalkulering er fra 4.7.0 erstattet av dataprosessering\nKalkulering Kalkuleringer kjøres på serveren, og er basert på input fra sluttbruker/skjemadata. Kalkuleringer trenger ikke å være rent matematiske, det kan også være å overføre verdier mellom felter, resultater av API-kall, osv.\nKalkuleringer kodes i C#, i filen CalculationHandler.cs. Denne filen kan redigeres enklest ved å laste ned kildekoden til app\u0026rsquo;en og redigere på egen maskin, f.eks. i Visual Studio Code. Datamodellen med skjemadata er tilgjengelig og kan redigeres/oppdateres etter ønske/behov.\nKalkuleringer kjøres hver gang data lagres. Med auto-lagring på (dette er standard) vil kalkulering kjøres hver gang en bruker har gjort en endring.\nVIKTIG: Når en kalkulering er kjørt som har oppdatert dataene på server, må front-end få beskjed om dette, sånn at de oppdaterte dataene kan lastes inn. For å gjøre dette, må Calculate-metoden returnere true om det er noen av dataene som har blitt oppdatert. Hvis dette ikke gjøres, vil de oppdaterte dataen ikke være synlig for sluttbruker før de ev. laster inn siden på nytt.\rEksempel på kode som erstatter en gitt verdi (12345678) med en annen verdi (22222222) i et gitt felt vises under:\npublic bool Calculate(object data) { if (data.GetType() == typeof(Skjema)) { // Cast the data object to model type to access all fields Skjema model = (Skjema)data; // Get the existing value of a specified field, if it exists string tlf = model? .OpplysningerOmArbeidstakerengrp8819? .OpplysningerOmArbeidstakerengrp8855? .OppgavegiverTelefonnummerdatadef27335?.value; // Check if the value exists and is equal to \u0026#34;12345678\u0026#34; if (tlf != null \u0026amp;\u0026amp; tlf == \u0026#34;12345678\u0026#34;) { // Replace the value in the field with a new value, \u0026#34;22222222\u0026#34; model .OpplysningerOmArbeidstakerengrp8819 .OpplysningerOmArbeidstakerengrp8855 .OppgavegiverTelefonnummerdatadef27335.value = \u0026#34;22222222\u0026#34;; // Return true to trigger a re-loading of data return true; } } // Return false if no changes have been made return false; } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/kodelister/",
	"title": "kodelister",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/api/consume/",
	"title": "Konsumere APIer i en app",
	"tags": [],
	"description": "En applikasjon kan konsumere åpne og lukkede API som er tilgjengelig via Internett.",
	"content": "ASP.NET Core har gode muligheter til å konsumere API.\nDette kan være nyttig dersom man ønsker å eksponere organisasjonens egne API via en app eller har behov for data fra eksterne API i appen.\nPå denne siden går vi gjennom et eksempel hvor et eksternt, åpent API benyttes til å berike skjemadata. Eksempelappen kan sees i sin helhet i Altinn Studio.\nAPIet som benyttes er RestCountries v3 og det er endepunktet https://restcountries.com/v3.1/name/{country} vi er interessert i. Dette returnerer et sett med detaljer om landet som er oppgitt.\nDu kan studere responsen ved å kalle APIet fra nettleseren din: https://restcountries.com/v3.1/name/Norway.\nVi ønsker å berike skjemaet med detaljer om et land som sluttbruker har fylt inn.\nOpprettelse av API modeller Dersom API-et som skal konsumeres er dokumentert med Swagger eller OpenAPI kan man enkelt genere C# klasser basert på datamodellen. Dette kan gjøres manuelt eller ved hjelp av verktøy som tilbyr slik generering.\nI dette eksempelet er responsobjektet stort og inneholder langt mer data enn den vi er interessert i.\nHer er et lite utklipp av responsobjektet for Norge.\n[ { \u0026#34;name\u0026#34;: { \u0026#34;common\u0026#34;: \u0026#34;Norway\u0026#34;, \u0026#34;official\u0026#34;: \u0026#34;Kingdom of Norway\u0026#34;, \u0026#34;nativeName\u0026#34;: {} }, \u0026#34;idd\u0026#34;: {}, \u0026#34;capital\u0026#34;: [ \u0026#34;Oslo\u0026#34; ], \u0026#34;altSpellings\u0026#34;: [], \u0026#34;region\u0026#34;: \u0026#34;Europe\u0026#34;, \u0026#34;subregion\u0026#34;: \u0026#34;Northern Europe\u0026#34;, \u0026#34;languages\u0026#34;: {}, \u0026#34;translations\u0026#34;: {}, \u0026#34;latlng\u0026#34;: [ 62, 10 ], \u0026#34;landlocked\u0026#34;: false, \u0026#34;borders\u0026#34;: [], \u0026#34;area\u0026#34;: 323802, \u0026#34;demonyms\u0026#34;: {}, \u0026#34;flag\u0026#34;: \u0026#34;🇳🇴\u0026#34;, \u0026#34;maps\u0026#34;: {}, \u0026#34;population\u0026#34;: 5379475, \u0026#34;postalCode\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;###\u0026#34;, \u0026#34;regex\u0026#34;: \u0026#34;^(\\\\d{4})$\u0026#34; } } ] I applikasjonen ønsker vi kun å ta med oss dataen på de markerte linjene, altså hovedstad og region. Vi lager et minimalistisk responsobjekt som kun inneholder de feltene vi er interessert i.\nI mappen App/models opprettes det en ny fil Country.cs.\nusing System.Collections.Generic; namespace Altinn.App.models { public class Country { public List\u0026lt;string\u0026gt; Capital { get; set; } public string Region { get; set; } } } Country-objektet består av feltene Capital og Region. Capital er en liste med strenger, da et land kan ha flere hovesteder.\nI dette eksempelt krever ikke APIet et komplekst request-objekt og dermed kan vi nøye oss med den ene modellen. Skulle det være behov for et request-objekt kan dette opprettes på samme måte.\nOppsett av interface for klienten Det er anbefalt å definere et interface for klienten som skal kalle APIet. Det gjør at vi kan benytte oss av styrkene til .NET med dependency injection og effektiv håndtering av HTTP-klienter.\nI applikasjonsrepoet opprettes mappen App/clients, i den nye mappen opprettes filen ICountryClient.cs.\nInterfaces består av én metode GetCountry som tar inn en streng og returnerer et Country-objekt.\nDefiner interfacet som vist nedenfor.\nusing System.Threading.Tasks; using Altinn.App.models; namespace Altinn.App.client { public interface ICountryClient { /// \u0026lt;summary\u0026gt; /// Retrieves metadata about the provided country. /// \u0026lt;/summary\u0026gt; /// \u0026lt;param name=\u0026#34;country\u0026#34;\u0026gt;The name of the country\u0026lt;/param\u0026gt; /// \u0026lt;returns\u0026gt;A country object\u0026lt;/returns\u0026gt; public Task\u0026lt;Country\u0026gt; GetCountry(string country); } } Returobjektet er omkranset av Task\u0026lt;...\u0026gt; denne er lagt inn for å vise til at kallet som skal gjøres vil være asynkront.\nImplementere klient Det er klienten som inneholder koden som gjør kallet mot APIer og omformer resultatet til Country-modellen som forventes i retur av funksjonene som kaller klienten.\nDen fulle implementasjonen av Country-klienten er vist nedenfor.\nusing System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; using Altinn.App.models; using Microsoft.Extensions.Logging; namespace Altinn.App.client { public class CountryClient : ICountryClient { HttpClient _client; ILogger\u0026lt;ICountryClient\u0026gt; _logger; JsonSerializerOptions _serializerOptions; public CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; } public async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); return countryResponse.Any() ? countryResponse.First() : null; } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } } } Øverst i filen finner du referansen til alle namespace som klassen er avhengig av\nusing System; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; using Altinn.App.models; using Microsoft.Extensions.Logging; Videre definerer vi klassen og hvilket interface den arver fra\npublic class CountryClient : ICountryClient Videre er tre private objekter _client, __logger og _serializerOptions\nprivate readonly HttpClient _client; private readonly ILogger\u0026lt;ICountryClient\u0026gt; _logger; private readonly JsonSerializerOptions _serializerOptions; Understrek foran navnet er kun en navnekonvensjon og har ingen effekt.\n_client vil i konstruktøren populeres med en http-klient. _logger vil i konstruktøren populeres med en logger slik at man kan logge feilmeldinger og annet i klassen _serializerOptions vil i konstruktøren instansieres og konfigureres for å kunne deserialisere responsen fra APIet. Videre i klassen defineres konstruktøren.\npublic CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; } Objekter populeres dersom de kommer som input i konstruktøren og andre objekter instansieres. Skulle du ha behov for å bruke en av de andre servicene som er registeret i applikasjonen er det bare å sende den inn i konstruktøren og opprette et privat objekt for å kunne ta det i bruk i klassen slik vi har gjort med _logger eller _client.\nVidere i klassen finner du implementasjonen av metoden GetCountry.\npublic async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); return countryResponse.Any() ? countryResponse.First() : null; } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } Her gjøres det en sjekk på at statuskoden på API-kallet er en suksess-kode før vi deserialiseres og returnerer objektet. Dersom det ikke er en suksess-statuskode logger vi en feil og returnerer null.\nRegistrere klienten i applikasjonen Når interface og klient er implementert kan den registreres i App/Program.cs (.NET 6) eller i App/Startup.cs (.NET 5) for bruk i applikasjonen.\nI Program.cs klassen legger vi til kodelinjen nedenfor. I tillegg må using Altinn.App.client; og using Altinn.App.AppLogic.DataProcessing; legges til øverst i filen.\nvoid RegisterCustomAppServices(IServiceCollection services, IConfiguration config, IWebHostEnvironment env) { services.AddHttpClient\u0026lt;ICountryClient, CountryClient\u0026gt;(); services.AddTransient\u0026lt;IDataProcessor, DataProcessor\u0026gt;(); // Register your apps custom service implementations here. } Benytte klient i applikasjonslogikk For å berike skjemadata må vi koble klienten vår på logikken i App/logic/DataProcessingHandler.cs i metoden ProcessDataWrite. Merk at for v7 av applikasjonsmalen er dette endret, se dataprossessering.\nFørst må klienten tilgjengeliggjøres ved å injecte den inn i konstruktøren til klassen. DataProcessingHandler har ingen konstruktør i utgangspunktet så den må opprettes i klasse.\npublic DataProcessingHandler() { } Videre kan vi opprette et privat objekt for klienten, injecte den i konstruktøren og assigne den til det private objektet. Resultatet blir seende slik ut:\nprivate readonly ICountryClient _countryClient; public DataProcessingHandler(ICountryClient countryClient) { _countryClient = countryClient; } I tillegg må using Altinn.App.client; legges til også i denne filen.\n_countryClient er nå tilgjengelig i DataProcessingHandler og vi er klare til å implementere logikken i ProcessDataWrite.\nMERK: Stateless apps kaller ikke på ProcessDataWrite. Bruk ProcessDataRead for statless apps.\rpublic async Task\u0026lt;bool\u0026gt; ProcessDataWrite(Instance instance, Guid? dataId, object data) { if (data.GetType() == typeof(skjema)) { skjema skjema = (skjema)data; if (!string.IsNullOrEmpty(skjema.land)) { Country country = await _countryClient.GetCountry(skjema.land.Trim()); if (country != null) { skjema.hovedstad = string.Join(\u0026#34;,\u0026#34;, country.Capital); skjema.region = country.Region; } else { skjema.hovedstad = skjema.region = string.Empty; } return true; } else { skjema.hovedstad = string.Empty; skjema.region = string.Empty; } } return await Task.FromResult(false); } Prøver du å bygge applikasjonen nå vil du få en feil. DataProcessingHandler instansieres i App.cs, så alle dependecies må og inn i denne filen og så sendes videre i konstruktøren til DataProcessingHandler.\nI filen App/logic/App.cs gjøres følgende endringer\nlegg til en referanse til namespaces til klienten øverst i filen\nusing Altinn.App.client; Inject ICountryClient nederst i App.cs-konstruktøren.\nDette er gjort på linje 14.\n1public App( 2 IAppResources appResourcesService, 3 ILogger\u0026lt;App\u0026gt; logger, 4 IData dataService, 5 IProcess processService, 6 IPDF pdfService, 7 IProfile profileService, 8 IRegister registerService, 9 IPrefill prefillService, 10 IInstance instanceService, 11 IOptions\u0026lt;GeneralSettings\u0026gt; settings, 12 IText textService, 13 IHttpContextAccessor httpContextAccessor, 14 ICountryClient countryClient) : base( 15 appResourcesService, 16 logger, 17 dataService, 18 processService, 19 pdfService, 20 prefillService, 21 instanceService, 22 registerService, 23 settings, 24 profileService, 25 textService, 26 httpContextAccessor) Legg til countryClient i konstruktøren til DataProcessingHandler\n_dataProcessingHandler = new DataProcessingHandler(countryClient); Caching av responsdata En ulempe med eksempelet slikt det står nå er at man for hver gang skjemaet lagres vil man gjøre et kall mot endepunktet for å hente ut data.\nDet er rimelig å anta at et lands hovedstad og hvilken region det tilhører ikke vil endre seg hyppig. Har vi hentet informasjon om Norge kan vi lagre denne lokalt i applikasjonen i en tidsperiode, så man slipper å gjøre kallet igjen.\nKodeendringene beskrives ikke steg for steg, men er vist i sin helhet nedenfor. Det kreves kun endringer i CountryClient.cs.\nusing Altinn.App.models; using Microsoft.Extensions.Caching.Memory; using Microsoft.Extensions.Logging; using System; using System.Collections.Generic; using System.Linq; using System.Net.Http; using System.Text.Json; using System.Threading.Tasks; namespace Altinn.App.client { public class CountryClient : ICountryClient { private readonly HttpClient _client; private readonly ILogger\u0026lt;ICountryClient\u0026gt; _logger; private readonly JsonSerializerOptions _serializerOptions; private readonly IMemoryCache _memoryCache; private readonly MemoryCacheEntryOptions _cacheOptions; public CountryClient(HttpClient client, ILogger\u0026lt;ICountryClient\u0026gt; logger, IMemoryCache memoryCache) { _logger = logger; _client = client; _client.BaseAddress = new Uri(\u0026#34;https://restcountries.com/v3.1/\u0026#34;); _serializerOptions = new() { PropertyNameCaseInsensitive = true }; _memoryCache = memoryCache; _cacheOptions = new() { AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(24) }; } public async Task\u0026lt;Country\u0026gt; GetCountry(string country) { string uniqueCacheKey = \u0026#34;Country_\u0026#34; + country; // Check if country is present in cache, if so return from cache if (_memoryCache.TryGetValue(uniqueCacheKey, out Country outputCountry)) { return outputCountry; } string query = $\u0026#34;name/{country}\u0026#34;; HttpResponseMessage res = await _client.GetAsync(query); if (res.IsSuccessStatusCode) { string resString = await res.Content.ReadAsStringAsync(); List\u0026lt;Country\u0026gt; countryResponse = JsonSerializer.Deserialize\u0026lt;List\u0026lt;Country\u0026gt;\u0026gt;(resString, _serializerOptions); if (countryResponse.Any()) { outputCountry = countryResponse.First(); // Add response country to cache _memoryCache.Set(uniqueCacheKey, outputCountry, _cacheOptions); return outputCountry; } else { return null; } } else { _logger.LogError(\u0026#34;Retrieving country {country} failed with status code {statusCode}\u0026#34;, country, res.StatusCode); return null; } } } } "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/konsumere-api/",
	"title": "konsumere API",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/technology/solutions/altinn-platform/receipt/",
	"title": "Kvittering",
	"tags": ["platform", "register"],
	"description": "Kvitteringskomponenten i Altinn Platform viser kvittering for apper.",
	"content": "Kvitteringskomponenten er laget for å vise en kvittering for alle apper. Noen apper vil fjernes fra Altinn Apps med tiden, men innsendte data vil likevel være tilgjengelig, og Kvitteringskomponenten er ansvarlig for å vise en generisk kvittering for innsendte data uavhengig av applikasjonen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/localtest/",
	"title": "localtest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/technology/solutions/",
	"title": "Løsningene",
	"tags": [],
	"description": "Den nyeste generasjonen Altinn-plattform lar deg bygge, teste, kjøre og overvåke dine digitale tjenester i skyen.",
	"content": "Plattformen består av flere løsninger for å understøtte dette.\nAltinn Studio Altinn Studio er løsningen for å utvikle, vedlikeholde, bygge og distribuere applikasjoner. Applikasjoner som er opprettet kan dekke enkle og komplekse brukerscenarier og har moderne arkitektur.\nLes mer om Altinn Studio\nAltinn Apps Altinn Apps er en fleksibel og skalerbar infrastruktur for container baserte applikasjoner laget i Altinn Studio.\nLes mer om Altinn-apper\nAltinn Plattform Altinn Plattform inneholder komponenter med sentral funksjonalitet som apper og andre konsumenter kan nyttigjøre.\nFunksjonalitet inkluderer lagring, autentisering, autorisasjon, profil, register, kvittering, pdf og hendelser.\nLes mer om Altinn-plattformen\nAltinn App Mal Altinn App-malen er en applikasjonsmal med funksjonalitet for de vanligste scenariene for digitale tjenester.\nAltinn Studio baserer alle apper på denne malen. I tillegg inneholder malen integrasjon med Altinn Platform for å kunne nyttigjøre seg funksjonaliteten i Altinn Platform raskt og effektivt\nLes mer om Altinn App Template\nAltinn CLI Altinn CLI er en kommandolinjeapplikasjon som appeiere kan bruke for å få tilgang til Altinn APIer.\nLes mer om Altinn CLI\nAltinn ReStorage Altinn ReStorage er en kommandolinjeapplikasjon som operatører kan bruke til å gjenopprette og gjenopprette data fra Altinn Platform Storage.\nLes mer om Altinn ReStorage\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/losningsforslag/",
	"title": "losningsforslag",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/about/goals/",
	"title": "Mål",
	"tags": [],
	"description": "Oppsummering av målene for Altinn 3.",
	"content": "Brukervennlige og responsive applikasjoner Brukergrensesnitt som er vennlig, effektivt og moderne. Støtte for responsivt design, både for tjenestene og tjenesteutviklingsverktøyet. Innebygd universell utforming med støtte for WCAG 2 God ytelse og lave responstider Effektiv og selvbetjent tjenesteutvikling Som utvikler kan du gjøre alt selv (inkludert å sette tjenesten i produksjon) når du vil, uten bestillinger, kursing eller lignende. Ingen flaskehalser. Effektiv og reell testing, der enhetstesting lokalt fungerer likt som i testmiljøer og produksjon Støtte for automatisert testing Regler og logikk defineres én gang for alle kanaler (portal og API), og er mer robust enn i gammel plattform Innebygd datamodelleringsverktøy (og støtte for import av modeller fra eksterne verktøy som SERES, OR, osv. ) Ikke behov for Citrix for å få tilgang til Altinn Studio Enkelt for ikke-tekniske utviklere, fleksibelt for tekniske utviklere Ikke-tekniske apputviklere har tilgang på relevant funksjonalitet i det nettleserbaserte grensesnittet til Altinn Studio Du kan gjenbruke gode, gjennomtestede komponenter Det er enkelt å gjøre kall mot eksterne API-er, både for gjenbruk av data og for å kjøre ekstern logikk Tekniske utviklere kan konfigurere alle aspekter ved appene, for eksempel overstyre styling og lage egne komponenter Gjenbruke tekster og andre ressurser på egnet nivå (plattform, organisasjon, applikasjon), og alle språk er støttet Git brukes som kildekodehåndtering (inkludert versjonshåndtering) for appene, både fra nettleser og ved bruk av kodeeditor. Plattformuavhengig åpen kildekode Altinn 3 bygger på åpen kildekode Altinn 3 skal være åpen kildekode Altinn 3 kan kjøres på din egen maskin, dine egne servere, på Windows, macOS eller Linux Alt er basert på åpne web-standarder og god utviklingskunnskap og -praksis. "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/message/",
	"title": "Melding",
	"tags": [],
	"description": "Hvordan sette opp en melding i Altinn Studio.",
	"content": "En melding i Altinn 3 er egentlig bare et data-steg, på samme måte som f.eks. skjemautfylling. Det settes opp med en datamodell for meldingen, og en layout for hva som skal vises på siden. Melding er dermed ikke en egen steg-type. Dette gjør at en melding i Altinn 3 er ekstremt fleksibel, og kan settes opp enten som eneste steg i en prosess, eller som en del av en større prosess.\nVi har lagd noen verktøy som skal gjøre det enkelt å komme i gang med å sette opp en melding i en app.\nDatamodell Vi har lagd en standard datamodell for meldinger, for å gjøre det enkelt å komme i gang. Denne datamodellen kan man finne her. Denne kan enten brukes som den er, brukes som et utgangspunkt, eller man kan bruke en helt annen datamodell.\nLayout Layout\u0026rsquo;en kan man definere helt selv, på samme måte som for skjema. Vi har allikevel opprettet en meldings-widget, for å gjøre det enklere å komme i gang. Denne widget\u0026rsquo;en inneholder alle komponentene som trengs for å lage visningen under. Den inneholder også tekster som legges til i ressurs-filene automatisk, som har variabler med referanser til feltene Title og Body i standard datamodell. Dersom man ønsker andre tekster eller å bruke en annen datamodell, er det bare å redigere enten komponentene eller tekstene etter ønske etter at de er lagt inn i siden.\nMerk at om en ønsker å bruke vedleggslisten, som er med i standard meldings-widget, må man i tillegg manuelt legge inn hvilke datatyper vedleggene som skal vises har i layout-filen. Det er lagt inn en placeholder for dette i komponenten når den legges til med widget\u0026rsquo;en. Funksjonalitet for å sette dette i Altinn Studio vil komme senere. Tilgjengelige datatyper ligger i applicationMetadata.json-filen til appen. Om dette ikke gjøres vil ikke generering av PDF fungere.\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/migration/",
	"title": "Migrering til versjonerte charts",
	"tags": [],
	"description": "Migrering fra helm template filer til versjonert helm dependency.",
	"content": "For å forenkle oppraderings prosessen av deployment charts har vi flyttet template filene ut et sentralt repository på github. Fra her publiseres helm charts som igjen draes inn i apps repoene som avhengigheter.\nDette gir oss muligheten til å oppdatere standard måte for deploy til altinn3 i et sentralt repository og forenkler jobben for tjenesteiere ved oppgradering.\nHvordan avdekke om din app bruker gammel deployment stretegi Åpne opp appen din i gitea eller hent siste versjon ned til din datamaskin med git.\nHvis mappen som heter deployment ser ut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r├── templates\r│ ├── NOTES.txt\r│ ├── _helpers.tpl\r│ ├── deployment.yaml\r│ ├── horizontalPodAutoscaler.yaml\r│ ├── ingressRoute.yaml\r│ ├── middleware.yaml\r│ └── service.yaml\r└── values.yaml og innholdet i filen deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 Benytter din applikasjon gammel deployment strategi og du kan følte guiden for hvordan du skal oppgradere til ny her.\nHvis mappen deployment ser sut som nedenfor:\ndeployment\r├── .helmignore\r├── Chart.yaml\r└── values.yaml og innholdet i `deployment/Chart.yaml er lignende dette:\napiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Benytter din applikasjon siste deployment strategi.\nHvordan du konfigurerer din deployment er dokumentert her\nNye versjoner er tilgjengelige. Hvis det er ny major versjon må du være obs på breaking changes.\rMigrere til ny deployment strategi Migreringen er rimelig enkel og involverer bare tre endringer i mappen deployment:\nSlett mappen templates. Definer avhengigheten til den sentralt vedlikeholde helm-charten i din Chart.yaml. dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Your Chart.yaml should now look like this: apiVersion: v1 description: A Helm chart for Kubernetes # name can only be lowercase. It is used in the templats. name: deployment version: 1.1.0 dependencies: - name: deployment repository: https://charts.altinn.studio/ version: 1.1.0 Legg til en ny linje i toppen av values.yaml og skriv inn deployment: på denne linjen. Legg til to space først på hver linje etter dette (yaml behandler tab og mellomrom forskjellig så forsikre deg om at det er mellomrom). Gitt at din values.yaml ser ut som det her: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken Etter at du har gjort dine migrerings endringer bør denne se ut som følger: deployment: replicaCount: 3 image: # Set \u0026#34;repository\u0026#34; name of your image for manual Helm install and upgrade. repository: tag: latest pullPolicy: Always pullSecrets: # Change this to the name of your pull secret - name: acr-secret service: name: deployment type: ClusterIP externalPort: 80 # If your application is running on another port, change only the internal port. internalPort: 5005 linkerd: enabled: true ingressRoute: name: Will be inserted during deploy entryPoints: - http - https routes: - match: Will be inserted during deploy kind: Rule services: - name: Will be inserted during deploy port: 80 middlewares: - name: hsts-header tls: options: name: tls-options secretName: ssl-cert volumeMounts: - name: datakeys mountPath: /mnt/keys - name: accesstoken mountPath: \u0026#34;/accesstoken\u0026#34; volumes: - name : datakeys persistentVolumeClaim: claimName: keys - name: accesstoken secret: secretName: accesstoken Commit og Push dine endringer til gitea og neste deploy av din applikasjon vil være med ny deployment strategi\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/models/",
	"title": "Modeller",
	"tags": [],
	"description": "Dette er en oversikt over de fleste modellene brukt av de forskjellige APIen. Den forklarer ikke hver eneste property i alle modeller, men vil forsøke å gi en solid introduksjon til de viktigste delene.",
	"content": "\rApp metadata\rThe application metadata document holds technical information about the app and the data type requirements.\nInstance\rAn instance is a metadata container that is used to track the status and progress of one interaction between an app user and owner.\nDataElement\rEt DataElement er en metadatabeholder som brukes til å spore statusen til faktiske data blobs.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/needstranslation/",
	"title": "needstranslation",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/openapi/",
	"title": "openapi",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/apps/spec/",
	"title": "OpenAPI (swagger) for Apps",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/authentication/spec/",
	"title": "OpenAPI (swagger) for Authentication",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/events/spec/",
	"title": "OpenAPI (swagger) for Events",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/spec/",
	"title": "OpenAPI (swagger) for Storage",
	"tags": ["swagger", "openapi"],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/oed/",
	"title": "Oppgjør etter dødsfall",
	"tags": ["app"],
	"description": "Dokumentasjon av arkitektur, design, funksjonalitet og apper relatert til oppgjør etter dødsfall.",
	"content": "Innledning Figuren under viser de viktigste komponentene i løsningen. OED er realisert som en serie Tjenester 3.0 app\u0026rsquo;er med en overordnet app med skreddersydd GUI og øvrige Tjenester 3.0 apper for spesifikke formål.\nApp\u0026rsquo;ene kan ikke instansieres fra tjenestekatalogen. Hovedapp\u0026rsquo;en instansieres utelukkende fra Domstol grensesnittet, og «Altinn avgiver» (process instance owner) er avdøde. Arvinger og evt andre som skal benytte løsningen får tilgang til instansen via tildelte roller i Altinn autorisasjon. Brukeren (arvingen) finner app\u0026rsquo;en fra en melding «Altinn correspondence» i meldingsboksen i Altinn. Meldingen inneholder en direktelenke til riktig instans i Tjenester 3.0. Se for øvrig 3 Grensesnitt mot Domstolene.\nLøsningens hovedapp har følgende adresse i Altinn Studio: designer og kode.\nOppdeling i Tjenester 3.0 apper Hovedapp\u0026rsquo;en har et skreddersydd brukergrensesnitt fordi Tjenester 3.0 p.t. ikke støtter å lage vilkårlige applikasjoner. Løsningen er derfor splittet opp i flere app\u0026rsquo;er slik at mest mulig realiseres som standard tjeneste 3.0 apper. I første omgang gjelder dette skjemautfylling. På sikt kan det også være aktuelt å flytte «innsynsfunksjonalitet» ut i Tjenester 3.0 app\u0026rsquo;er, men p.t. er støtten for GUI design i Tjenester 3.0 såvidt begrenset at det er vanskelig å implementere ønsket brukeropplevelse.\nSkjema app\u0026rsquo;ene blir instansiert og preutfylt fra hovedapp\u0026rsquo;en når brukeren tar initiativ til å starte skjemautfylling. Skjemaet blir instansiert med avdøde som «Altinn avgiver» (process instance owner), og fødselsnummer til den arvingen som startet skjemautfylling blir lagt som en nøkkel på instansdataene med Tjenester 3.0 mekanismen «data value» med nøkkel «ssn».\nDet er lagt opp til at alle arvingene aksesserer de samme skjemainstansene bortsett fra skjemaet «oed-signature». I sistnevnte skjema blir det en unik instans per arving.\nAll innsending av data fra arvingene gjøres via skjema app\u0026rsquo;er. Signering ved innsending benytter derfor standard Tjenester 3.0 funksjonalitet. Hvis gjeldene funksjonalitet for signering ikke tilfredsstiller formelle krav til løsningen (f.eks. om man ønsker nivå 4 signering), må dette være utvidelser/forbedringer i Tjenester 3.0 plattformen \u0026ndash; ikke spesifikt i OED løsningen.\nFølgende app\u0026rsquo;er finnes p.t.:\noed (hoved app) oed-register-agri-property oed-register-heirs oed-register-marriage-pact oed-register-testament oed-signature Mer dokumentasjon knyttet mot applikasjoner vedrørende Tjenester 3.0 finnes her:\nOED: https://github.com/Altinn/oed/issues/442\nT3.0: https://github.com/Altinn/altinn-studio/issues/6880\nVedlikehold av subapps Det er laget en egen solution for felles vedlikehold av hovedapp og subapps. Denne ligger i repoet til hovedapp - SubApps/SubAppsMaster.sln. Sln\u0026rsquo;en refererer både hovedapp og alle subapps. Eventuelle nye subapps må også linkes inn her. Multi-repo git operasjoner kan gjøres via ny funksjonalitet i VS2022.\nScrptet SubApps/SyncItems.ps1 synkroniserer filer som vedlikeholdes i felles maler til de forskjellige subapp\u0026rsquo;ene. Følgende er p.t. implementert:\nSubApps/SubAppsMaster.csproj kopieres til App.csproj SubApps/Policy.xml kopieres til subapps etter nødvendig substituering av navn Følende må gjøres når man lager en ny subapp:\nSubapp må lenkes inn i SubAppsMaster.sln SubApps/SyncItems.ps1 må kjøres Appsettings.development.json må oppdateres i Kestrel seksjonen slik at portnummeret blir unikt på tvers av alle OED apps Grensesnitt mot Domstolene Grensesnittet for å motta data fra Domstolene er definert av Domstolene og ligger på GitHub - Altinn/oed-da. Dette er et hendelsesbasert grensesnitt med samme oppbygning som eksiterende Altinn grensesnitt mot Folkeregisteret. P.t. er det bare spesifisert overføringer av nye avdøde og arvinger, men det er forventet at grensesnittet kan utvides til endringer på avdøde og arvinger samt testamentinformasjon.\nProsjektet har besluttet å implementere grensesnittet som en Altinn II batch. Bakgrunnen for at grensesnittet ikke ble implementert i Tjenester 3.0 er:\nTjenester 3.0 støttet ikke batch jobber da beslutningen ble tat Tjenester 3.0 har ikke et regime for driftsoppfølging av batcher Tjenester 3.0 tilbyr ikke databaser for app\u0026rsquo;er utover lagring av skjemadata og instansdata. Domstol grensesnittet krever at man lagrer en tilstand mellom hver kjøring. Altinn II har ikke eksponert eksterne tjenester for å laste inn roller/rettigheter. Altinn II batch jobber kan benytte interne tjenester. Batchen kjøres automatisk ved regelmessige intervaller og gjør følgende:\nHenter nye arvinger fra Domstolene Tildeler roller mellom arving og avdøde i Altinn Autorisasjon Gjør oppslag mot KRR (Altinn kopi) angående reservasjon mot elektronisk behandling. Det er p.t. ikke avgjort om Altinn skal ha ansvar for dette og hva som eventuelt skal være konsekvensen hvis det foreligger en reservasjon. Hente utfyllende informasjon om arving og avdøde fra Folkeregisteret (Altinn kopi). Sjekke om det finnes en instans av boet. Opprette instans hvis den ikke finnes Legge arving inn blant instansdata Sende melding til arving (Altinn II Correspondence). Meldingen blir liggende i Altinn meldingsboks dyplenke inn til avdødes instans Sende varsling til arving på epost/SMS basert på informasjon fra KRR. (Gjøres som en integrert del av forrige punkt.) Batchen ligger i Altinn II repo for batcher og heter Altinn.SBL.Batch.DA.\nGrensesnitt data fra eksterne aktører Autorisasjon Nedenfor beskrives hva som ligger til grunn for autorisasjonen.\nImplisitt fullmakt fra DA (1-2)\nAltinn mottar en implisitt fullmakt fra DA (dvs at en person er en arving) ved hjelp av DA grensesnittet (1). Fullmakten lagres i Altinn (2). Fullmakten lagres logisk to steder:\nI boets instans i OED appen\nDet lagres hvem som er avdød og hvilke arvinger som har fullmakt. Se for øvrig åpne punkter nederst i dokumentet.\nSom autorisasjonsregler i Altinn sin standard autorisasjonsløsning\nDet lages en eller flere autorisasjonsregler per arving.\nAksess til eksterne ressurser fra OED basert på fullmakt (3-7)\nBasert på fullmakt fra DA kan OED hente data fra eksterne kilder på vegne av arvinger med fullmakt. OED gjør system-til-system oppslag mot eksterne kilder. Oppslagene autoriseres ved hjelp av egnet autorisasjonsinfrastruktur \u0026ndash; primært Maskinporten (3-4). Maskinporten returnerer et token (4) som sendes med til eksternt system (5). Tokenet er bevis overfor eksterne parter at forespørselen kommer fra OED. Oppslagene har nesten alltid avdødes fødselsnummer som forespørselsnøkkel (5). Eksterne systemer må stole på at OED kun gjøre forespørsel når det foreligger en fullmakt samt at OED ikke viser dataene til arvinger uten fullmakt. Avdødes fødselsnummer er nøkkel til fullmakten i OED (2).\nBeskrivelsen i dette dokumentet gjelder uavhengig av om man teknisk gjør oppslag mot eksterne kilder basert på en arvings aktivitet i portalen eller om det gjøres asynkront \u0026ndash; uavhengig av brukerinteraksjon. I figuren over er det antydet at dataene lagres i OED (7), men hvis man velger å ikke lagre dataene, påvirker ikke dette den øvrige beskrivelsen.\nVise data fra eksterne aktører til arvinger (8-12)\nDet defineres i OED hvilket krav man har til autentisering (8) av arvingene. Det er naturlig at man definerer et nivå som ID-Porten eller høyere. Alle innlogginger logges i Altinn (samt i ID-Porten eller annen ekstern infrastruktur for autentisering) (8-10). OED vet derfor alltid hvem brukeren er. OED definerer også autorisasjonsregler som gjør at det ikke er mulig for noen andre enn de som har fått autorisasjonsregler fra fullmakten å aksessere et gitt dødsbo (11). Når brukeren får tilgang til eksterne data, er disse hentet ut basert på fullmakten som foreligger fra DA, og de vises til brukeren (12) basert på autorisasjonsreglene fra fullmakten.\nRevisjonsspor\nAt de ikke blir utlevert opplysninger fra ekstern kilde uten fullmakt kan dokumenteres ved følgende revisjonsspor:\nFullmakten ligger lagret i Altinn (2). Fullmakten inkluderes saks-id fra DA. Fullmakten peker tilbake til kilden hos DA (1).\nAltinn gjør oppslag mot eksterne kilder ved hjelp av autorisasjonsinfrastruktur (primært Maskinporten) som beviser at oppslaget ble gjort fra OED (3-4). Oppslaget blir gjort med avdødes fødselsnummer som nøkkel (5-6), og samme fødselsnummer er nøkkel til fullmakten (2).\nArvingene må autentisere seg før aksess til OED (8). Alle autentiseringsforsøk blir logget i Altinn sin TTP (trusted third party) database (9-10).\nAll aksess til OED autoriseres. Alle autorisasjoner logges i altinn sin TTP (trusted third party) database (11). Autorisasjonsloggen inkluderer aktuell bruker, tidspunkt, hvilken ressurs som ble forsøkt aksessert (i dette tilfellet referanse til avdødes instans med tilhørende fullmakt i OED) og utfall av autorisasjonen.\nÅpne punkter\nSkal alle arvinger med tilgang til OED ha fullmakt? I motsatt fall må det gjøres intern autorisasjon i OED som differensierer hva slags informasjon som skal vises avhengig av hvilken arving som har logget inn.\nEr fullmakt implisitt dekket av eksisterende DA grensesnitt (ny arving foreligger i boet) eller trenger man en ny hendelse \u0026ndash; fullmakt \u0026ndash; i DA grensesnittet? Er for øvrig relatert til forrige punkt. Hvorvidt fullmakt blir en ny hendelse eller ikke påvirker ikke beskrivelsen over annet enn at DA grensesnittet eventuelt må oppdateres.\nLagring av innhentede data Det er gjort konfigurerbart (via felles kode \u0026ndash; se 4.3 Intern implementasjon) hvorvidt man skal lagre data fra aktørene blant instansdataene etter at de er framvist for arvingen. P.t. prøver man først å hente friske data når arvingen åpner app\u0026rsquo;en. Dataene lagres samtidig. Hvis man ikke får tak i data og det ligger data på instansen fra før, vises disse.\nIntern implementasjon De fleste grensesnittene har Swagger spesifikasjoner. Der dette ikke finnes lager vi Swagger manuelt. Det benyttes standard mekanismer i Visual Studio for å importere Swagger definisjonene og generere klientkode \u0026ndash; «Connected Services».\nMotparten til den genererte koden ligger i klasser i katalogen ExternalApi. I disse klassene kalles Api, og og det blir gjort en mapping til intern domenemodell.\nHver grensesnitt er tilgjengelig fra GUI via ExternalAPIController. Kontrolleren har felles kode for alle grensesnittene for å:\nKalle grensesnitt Hente instans Lagre respons i instans Benytte lagret respons hvis gjeldende oppslag ikke returnerer data Gjøre evt mapping av fødselsnummer \u0026ndash; se 4.3 Testdata Returnere data til GUI De genererte klientene konfigureres i startup.cs. Her hentes vertsnavn fra miljøspesifikke konfigurasjonsfiler.\nListe over grensesnitt P.t. benyttes følgende grensesnitt\nAktør Eks*) Swagger Skatt Skatt avregning Skatt Skatt 2020 Skatt Skatt tilgjengelige data Kartverket x API docs SVV x Kjøretøy søk Norsk Pensjon x API docs Bank KAR x DSOP KFR API Bank konto x DSOP Konto API Geo Norge x Kommune API Geo Norge x Adresse API Landbruk API docs Ektepakt x n/a SOAP grensesnitt *) Betyr at swagger kommer fra aktør og ikke er konstruert av OED\nTestdata Det mest optimale hadde vært om man kunne definere felles testdata på tvers av alle aktører i OED. Dette er imidlertid ikke realistisk på kort sikt. Det er definert en modul for mappe avdødes fødselsnummer, som benyttes som nøkkel i nesten alle eksterne grensesnitt, til et passende fødselsnummer hos aktuell aktør.\nMappingen utføres bare når man kjører løsningen i et testmiljø. Mappingen ligger som kode i metoden MapSsn i ExternalAPIController.\nKode for å autorisere mot Maskinporten og eventuell utveksling av token fra Maskinporten til Altinn JWT ligger i Util/MaskinportenUtil.\nGrensesnitt for å hente ut data Eksterne aktører \u0026ndash; i første omgang primært Domstolene \u0026ndash; kan hente ut data via standardiserte Api fra Tjenester 3.0. Dette er beskrevet i Storage API \u0026ndash; Altinn.\nDet anbefales å benytte en hendelsesbasert innfallsvinkel til å hente ut data. Dette er beskrevet i Integration \u0026amp; Data Transport Capabilties \u0026ndash;Altinn.\nDet finnes tilgjengelige data fra hver app. Det antas at Domstolene i første omgang vil hente data fra skjema app\u0026rsquo;ene. Avdøde vil være «instance owner». Fødselsnummeret til den arvingen som fylte ut skjemaet, vil ligge som «data value» med nøkkel «ssn».\nCustom GUI for hoved app Tjenester 3.0 tilbyr p.t. ingen støtte for skreddersydde brukergrensesnitt, som man trenger i hovedapp. Det er derfor tatt utgangspunkt i en kopi av Tjenester 3.0 sin fulle klient for skjemautfylling. I denne klienten er det i noen grad fjernet komponenter som ikke er relevante for en skreddersydd klient, men det gjenstående er likevel stort og komplekst.\nKlienten - altinn-app-frontend.js - lenkes inn i fila App\\views\\Home\\Index.cshtml. I utviklingsmiljøet benyttes lokal node modul mens i prod- og testmiljøer refereres den ferdig kompilerte .js-fila fra bygg prosessen.\nOED spesifikk kode for klienten ligger hovedsakelig under mappen features/custom, der mapper og filer oppdeles logisk basert på visningstype og fagområde. Det har blitt tatt i bruk eksisterende biblioteker, basert på kopien av Tjenester 3.0 sin fulle klient og ikke lagt til nye utenom React testing library og Cypress. Disse bibliotekene blir brukt for enhetstesting, ende-til-ende testing og universell utforming tester.\nDet har blitt utviklet en del komponenter, både spesifikt tilknyttet OED design men også tilknyttet Altinn 3 Figma Designsystem ettersom Tjenester 3.0 per nå har ingen felles bibliotek som brukes av andre klienter. Det har vært mye samarbeid mellom OED og Tjenester 3.0 for å løse slik problematikk og OED har utviklet, tildelsvis med Tjenester 3.0 en rekke enkle komponenter med tilhørende design basert på Altinn 3 Designsystem. Disse ligger innunder mappen features/custom/common/inputs. Tanken har vært at disse enkle komponentene kan tas rett ut fra prosjektet og legges ut på npm for felles bruk av alle klienter. Dette har stoppet opp da det ikke har vært relevant for OED lenger å utvikle egne skjema komponenter, som nevnt innunder kapittel 2.\nRedux og React Context brukes av OED for intern state håndtering da Redux var allerede vesentlig brukt av Tjenester 3.0. I Redux ligger det mye data som kommer fra kopien av Tjenester 3.0 sin klient og Redux Store har blitt utvidet til å inneha data fra eksterne aktører, eksempelvis data fra banker, Statens Vegvesen, Norsk Pensjon og andre.\nDrift og overvåkning Før man kan gå i produksjon må det avklares hvordan løsningen kan driftes og overvåkes. Viktige momenter vil være:\nMonitorere at Tjenester 3.0 app\u0026rsquo;ene er oppe og fungerer Monitorere at batch for DA grensesnitt kjører og fungerer. Det må avklares om Altinn Forvaltning skal benyttes i denne sammenheng. Analyse av feillogger Sanering av data Utviklingsmiljø Man kan benytte et standard utviklingsmiljø for Tjenester 3.0 med følgende utvidelser:\nInstallere digdir virksomhetssertifikat for test lokalt Kopiere serialisert sertifikat inn i App/secrets.json Oppdatere passord i App/secrets.json Sertifikat og passord kan ikke inkluderes i denne dokumentasjonen.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/options/",
	"title": "options",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/org/",
	"title": "API test org",
	"tags": [],
	"description": "Når man kjører applikasjonene lokalt sammen med den lokale testplattformen kan man teste API som applikasjon eksponerer.",
	"content": "Appen har en rekke API som kan benyttes av applikasjonseier/tjenesteeier. Beskrivelsen du finner her er laget for Postman hvor det er benyttet testapplikasjonen MVA testapp.\nPostman-prosjektet kan lastes ned fra her (høyreklikk og velg \u0026ldquo;save as\u0026rdquo;).\nAutentisering av tjenesteier org I testmiljø og produksjon brukes maskinporten for å autentisere organisasjoner som eier apper.\nTestplattformen for lokal testing tilbyr et enkelt api for å autentisere organisjonen som er ansvarlig.\nMan trenger bare å oppgi tjenesteeier kode (som f.eks brg, skd osv)\nUrl: http://local.altinn.cloud/Home/GetTestOrgToken/ttd (ttd needs to be replaced with the org you want to authenticate)\nThe response is a JWT token that should be uses as a Authorization header.\nMultipart instansiering Applikasjonene støtter at man instansierer instanser til aktører. Personer eller organsiasjoner.\nUrl: http://local.altinn.cloud/ttd/mva/instances\nMetode: POST\nHeaders:\nAuthorization: Bearer + jwttoken Content-Type: multipart/form-data; boundary=\u0026ldquo;abcdefg\u0026rdquo; Eksempel Body:\n--abcdefg Content-Type: application/json; charset=utf-8 Content-Disposition: form-data; name=\u0026#34;instance\u0026#34; { \u0026#34;instanceOwner\u0026#34;: { \u0026#34;organisationNumber\u0026#34; : \u0026#34;897069650\u0026#34; } } --abcdefg Content-Type: application/xml Content-Disposition: form-data; name=\u0026#34;RF0002\u0026#34; \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;Skjema xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:xsd=\u0026#34;http://www.w3.org/2001/XMLSchema\u0026#34; skjemanummer=\u0026#34;212\u0026#34; spesifikasjonsnummer=\u0026#34;10420\u0026#34; blankettnummer=\u0026#34;RF-0002\u0026#34; tittel=\u0026#34;Alminnelig omsetningsoppgave\u0026#34; gruppeid=\u0026#34;20\u0026#34;\u0026gt; \u0026lt;GenerellInformasjon-grp-2581 gruppeid=\u0026#34;2581\u0026#34;\u0026gt; \u0026lt;Avgiftspliktig-grp-50 gruppeid=\u0026#34;50\u0026#34;\u0026gt; \u0026lt;RapporteringsenhetNavn-datadef-21771 orid=\u0026#34;21771\u0026#34;\u0026gt;DDG Fitness\u0026lt;/RapporteringsenhetNavn-datadef-21771\u0026gt; \u0026lt;RapporteringsenhetAdresse-datadef-21773 orid=\u0026#34;21773\u0026#34;\u0026gt;Sofies Gate 1\u0026lt;/RapporteringsenhetAdresse-datadef-21773\u0026gt; \u0026lt;RapporteringsenhetPostnummer-datadef-21774 orid=\u0026#34;21774\u0026#34;\u0026gt;0170\u0026lt;/RapporteringsenhetPostnummer-datadef-21774\u0026gt; \u0026lt;RapporteringsenhetPoststed-datadef-21775 orid=\u0026#34;21775\u0026#34;\u0026gt;By\u0026lt;/RapporteringsenhetPoststed-datadef-21775\u0026gt; \u0026lt;RapporteringsenhetOrganisasjonsnummer-datadef-21772 orid=\u0026#34;21772\u0026#34;\u0026gt;897069650\u0026lt;/RapporteringsenhetOrganisasjonsnummer-datadef-21772\u0026gt; \u0026lt;/Avgiftspliktig-grp-50\u0026gt; \u0026lt;/GenerellInformasjon-grp-2581\u0026gt; \u0026lt;/Skjema\u0026gt; --abcdefg-- Example Response The below response show how an instance was created for a given organization.\n1{ 2 \u0026#34;id\u0026#34;: \u0026#34;500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 3 \u0026#34;instanceOwner\u0026#34;: { 4 \u0026#34;partyId\u0026#34;: \u0026#34;500000\u0026#34;, 5 \u0026#34;personNumber\u0026#34;: null, 6 \u0026#34;organisationNumber\u0026#34;: \u0026#34;897069650\u0026#34; 7 }, 8 \u0026#34;appId\u0026#34;: \u0026#34;ttd/mva\u0026#34;, 9 \u0026#34;org\u0026#34;: \u0026#34;ttd\u0026#34;, 10 \u0026#34;selfLinks\u0026#34;: { 11 \u0026#34;apps\u0026#34;: \u0026#34;https://local.altinn.cloud/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 12 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34; 13 }, 14 \u0026#34;dueBefore\u0026#34;: null, 15 \u0026#34;visibleAfter\u0026#34;: null, 16 \u0026#34;title\u0026#34;: { 17 \u0026#34;nb\u0026#34;: \u0026#34;RF-0002\u0026#34; 18 }, 19 \u0026#34;process\u0026#34;: { 20 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6026647Z\u0026#34;, 21 \u0026#34;startEvent\u0026#34;: \u0026#34;StartEvent_1\u0026#34;, 22 \u0026#34;currentTask\u0026#34;: { 23 \u0026#34;flow\u0026#34;: 2, 24 \u0026#34;started\u0026#34;: \u0026#34;2020-01-24T06:37:48.6027116Z\u0026#34;, 25 \u0026#34;elementId\u0026#34;: \u0026#34;Task_1\u0026#34;, 26 \u0026#34;name\u0026#34;: \u0026#34;Utfylling\u0026#34;, 27 \u0026#34;altinnTaskType\u0026#34;: \u0026#34;data\u0026#34;, 28 \u0026#34;ended\u0026#34;: null, 29 \u0026#34;validated\u0026#34;: null 30 }, 31 \u0026#34;ended\u0026#34;: null, 32 \u0026#34;endEvent\u0026#34;: null 33 }, 34 \u0026#34;status\u0026#34;: null, 35 \u0026#34;appOwner\u0026#34;: { 36 \u0026#34;labels\u0026#34;: null, 37 \u0026#34;messages\u0026#34;: null, 38 \u0026#34;canBeDeletedAfter\u0026#34;: null 39 }, 40 \u0026#34;data\u0026#34;: [ 41 { 42 \u0026#34;id\u0026#34;: \u0026#34;54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 43 \u0026#34;instanceGuid\u0026#34;: \u0026#34;b4a42747-882f-47fa-bcd3-94029fdbc918\u0026#34;, 44 \u0026#34;dataType\u0026#34;: \u0026#34;RF0002\u0026#34;, 45 \u0026#34;filename\u0026#34;: null, 46 \u0026#34;contentType\u0026#34;: \u0026#34;application/xml\u0026#34;, 47 \u0026#34;blobStoragePath\u0026#34;: \u0026#34;ttd/mva/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 48 \u0026#34;selfLinks\u0026#34;: { 49 \u0026#34;apps\u0026#34;: \u0026#34;https://local.altinn.cloud/ttd/mva/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34;, 50 \u0026#34;platform\u0026#34;: \u0026#34;https://localhost:5101/storage/api/v1/instances/500000/b4a42747-882f-47fa-bcd3-94029fdbc918/data/54d868aa-5bc9-47fb-9525-67ba4c2e595c\u0026#34; 51 }, 52 \u0026#34;size\u0026#34;: 1009, 53 \u0026#34;locked\u0026#34;: false, 54 \u0026#34;refs\u0026#34;: [], 55 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 56 \u0026#34;createdBy\u0026#34;: null, 57 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.641997Z\u0026#34;, 58 \u0026#34;lastChangedBy\u0026#34;: null 59 } 60 ], 61 \u0026#34;created\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 62 \u0026#34;createdBy\u0026#34;: null, 63 \u0026#34;lastChanged\u0026#34;: \u0026#34;2020-01-24T06:37:48.6068671Z\u0026#34;, 64 \u0026#34;lastChangedBy\u0026#34;: null 65} "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_altinn/altinn_roles_persons/",
	"title": "Altinnroller brukt av personer",
	"tags": [],
	"description": "Denne siden beskriver hvilke Altinn roller som kan benyttes for å gi en bruker tilgang til en applikasjon på vegne av en person",
	"content": "Følgende roller finnes i dag for personer\nBegrenset signeringsrettighet Beskrivelse: Tilgang til å signere utvalgte skjema og tjenester\nKan delegeres: ja\nEnergi, miljø og klima Beskrivelse: Tilgang til tjenester relatert til energi, miljø og klima\nKan delegeres: ja\nKommunale tjenester Beskrivelse: Rolle for kommunale tjenester\nKan delegeres: ja\nLønn og personalmedarbeider Beskrivelse: Denne rollen gir rettighet til lønns- og personalrelaterte tjenester.\nKan delegeres: ja\nPatent, varemerke og design Beskrivelse: Denne rollen gir rettighet til tjenester relatert til patent, varemerke og design.\nKan delegeres: ja\nPlan- og byggesak Beskrivelse: Rollen er forbeholdt skjemaer og tjenester som er godkjent av Direktoratet for byggkvalitet (DiBK).\nKan delegeres: ja\nPost/arkiv Beskrivelse: Denne rollen gir rettighet til å lese meldinger som blir sendt til brukerens meldingsboks.\nKan delegeres: ja\nPrimærnæring og næringsmiddel Beskrivelse: Denne rollen gir rettighet til tjenester innen import, foredling, produksjon og/eller salg av primærnæringsprodukter og andre næringsmiddel, samt dyrehold, akvakultur, planter og kosmetikk.\nKan delegeres: ja\nPrivatperson begrensede rettigheter Beskrivelse: Denne rollen gir mulighet til å benytte tjenester på vegne av en annen privatperson.\nKan delegeres: ja\nRegnskapsmedarbeider Beskrivelse: Denne rollen gir rettighet til regnskapsrelaterte skjema og tjenester.\nKan delegeres: ja\nSamferdsel Beskrivelse: Rollen gir rettighet til tjenester relatert til samferdsel. For eksempel tjenester fra Statens Vegvesen, Sjøfartsdirektoratet og Luftfartstilsynet.\nKan delegeres: ja\nSkatteforhold for privatpersoner Beskrivelse: Tillatelsen gjelder alle opplysninger vedrørende dine eller ditt enkeltpersonsforetaks skatteforhold. Ved regelverksendringer eller innføring av nye digitale tjenester kan Skatteetaten endre i tillatelsen.\nKan delegeres: ja\nUtfyller/innsender Beskrivelse: Denne rollen gir rettighet til utvalgte skjema og tjenester.\nKan delegeres: ja\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/platform/",
	"title": "platform",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/platform/",
	"title": "Platform",
	"tags": [],
	"description": "DevOps teamet Platform jobber hovedsaklig med Altinn 3 sine platform applikasjoner og drift av disse.",
	"content": "Ansvarsområder Platform teamet har ansvar for de fleste felles tjenestene for Altinn 3. Dette inkluderer videreutvikling, retting av feil og mangler, infrastruktur og tilgjengelighet.\nRepository\nEvents Applikasjonen Events og tilhørende funksjoner i Azure gir Altinn 3 en mekanisme for å publisere og abonnere på hendelser.\nRepository\nPdf Applikasjonen Pdf kan benyttes til å generere PDF dokumenter av Altinn 3 skjema.\nRepository\nProfile Applikasjonen Profile gir Altinn 3 tilgang til profilinformasjon på brukere i Altinn.\nRepository\nReceipt Applikasjonen Receipt er et system for å vise en kvittering på at et skjema er fylt ut og ferdistilt.\nRepository\nRegister Applikasjonen Register gir Altinn 3 tilgang til registerinformasjon på personer og virksomheter som opererer i Norge.\nRepository\nStorage Applikasjonen Storage gir en app i Altinn 3 et sted å lagre data som blir samlet inn, og metadata om tilstanden til skjema under utfylling.\nSBLBridge Applikasjonen SBLBridge er Altinn 3 sin proxy inn mot Altinn 2 systemet.\nAnnen infrastruktur Teamet har også ansvar for alle applikasjonseierspesifikke Kubernetes cluster, og Dev-Test-Lab miljøet ai-dev med alle utviklermaskiner.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/policy/",
	"title": "policy",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/prefill/",
	"title": "prefill",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/presentations/",
	"title": "Presentasjoner og Altinn kaffe",
	"tags": [],
	"description": "The Altinn-kaffe meeting series is a low threshold meeting series, where app owners (and potential app owners) can learn more about what we&#39;re doing in Altinn 3. It&#39;s also designed to gather information on how Altinn can help app owners realise their Altinn 3 potential. Slides mainly in Norwegian.",
	"content": "Introduksjonspresentasjon og utbredelsesstrategimøte Det første møtet var en lengre introduksjon til plattformen og målene med den.\nAltinn 3 - hva og hvorfor? Vi holdt et møte for at man skulle kunne gi input på Altinn 3 utbredelsesstrategi 28. januar 2021. Disse presentasjonene ble vist.\nOverordnet Strategi og tiltak Kort status fra Team Tjenestestøtte Vi har også lagd en mer generell presntasjon om hva Altinn Studio / Altinn 3 er, og hvordan man kommer i gang\nGenerell Presentasjon og Kom i Gang Status og planer Annenhver uke presenterer vi hva vi har gjort og hva vi planlegger å gjøre den neste to-ukersperioden.\nStatus og planer - 30. september 2020 Status og planer - 14. oktober 2020 Status og planer - 28. oktober 2020 Status og planer - 11. november 2020 Status og planer - 25. november 2020 Status og planer - 9. desember 2020 Status og planer - 6. januar 2021 Status og planer - 20. januar 2021 Status og planer - 3. februar 2021 Status og planer - 17. februar 2021 Status og planer - 3. mars 2021 Status og planer - 17. mars 2021 Status og planer - 14. april 2021 Status og planer - 28. april 2021 Status og planer - 12. mai 2021 Status og planer - 26. mai 2021 Status og planer - 9. juni 2021 Status og planer - 23. juni 2021 Status og planer - 26. august 2021 Status og planer - 9. september 2021 Status og planer - 23. september 2021 Status og planer - 7. oktober 2021 Status og planer - 21. oktober 2021 Status og planer - 3. november 2021 Status og planer - 18. november 2021 Status og planer - 2. desember 2021 Det kommer mer\u0026hellip; Temamøter Ukene vi ikke presenterer status, har vi temamøter. Hvis det ikke ligger noen presentasjon, hadde vi sannsynligvis livedemo eller gjennomgang av dokumentasjon.\nHvordan komme i gang med Altinn 3? (7. oktober 2020) Altinns presentasjon | SSBs presentasjon Integrasjon med mottakssystem (21. oktober 2020) Hvordan bidra til et bedre Altinn 3? (4. november 2020) Signering i Altinn 3 (18. november 2020) Kalkulering i Altinn 3 (16. desember 2020) Hvordan bruke første halvtimen i Altinn Studio (27. januar 2021) Datamodellering i Altinn Studio (24. februar 2021) Lanserte tjenester (10. mars 2021) Arbeidstilsynets presentasjon | Presentasjon for Kartverket Planer for utvikling i Q2 2021 (7. april 2021) Tilgang til logger og hemmeligheter (21. april 2021) Altinn Events - inkludert mulighet for push (5. mai 2021) Datamodellering: Håndtering av utfasing av Seres (19. mai 2021) Case: Karantenehotellunntak (2. juni 2021) Standardisering vs. fleksibilitet (30. juni 2021) Kopiering av app (2. september 2021) Framtida for meldingstjenester (29. november 2021) Det kommer mer\u0026hellip; NDC 2020 Dette er et foredrag som ble holdt 11. juni 2020 på NDC Oslo, der tre av utviklerne våre presenterer Altinn 3 like etter produksjonssetting.\nForedraget er på engelsk, men er tekstet på både engelsk og norsk.\nSlides brukt under presentasjonen (pptx) Behind the scenes Fagprat med Digitaliseringsdirektoratet "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/process/",
	"title": "process",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/prosess/",
	"title": "prosess",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/rules/",
	"title": "Regelbibliotek",
	"tags": [],
	"description": "Bibliotek av autorisasjonsregler som kan brukes i en app. Husk å bytte ut tags ([ORG], [APP], [RULE_ID]) med din egen data.",
	"content": "[ORG] kan instansiere [ORG]/[APP] [ORG_1] og [ORG_2] kan her være like eller ulike. I tilfellet at de er ulike vil [ORG_1] tilsvare applikasjonseieren og [ORG_2] være en annen organisasjon som får lov til å instansiere.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG_2] can instantiate an instance of [ORG_1]/[APP]\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_2]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG_1]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;instantiate\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA can lese instanser av [ORG]/[APP] som er i Task_1 Ved å endre på rolle og task i denne regelen vil du kunne gi rettigheter til å lese instansdata på en gitt task i prosessflyten.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instances of [ORG]/[APP] when it is in Task_1\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_1\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan skrive til en instans av [ORG]/[APP] uavhengig av prosessflyt Denne regelen kan brukes dersom applikasjonseier skal kunne oppdatere instanser uavhengig av hvor de er i prosessflyten sin.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can write to instances of [ORG]/[APP] in any task or event\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;write\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rollen REGNA eller DAGL kan bekrefte instanser av [ORG]/[APP] som er i Task_2 Denne reglen begrenser rettigheten til å bekrefte en instans i en bestemt task til kun to roller. Ved å enten modifisere task eller roller vil du her kunne sette regler for hvem som får bekrefte instansen i ulike faser av prosessen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA or DAGL can confirm instances of [ORG]/[APP] when it is in Task_2\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;DAGL\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;Task_2\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:task\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;confirm\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Bruker med rolle REGNA kan lese instanser av [ORG]/[APP] som er i EndEvent_1 Denne regler tillatter en bruker med den gitte rollen å lese instansdata etter at prosessen er avsluttet. Dette vil bl.a. inkludere å laste ned vedlegg og kvitteringer knyttet til instansen.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;User with role REGNA can read instanes of [ORG]/[APP] when it is in EndEvent_1\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:3.0:function:string-equal-ignore-case\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;REGNA\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:rolecode\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;read\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; Regel som definerer at [ORG] kan fullføre en instans av [ORG]/[APP] som har en fullført prosess. Denne regelen tillatter applikasjonseier å utføre en kvittering på at de er ferdig med en instans. Instansen må ha en fullført process.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;Rule that defines that [ORG] can complete an instance of [ORG]/[APP] which state is at the end event.\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;EndEvent_1\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:end-event\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;complete\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan slette en instans av [ORG]/[APP] uavhengig av hvor den er i prosessen Denne regelen tillatter applikasjonseier å slette en instans. Dette kan gjøres uavhengig av hvor i prosessen instansen er.\n\u0026lt;xacml:Rule RuleId=\u0026#34;urn:altinn:example:ruleid:[RULE_ID]\u0026#34; Effect=\u0026#34;Permit\u0026#34;\u0026gt; \u0026lt;xacml:Description\u0026gt;[ORG] can delete an instance of [ORG]/[APP] in any task or event.\u0026lt;/xacml:Description\u0026gt; \u0026lt;xacml:Target\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:1.0:subject-category:access-subject\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[ORG]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:org\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;[APP]\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:altinn:app\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:resource\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;xacml:AnyOf\u0026gt; \u0026lt;xacml:AllOf\u0026gt; \u0026lt;xacml:Match MatchId=\u0026#34;urn:oasis:names:tc:xacml:1.0:function:string-equal\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34;\u0026gt;delete\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;xacml:AttributeDesignator AttributeId=\u0026#34;urn:oasis:names:tc:xacml:1.0:action:action-id\u0026#34; Category=\u0026#34;urn:oasis:names:tc:xacml:3.0:attribute-category:action\u0026#34; DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#string\u0026#34; MustBePresent=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;/xacml:Match\u0026gt; \u0026lt;/xacml:AllOf\u0026gt; \u0026lt;/xacml:AnyOf\u0026gt; \u0026lt;/xacml:Target\u0026gt; \u0026lt;/xacml:Rule\u0026gt; [ORG] kan aksesserere med autentiseringsnivå 3 \u0026lt;xacml:ObligationExpressions\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel1\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation1-assignment1\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;4\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;xacml:ObligationExpression FulfillOn=\u0026#34;Permit\u0026#34; ObligationId=\u0026#34;urn:altinn:obligation:authenticationLevel2\u0026#34;\u0026gt; \u0026lt;xacml:AttributeAssignmentExpression AttributeId=\u0026#34;urn:altinn:obligation2-assignment2\u0026#34; Category=\u0026#34;urn:altinn:minimum-authenticationlevel-org\u0026#34;\u0026gt; \u0026lt;xacml:AttributeValue DataType=\u0026#34;http://www.w3.org/2001/XMLSchema#integer\u0026#34;\u0026gt;3\u0026lt;/xacml:AttributeValue\u0026gt; \u0026lt;/xacml:AttributeAssignmentExpression\u0026gt; \u0026lt;/xacml:ObligationExpression\u0026gt; \u0026lt;/xacml:ObligationExpressions\u0026gt; "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/register/",
	"title": "register",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/repeterende-grupper/",
	"title": "repeterende grupper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/roadmapprocess/",
	"title": "Roadmap prosess",
	"tags": [],
	"description": "Hvordan jobber vi med vår roadmap",
	"content": "Dette dokumentet beskriver hvordan vi jobber med features for Altinn 3 plattformen.\nArtifakter Arbeidet med Altinn 3 krever en del artifakter.\nFullscreen\nFeature request En feature request er en forespørsel om ønsket funksjonalitet i Altinn 3 plattformen. Den opprettes enten av eksterne som bruker plattformen, eller av andre som har identifsert et behov.\nFeature request opprettes i de forsjellige produkt eller team backloggene.\nAltinn Studio App Template Dotnet App Frontend React Altinn Platform Altinn Authorization Altinn Authentication Altinn Notifications Altinn Storage Altinn Profile Altinn PDF Altinn Events En del av disse vil ha bakgrunn fra Altinn Apps backloggen hvor man finner backlog for apper som utvikles.\nEksempler\nRemoving data from the stored receipt Behov for alternativ visning av repeterende gruppe Product epic Kilden til denne er typisk en feature request. Denne vil inneholde detaljert beskrivelse av feature samt referer til underoppgaver som f.eks\nFunksjonelle beskrivelser og tekniske analyser User Experience og Interaction design hensyn Juridiske vurderinger Sikkerhets vurderinger Kostnad/finansierings betraktninger (Oversikt over hvilke apper som har dette behovet?) Det er produkteierne som i utgangspunktet eier denne, men får hjelp av teamarkitekter, utviklere, jurister og andre som trengs for å spesifisere disse Denne featuren epic vil ligge i produktbackloggen hvor den mest naturlig hører hjemme. Det vil være naturlig at man itererer over denne mange ganger i product planing, før den er klar til product refinement.\nEksempel 1 - funksjonel signering\nAnsvarlig: Produkteiere Analyse issues Analyse issue er github issues som typisk er lenket til product epic. Dette vil være premissgiveres vurderinger til videre realisering av epicen.\nDette kan altså f.eks være\nUser Experience og Interaction design hensyn Juridiske vurderinger Sikkerhets vurderinger Kostnad/finansierings betraktninger Aktører\nAnsvarlig: Produkteiere Utførende: Diverse premissgivere Eksempel\nUX Analyse tabell Development issue Dette er detaljerte oppgaver som er knyttet til epic og kan være analyse oppgaver eller rene implementasjonsoppgave. Issue tilknyttet en produkt feature epic trenger ikke å ligge i samme backlog som epic. Disse tas inn i sprinter som del av sprint planning\nAnsvarlig: Devops team Utførende: Devops team Roadmap feature Denne beskriver overordnet hvilken funksjonalitet feature dekker og egenskapene ved funksjonaliteten. Formålet er at eksterne interessenter skal kunne lese denne uten å lese noe annet for å få en god forståelse hvilken funksjonalitet en slik feature dekker og når den kommer.\nDenne opprettes av produkteierene. Vanligvis basert på product epics, etter at den er nødvendig analysert og kan tas inn i roadmap. Roadmap features finnes i Roadmap repository. Vi ønsker å legge oss på detaljnivået til Github Roadmap for roadmap features\nAnsvarlig: Produkteier Utførene: Produkteier Prosess Følgende prosess følges med artifakten\nFullscreen\nProduct planing Dette er arbeidet som produkteierne utfører, sammen med andre ressurser, for å skape og jobbe med epics i produkt backloggen og tilhørende analyse issues. En oppsummering av et slikt element vil kunne ende opp som et road map feature.\nAnsvarlig: Produkteier Støtte: Forretningsutviklere, Arkitekter, UX, Jurister, Sikkerhet, Forretning, Leverandørstyrere, samt andre produkteiere. Product refinement Dette er en behandling med utgangspunkt i produkt epics med hensikt om å definere underliggende development issues. Altså gjøre klart for sprintplaning, eventuelt sende det tilbake til produkt planing.\nMålet med feature refinement er å detaljere issue til et nivå at team kan ta oppgavene inn i sprinter.\nViktige teknologi valg må være analysert Bør være mulig å identifisere oppgaver å dele opp i egne issues Være detaljert nok til at man kan si noe om omfang. Sprint planing DevOps teamet tar inn development issues i en (eller flere) sprinter basert på kapasitet.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/",
	"title": "Roller som benyttes i Altinn",
	"tags": [],
	"description": "Denne siden inneholder informajson om hvilke typer roller Altinn har som kan brukes til å gi tilgang til en applikasjon",
	"content": "En rolle er en type fullmakt en bruker har på vegne av aktøren som bruker skal opptre på vegne av. Roller kan gis til personer eller virksomheter. Disse identifiseres med fødselsnummer (fra Folkeregisteret) eller organisasjonsnummer (fra Enhetsregisteret). Det finnes to hovedtyper av roller som man kan knytte en autorisasjonsregel til: Eksterne roller og Altinn roller.\nEksterne roller Informasjon om eksterne roller hentes fra ulike offentlige og autorative register. Fullmakten som disse rollene gir er regulert gjennom lover og forskrifter som legitimerer at en rolleinnehaver automatisk skal gis tilgang til bestemte tjenester eller data på vegne av aktør. Det er ansvarlig etat som sammen med Altinns forvaltning som bestemmer hvilke fullmakter det er naturlig at en ekstern rolle får i Altinn.\nEksterne roller for en aktør kan bare endres av den ansvarlige virksomheten som eier det autorative registeret. Altinn benytter roller fra følgende autorative register:\nRoller fra Enhetsregisteret Disse rollene benyttes når aktøren er en virksomhet. Du kan lese mer om hvilke roller fra Enhetsregisteret som benyttes i Altinn her\nRoller fra Skatteeaten Disse rollene benyttes når aktøren er en virksomhet eller person Du kan lese mer om hvilke roller fra Skatteetaten som benyttes her\nRoller fra Arbeidsgiver- og arbeidstakerregisteret Dette er ikke implmentert i dag men ligger i backlogg som ny kilde til eksterne roller\nRoller om Vergemål fra Statens sivilrettsforvaltning Dette er ikke implmentert i dag men ligger i backlogg som ny kilde til eksterne roller\nRoller om Foreldreansvar Dette er ikke implmentert i dag men ligger i backlogg som ny kilde til eksterne roller\nRoller fra Advokatregisteret hos Tilsynsrådet for Advokater Dette er ikke implmentert i dag men ligger i backlogg som ny kilde til eksterne roller\nAltinn roller Disse rollene benyttes når aktøren er en virksomhet eller person. Altinn roller kan (i motsetning til eksterne roller) administres og endres via Altinn Profile av administrator for aktøren.\nDu kan lese mer om hvilke roller fra Skatteetaten som benyttes her\nAPI for rolleinformasjon Det finnes et API for å slå opp informasjon om aller roller som er registrert i Altinn 2. Dokumentasjon av API finnes her under overskriften \u0026ldquo;Hente metadata om rolledefinisjoner i Altinn\u0026rdquo;. APIet er åpen to tilgjengelig for alle på lenken https://www.altinn.no/api/metadata/roledefinitions.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/scenarios/",
	"title": "Scenarier",
	"tags": [],
	"description": "Forskjellige API-bruksscenarier.",
	"content": "\rAutentisering\rHvordan autentisere ved å bruke APIene.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_ske/",
	"title": "Roller from Skatteetaten",
	"tags": [],
	"description": "Denne siden forklarer rollene fra Skatteetaten som kan benyttes til å gi tilgang til en applikasjon.",
	"content": "Indre selskap Skatteetaten leser inn såkalte \u0026ldquo;Indre selskap\u0026rdquo; i Altinn og registrerer brukere som har roller på disse. Dette er enheter som ikke er registert i Enhetsregisteret men som har rapporteringsplikt mot Skatteetaten. Her kan du lese mer om hva indre selskap er.\nIndre selskap er identifisert med egen type id-nummer i Altinn. De har 9 siffer og starter med 4. Virksomheter fra Enhetsregisteret har også 9 siffre, men starter alltid med 8 eller 9.\nFølgende roller er registert på de Indre selskapene: REPR, DTSO, DAGL, REVI, KOMP, REGN, SAM, DTPR, FFØR, MEDL, KONT, LEDE, NEST, INNH, BEST\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/apitests/user/",
	"title": "API bruk som sluttbruker",
	"tags": ["todo"],
	"description": "Når man kjører applikasjonen lokalt så kan man teste API beregnet for sluttbruker.",
	"content": "TODO\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/roadmap/studio/enduser/",
	"title": "Sluttbrukerfunksjonalitet i Altinn 3",
	"tags": [],
	"description": "Dette er funksjonaliteten for applikasjonseiere i Altinn 3, og noen av de større planene framover.",
	"content": "Lansert funksjonalitet For informasjon om hvordan man bruker funksjonalitetene som er beskrevet her, se brukerdokumentasjonen for Altinn Studio.\nSkjemafunksjonalitet Støtte for innsendingstjenester. Et utvalg standardkomponenter å bygge med (eks. tekstfelt, radioknapp, sjekkliste, datovelger, vedlegg, repeterende gruppe av komponenter), inkludert sidestilling av elementer (støtte for grid). Støtte for at skjemaet består av flere sider, men sluttbruker kan kun navigere framover/bakover mellom sidene (styrt navigasjon). Alle skjema og elementer har standardisert look and feel.\nStøtte for å sette opp ulike regler, herunder kalkulering, validering og dynamikk på både element- og sidenivå (dvs. styre hva som vises ut fra hva bruker fyller inn i skjemaet.)\nElementene kobles med tekster og knyttes til datamodell. Mulighet til å koble på API-er som datakilder, samt å forhåndsutfylle med data fra Altinns kopier av Folkeregisteret og Enhetsregisteret.\nVi støtter også innsynstjenester (rene oppslagstjenester) (#1328) ✔️\nArbeidsflyt i applikasjonen Du kan kombinere flere ulike steg i den rekkefølgen som er relevant for tjenesten:\nUtfylling/melding (data) - eksponering av data fra tjenesteeier og/eller innhenting av data fra sluttbruker Bekreftelse (confirm) - bruker skal bekrefte at dette er dataene de ønsker å sende inn Vente på tilbakemelding (feedback) - prosessen er ikke fullført, men det er andre enn bruker (tjenesteeier eller tredjepart) som skal gjøre noe I tillegg har alle en sluttstatus for at instanser er arkivert/fullført.\nAutentisering og autorisasjon Det er støtte for å definere hvilke(n) rolle(r) som har tilgang til ulike operasjoner per steg i arbeidsflyten. Rollene kan enten være Altinn-roller, roller fra Enhetsregisteret eller at tjenesteeier selv har tilgang.\nIntegrasjon med meldingsboksen i Altinn Instanser av tjenester ligger i brukers meldingsboks på samme måte som i Altinn 2. Det er mulig å finne instansene ved bruk av søk (men med enkelte begrensninger).\nDu kan bruke presentasjonsfelter for å skille instanser av samme app fra hverandre (Q2 2021) (#594) ✔️\nTjenesteeier har selv mulighet til å angi hvilken status som er relevant for den enkelte instans. Det er også mulig å definere opp at instanser av en app aldri skal legges i brukers arkiv.\nIntegrasjon med sluttbrukersystemer Tjenestene har standardiserte API-er som kan benyttes for innsending fra tredjepartssystemer. Hver app har sine egne endepunkter. Autentisering av bruker skjer med ID-porten.\nKommende funksjonalitet Altinn 3 er i stadig videreutvikling, og funksjonalitet lanseres løpende. Backlogg revideres åtte ganger i året, og mindre endringer kan også forekomme mellom revisjonene. Generelt kan man si at jo lenger frem i tid leveranse er planlagt jo mer usikkert er angitt leveransetidspunkt.\nEndringer beskrevet i kursiv er å regne som på idéstadiet, og er ikke besluttet at skal utvikles. Lenker i parentes er til beskrivelser i vår åpne backlog på Github.\nSkjemafunksjonalitet Det skal være mulig å definere opp brukergrensesnitt som passer godt til den enkelte tjenestens behov. Eksempler på kommende funksjonaliteter:\nFriere navigering mellom sider (Q4 2021) (#5893) Utfyllbare tabeller (Q4 2021) (#378) Mulighet for å endre språk inne i applikasjonen (Q1 2022) (#2055). Denne endringen gjør det også mulig å tilby tjenester på andre språk enn bokmål/nynorsk/engelsk. Ulike «tema» for brukergrensesnittet i portalen (#2115) Arbeidsflyt i applikasjonen Vi vil utvide biblioteket med tilgjengelige arbeidsflytsteg for å dekke stadig flere bruksområder. Eksempler på kommende funksjonaliteter:\nFunksjonell signering (Q4 2021) (#5540) Teknisk signering (Q1 2022) Komplekse signeringsregler - f.eks. basert på hva som fylles ut i skjemaet og parallellsignering (x av y personer skal signere) (Q2 2022) (#1324) / (#1325) Betaling (Q3 2022) (#1320) Friere navigering mellom stegene i prosessen (Q4 2021) (#2743) Innhenting av samtykke Autentisering og autorisasjon Vi skal tilby minst samme fleksibilitet for brukerne til å styre hvem som har tilgang til Altinn 3-tjenestene som finnes i Altinn II. Det innebærer f.eks. følgende endringer:\nStøtte for delegering på app-nivå (Q4 2021) (#2731) Støtte for delegering på instansnivå (Q4 2021) (#2732) Tilgang til app med virksomhetsbruker (#3743) Whitelisting av aktuelle brukere for en app (#5547) Hendelsesstyrte tjenester For å bygge sammenhengende tjenestekjeder, uten at man må bygge kompleks orkestrering, er det nødvendig at en tjeneste skal kunne \u0026ldquo;reagere\u0026rdquo; på hendelser i en annen app, eller på eksterne hendelser. Å legge til rette for denne måten å lage tjenestekjeder ligger i planene for andre halvår 2022.\nVarslinger (e-post og sms) Å sende ut varsler på e-post og/eller sms er en viktig del av flere tjenester. Inntil videre vil Altinn 3 bruke varslingsfunksjonaliteten i Altinn II.\nDet skal være mulig å koble varslingene til ulike hendelser i appene (Q1 2022) (#4275) Sluttbruker selv skal kunne sende e-post av kvitteringen (Q3 2022) (#1902) Integrasjon med meldingsboksen i Altinn Det skal være lett å finne riktig instans av en tjeneste i meldingsboksen. For å få til dette legger vi til:\nStøtte for å lage ny instans med utgangspunkt i en eksisterende - lag ny kopi (Q2 2021) (#1566) Sjekk av om man allerede har en instans av app i meldingsboks, slik at man får velge mellom ny instans eller fortsette på eksisterende (Q2 2021) (#1811) Mulighet for å søke i innholdet i instansene (#5450) "
},
{
	"uri": "https://docs.altinn.studio/nb/tags/solution/",
	"title": "solution",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/sporvalg/",
	"title": "sporvalg",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/api/storage/",
	"title": "Storage API",
	"tags": [],
	"description": "Beskrivelse av API&#39;et til Storage komponenten i Altinn 3 platformen.",
	"content": "\rInstanser\rPlatform API for instanser.\nInstance events\rPlattform API for å jobbe med instans-hendelser.\nOpenAPI (swagger) for Storage\r"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/storage-interfaces/",
	"title": "Storage Interface endringslogg",
	"tags": [],
	"description": "Oversikt over endringer introdusert i Altinn.Platform.Storage.Interface NuGet package.",
	"content": "\rv3\rOversikt over endringer introdusert i v3 av Altinn.Platform.Storage.Interface.\nv2\rOversikt over endringer som ble introdusert i v2 av Altinn.Platform.Storage.Interface.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/api/studio/",
	"title": "Altinn Studio Repository API",
	"tags": [],
	"description": "OpenAPI (swagger) spesifikasjon for Altinn Studio.",
	"content": "Se https://altinn.studio/repos/api/swagger\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/studio/",
	"title": "Studio",
	"tags": [],
	"description": "Team Studio jobber hovedsaklig produkter relatert til bygging og utvikling av Altinn 3 applikasjoner.",
	"content": "Ansvarsområder Studio teamet har ansvar for følgende Altinn 3 produkter:\nStudio Designer Altinn App Frontend Template (backend for Frontend) Dette inkluderer videreutvikling, retting av feil og mangler, dokumentasjon, build og release pipelines, infrastruktur og tilgjengelighet og selvfølgelig sørge for at det kjører som det skal i produksjon.\nAltinn Studio Altinn Studio\nKubernetes Wrapper]\nAltinn App Frontend\nAppTemplate\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/swagger/",
	"title": "swagger",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/community/devops/teams/",
	"title": "Teams",
	"tags": [],
	"description": "Våre DevOps-teams",
	"content": "\rApps\rTeam Apps sitt hovedansvar er å assistere tjenesteeiere i migrering av tjenester fra Altinn 2 og utvikling av nye tjenester på Altinn 3.\nAutorisasjon\rAutorisasjon DevOps team har hovedsaklig ansvar for løsninger som leverer Autentisering og Autorisasjonsfunksjonalitet i Altinn 2 og Altinn 3 løsningen\nPlatform\rDevOps teamet Platform jobber hovedsaklig med Altinn 3 sine platform applikasjoner og drift av disse.\nStudio\rTeam Studio jobber hovedsaklig produkter relatert til bygging og utvikling av Altinn 3 applikasjoner.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/test/",
	"title": "test",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/testing/local/testusers/",
	"title": "Testbrukere lokalt",
	"tags": [],
	"description": "Vi har definert et lite sett med testbrukere som er tilgjengelig for lokal test.",
	"content": "Disse kan man velge når man logger inn i lokal test.\nSophie Salt Sophie er en svært driftig dame som bor i Oslo. Hun har startet en kjede med treningsententer som heter DDG Fitness og til nå er det startet 3 underenheter i Oslo, Bergen og Trondheim. Sophie har rollen DAGL og dens underroller for DDG Fitness AS og dens underhenheter.\nI tilegg er hun ekspert på helse og har startet eget konsulentfirma for helsetjenester. Sophie har rollen LEDE + knyttede roller for EAS Health Consulting.\nHun er også styremedlem i borettslaget der hun bor. \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;. Sophie har rollen MEDL + knyttede roller for \u0026ldquo;Oslos Vakreste Borettslag\u0026rdquo;.\nAvgivere Avgiver Roller 01039012345 Sophie Salt Privatperson 897069650 DDG Fitness AS Daglig leder + knytninger 897069651 DDG Fitness Bergen Daglig leder + knytninger 897069652 DDG Fitness Oslo Daglig leder + knytninger 897069653 DDG Fitness Trondheim Daglig leder + knytninger 897069631 EAS Health Consulting Styreleder + knytninger 950474084 Oslos Vakreste Borettslag Styremedlem + knytninger Ola Nordmann. Ola Nordmann er en privatperson som kun kan representere seg selv. Er bosatt på Stokmarknes.\nAvgivere 01017512345 Ola Nordmann "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/test_authorization_application/",
	"title": "Test av autorisasjonsregler",
	"tags": [],
	"description": "Testing av autorisasjonsregler er viktig før produksjonssetting for å verifisere at valgte regler fungerer etter intensjon og gir en sikker og brukervennlig opplevelse",
	"content": "Feil i autoriasjonsregler eller valg av ikke passende rolle for et eller flere arbeidstrinn kan i verste fall føre til at urettmessige brukere får tilgang til data de ikke skal ha. Dette kan få alvorlige konsekvenser for aktør og vil være å betrakte som en sikkerhetsbrudd.\rHva må testes? Ved testing er det viktig å gjennomføre både positive og negative tester, dvs at man verifiserer at ønskede brukere får tilgang og at andre IKKE får tilgang.\nNedenfor har vi laget en liste over testsituasjoner som applikasjonsutvikler bør lage testscenario på og verifisere. Vi anbefaler at man automatiserer disse testene på samme måte som annen app-testing.\nVerifisèr at at ønskede eksterne roller får utført de ulike trinnene i prosessen og får tilgang til nødvendig data for å utføre dette Verifisèr at andre eksterne roller IKKE får utført de ulike trinnene i prosessen og får tilgang til nødvendig data for å utføre dette Verifisèr at brukere som får delegert altinn-roller knyttet til applikasjonen får utført de ulike trinnene i prosessen og får tilgang til nødvendig data for å utføre dette Verifisèr at applikasjonen finnes i listen av delegerbare tjenester og at det er mulig å bare delegere tilgang til applikasjonen uten rolledelegering, se her Verifisèr at bruker med for lavt sikkerhetsnivå ikke får tilgang uten å heve sikkerhetsnivå på innlogging Dokumentasjon av manuell testing For å sikre tilstrekkelig kvalitet på test av autorisasjonsregler er det nødvendig med en systematisk tilnærming og dokumenterer testing ved å ha detaljerte test-skript. Ved evt feil under testing eller senere er det viktig at man har god kontroll på hvilke brukere og akøtører som ble brukt og hvilke trinn i arbeidsprosessen som ble verifisert.\nTestdata Det er mulig å benytte testdata fra Tenor i Altinn for å finne brukere med riktige roller for riktige aktører.\nNoen ganger kan det være utfordrende å finne til testdata som dekker ønskede testscenario avhengig av hvilke type aktører som benyttes (f eks bestemte organisasjonsformer) eller at man har tatt i bruk \u0026ldquo;uvanlige\u0026rdquo; eksterne roller. Ta kontakt med Altinn hvis du ikke finner passende testdata så kan vi lese inn testbrukere og -aktører tilpasset ditt behov.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/texts/",
	"title": "texts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/launched-apps/digdir/be-om-api-nokkel/",
	"title": "Bestill tilgang til REST API",
	"tags": ["app"],
	"description": "Dokumentasjon av appen for å bestille API-nøkler for bruk i Altinn.",
	"content": "TODO: Dokumentasjon, screenshots, etc\nInfo Repo Kjørende tjeneste "
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/process/customize/",
	"title": "Tilpasse visninger av steg",
	"tags": [],
	"description": "Hvordan tilpasse visninger i forskjellige steg av en prosess.",
	"content": "En applikasjon vil ha en prosess som brukeren av applikasjonen vil følge. Avhengig av hvilken type steg brukeren er i, vil forskjellige ting vises. Denne siden vil forklare hvordan visningen til de forskjellige stegene kan tilpasses.\nData (tilsvarer utfyllingssteg i Altinn II) I denne prosess-task-typen vises skjema som kan fylles ut.\nSkjema kan redigeres ved bruk av UI editoren eller ved å endre FormLayout.json direkte.\nBekreftelse (Confirmation) I denne prosess-task-typen vises noen standard-tekster, og bruker kan velge å bekrefte for å gå videre.\nTekstene kan overstyres, ved at man legger inn tekstnøkkel som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nOverstyre tekster Tekst nr. (se bilde over) Tekstnøkkel 1 confirm.title 2 confirm.sender 3 confirm.body 4 confirm.answers 5 confirm.attachments 6 confirm.button_text Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;confirm.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Vennligst bekreft at du ønsker å sende inn\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Du må kun trykke send inn om du er helt sikker på at du vil sende inn. \u0026lt;br/\u0026gt;\u0026lt;br/\u0026gt;I det du trykker send inn kan du ikke gjøre endringer.\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.attachments\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Dokumenter med opplysninger\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;confirm.button_text\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Lagre og fortsett\u0026#34; } Merk at i eksempelet over har vi brukt html-taggen \u0026lt;br/\u0026gt; for å lage linjeskift. For lenke og utheving, benytt markdown.\nDette resulterer i følgende visning:\nCustom form layout For bekreftelsessteget har man som apputvikler muligheten til å definere et eget layout set med tilhørende form layout filer og andre konfigurasjonsfiler som hører til data-steget.\nDette gjør det mulig å helt fritt styre innholdet på bekreftelsessiden, og man kan bruke komponentene man ellers har tilgjengelig i Altinn Studio.\nSiden bekreftelsessteget ikke er ment brukt når man skal skrive data, anbefaler vi å bruke statiske komponenter (header, paragraph) og sette komponenter utover dette som readOnly.\nEksempel oppsett av layout-sets.json hvor Task_1 er et datasteg, og Task_2 et bekreftelsesteg.\n{ \u0026#34;sets\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_1\u0026#34; ] }, { \u0026#34;id\u0026#34;: \u0026#34;custom-confirmation\u0026#34;, \u0026#34;dataType\u0026#34;: \u0026#34;simple\u0026#34;, \u0026#34;tasks\u0026#34;: [ \u0026#34;Task_2\u0026#34; ] } ] } Legg merke til at konfigurasjonen for settet til Task_2 referer til data typen til Task_1.\nEksempel formLayout.json som presenterer data som brukeren fylte ut i data-steget.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;paragraph\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;paragraph\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;name.label\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Felt1\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: true }, { \u0026#34;id\u0026#34;: \u0026#34;lastname\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;lastName.label\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Felt2\u0026#34; }, \u0026#34;required\u0026#34;: true, \u0026#34;readOnly\u0026#34;: true } ] } } Dette vil gi følgende app-struktur:\n├───App │ ├───config │ ├───logic │ ├───models | | ... │ ├───ui │ │ ├───custom-confirmation │ │ │ └───layouts | | | └─── ... │ │ └───simple │ │ └───layouts | | | └─── ... Sluttresultatet i appen:\nFor et komplett oppsett av denne muligheten kan du se vår eksempel applikasjon.\nTilbakemelding (Feedback) Dette er et prosesssteg hvor applikasjonseier vil sjekke utfylte data for å generere en tilbakemelding før alle data kan arkiveres.\nTekstene på siden kan overstyres ved at man legger inn tekstnøkler som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nOverstyre tekster Tekst nr. (se bilde over) Tekstnøkkel 1 feedback.title 2 feedback.body Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;feedback.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Vent på at tjenesteeier sjekker data\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;feedback.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Når tjenesteier har sjekket at alle data er godkjent vil du bli automatisk sendt videre til siste steg i prosessen.\u0026#34; } Kvittering (Receipt) I denne prosess-task-typen er prosessen ferdig og noen standardtekster vises.\nTekstene kan overstyres, ved at man legger inn tekstnøkkel som hører til hver tekst i språkfilene for appen. Info om hvordan dette gjøres finner du her. Se under for oversikt over de forskjellige tekstnøklene som kan overstyres.\nOverstyre tekster Tekst nr. (se bilde over) Tekstnøkkel 1 receipt.receipt 2 receipt.title 3 receipt.subtitle 4 receipt.body 5 receipt.title_submitted Eksempel på overstyrte tekster i filen resources.nb.json:\n{ \u0026#34;id\u0026#34;: \u0026#34;receipt.receipt\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Søknad om flytting til Sogndal kommune\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;receipt.title\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Takk, søknaden er sendt!\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;receipt.subtitle\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Finn kopi av dine svar i Altinn Innboks\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;receipt.body\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Saksbehandling av denne type søknader tar vanligvis opp til 4 uker. Du vil bli varslet når svaret er klart i din innboks.\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;receipt.title_submitted\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Last ned PDF med dine svar:\u0026#34; } Merk at dersom du endrer verdien til tekst-nøkkelen receipt.subtitle vil lenken uansett peke til Altinn Inboks.\nDette resulterer i følgende visning:\nCustom form layout Dette er en midlertidig fremgangsmåte for å fleksibelt bygge kvitteringssiden på samme måte som andre skjemasider. Når støtte for layout-sets blir tilgjengelig i Altinn Studio vil tilpasning av kvittering skje på tilsvarende måte som for bekreftelsessiden.\rEn egendefinert kvitteringsside kan nå lages på samme måte som alle andre skjemasider. Funksjonaliteten vil også innen kort tid bli tilgjengelig i Altinn Studio.\nBygg layoutfilen på vanlig måte og referer til navnet på denne layoutfilen i settings.json med nøkkelen receiptLayoutName. Se eksempelet under for en layout med filnavnet kvittering.json.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layoutSettings.schema.v1.json\u0026#34;, \u0026#34;pages\u0026#34;: { \u0026#34;order\u0026#34;: [ \u0026#34;side1\u0026#34;, \u0026#34;side2\u0026#34;, \u0026#34;side3\u0026#34; ] }, \u0026#34;receiptLayoutName\u0026#34;: \u0026#34;kvittering\u0026#34; } Eksempel på en egendefinert layoutfil for kvittering:\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;ReceiptHeader\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;receipt.title\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;size\u0026#34;: \u0026#34;h2\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;fa796d12-49fc-457a-9d9a-d153998d55de\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Image\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Bilde\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;image\u0026#34;: { \u0026#34;src\u0026#34;: { \u0026#34;nb\u0026#34;: \u0026#34;https://docs.altinn.studio/app/app-dev-course/modul2/kommune-logo.png\u0026#34; }, \u0026#34;width\u0026#34;: \u0026#34;100%\u0026#34;, \u0026#34;align\u0026#34;: \u0026#34;flex-start\u0026#34; }, \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 2 } }, { \u0026#34;id\u0026#34;: \u0026#34;ReceiptParagraph\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Paragraph\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;receipt.body\u0026#34; }, \u0026#34;grid\u0026#34;: { \u0026#34;xs\u0026#34;: 10 } }, { \u0026#34;id\u0026#34;: \u0026#34;ReceiptInstanceInformation\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;InstanceInformation\u0026#34;, \u0026#34;elements\u0026#34;:{ \u0026#34;dateSent\u0026#34;: false } }, { \u0026#34;id\u0026#34;: \u0026#34;ReceiptHeader\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Header\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;receipt.title_submitted\u0026#34; }, \u0026#34;size\u0026#34;: \u0026#34;h4\u0026#34; }, { \u0026#34;id\u0026#34;: \u0026#34;ReceiptAttachmentList\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;AttachmentList\u0026#34;, \u0026#34;dataTypeIds\u0026#34;: [\u0026#34;ref-data-as-pdf\u0026#34;], \u0026#34;includePDF\u0026#34;: true } ] } } Sluttresultatet i appen:\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/todo/",
	"title": "todo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/training/",
	"title": "training",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/translate-to-english/",
	"title": "translate-to-english",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/tags/translate-to-norwegian/",
	"title": "translate-to-norwegian",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/getting-started/navigation/designer/ui-editor/",
	"title": "UI editor",
	"tags": [],
	"description": "Hvordan bygge et skjema med UI editor i Altinn Studio.",
	"content": "Bygge et skjema ved bruk av UI editor UI Editor er tilgjengelig i fanen Lage når man er inne i en app i Altinn Studio.\nBruke skjemakomponenter Skjemakomponentene kan trekkes inn i arbeidsområdet (i midten) fra menyen til venstre. Man kan deretter endre rekkefølgen på dem ved hjelp av drag and drop i arbeidsområdet.\nNår du holder muspekeren over en komponent, eller når du velger den ved å klikke på den, blir to ikoner synlig - et søppelbøtte-ikon for å slette komponenten, og et blyant-ikon for å endre på egenskapene til komponenten.\nSe oversikten over skjemakomponenter for mer detaljer om komponentene som er tilgjengelig.\nRedigere egenskapene til komponentene Hver komponent har et sett med egenskaper som kan redigeres, for eksempel kobling til tekster og kobling til datamodell osv. For å endre på egenskapene, klikk blyant-ikonet som vises når du holder musepekeren over komponenten du vil endre på.\nGjør deretter endringene du ønsker, og lagre dem ved å klikke på hake-ikonet til høyre for egenskapsredigeringen. Du kan forkaste endringene ved å klikke på kryss-ikonet.\nMERK: UI-editoren og kompoentene er under utvikling. Det vil derfor være perioder der ikke alle egenskaper kan settes i UI-editor.\r"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/expressions/",
	"title": "Dynamiske uttrykk",
	"tags": ["dynamics"],
	"description": "Oversikt over dynamiske uttrykk definert i JSON",
	"content": "\r⚠️ Dynamikk er et område under aktiv utvikling. Denne funksjonaliteten er ikke tilgjengelig for konfigurasjon direkte i Altinn Studio enda, og må derfor skrives manuelt i JSON-filene.\nIntroduksjon Dynamikk via uttrykk gjør det mulig å definere enkel dynamisk oppførsel i en Altinn 3 app, som for eksempel ved å definere om et skjemafelt skal vises eller skjules, om feltet skal være påkrevd eller skrivebeskyttet.\nUttrykkene er tilgjengelige i alle Altinn 3-apper som bruker frontend-versjon 3.54.0 eller nyere. Bruker man denne versjonen (eller siste hovedversjon) har man mulighet til å benytte dynamiske uttrykk til flere bruksområder.\nFra versjon 7.2.0 av nuget-pakkene er også uttrykkene støttet i backend. Det gjør at serveren vil kunne evaluere uttrykkene og fjerne data som potensielt er lagret i instansen og er knyttet til felter/komponenter som i ettertid er skjult. Disse dataene kan da fjernes fra datamodellen når instansen sendes inn. Merk at dette bare gjelder data i datamodellen som er knyttet til skjulte komponenter - data i datamodellen som ikke er knyttet til komponenter (og dermed implisitt skjult for brukeren) vil ikke fjernes automatisk.\nDet gjør det også mulig å unnlate å sende inn data som ellers er tilknyttet påkrevde felter - dersom disse påkrevde feltene er skjult i skjemaet ved hjelp av dynamiske uttrykk. Dette gjelder også ved innsending direkte fra API.\nNB: Automatisk fjerning av skjult data må foreløpig aktiveres manuelt (opt-in) ved at man legger til følgende linje i App/appsettings.json etter at man har oppgradert nuget-pakkene til 7.2.0 eller nyere:\n\u0026#34;AppSettings\u0026#34;: { \u0026#34;OpenIdWellKnownEndpoint\u0026#34;: \u0026#34;http://localhost:5101/authentication/api/v1/openid/\u0026#34;, \u0026#34;RuntimeCookieName\u0026#34;: \u0026#34;AltinnStudioRuntime\u0026#34;, \u0026#34;RegisterEventsWithEventsComponent\u0026#34;: false, \u0026#34;RemoveHiddenDataPreview\u0026#34;: true }, Oppbygging og syntaks Uttrykkene er bygget opp som et slags mini-programmeringsspråk, hvor alt er definert i JSON. Selve uttrykkene er alltid en liste (array) med verdier, hvor den første verdien i hver liste alltid er et funksjonsnavn. Resten av verdiene sendes som inndata/argumenter til funksjonen.\n[\u0026#34;equals\u0026#34;, \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;] I eksempelet over blir strengene \u0026ldquo;foo\u0026rdquo; og \u0026ldquo;bar\u0026rdquo; sammenlignet. De er ulike, så resultatet av dette uttrykket blir en boolsk verdi; false.\nDenne funksjonen, equals, forventer å få inn to strenger som inndata/argumenter. Det er også mulig å gi den andre uttrykk. Gjør man dette vil uttrykket bli tolket slik at de innerste funksjonene blir kjørt først, og de ytterste kjørt sist.\n[\u0026#34;equals\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;firstName\u0026#34;], \u0026#34;John\u0026#34;] I dette eksempelet blir det innerste uttrykket/funksjonskallet [\u0026quot;component\u0026quot;, \u0026quot;firstName\u0026quot;] kjørt først. Om verdien til komponenten \u0026ldquo;firstName\u0026rdquo; er lik strengen \u0026ldquo;John\u0026rdquo;, gir funksjonen resultatet den boolske verdien \u0026ldquo;true\u0026rdquo;.\nDersom man da bruker dette uttrykket for hidden-egenskapen til en komponent, vil komponenten bli skjult dersom man skriver inn \u0026ldquo;John\u0026rdquo; i \u0026ldquo;firstName\u0026rdquo;-komponenten et annet sted i applikasjonen:\n{ \u0026#34;id\u0026#34;: \u0026#34;lastName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;hidden\u0026#34;: [\u0026#34;equals\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;firstName\u0026#34;], \u0026#34;John\u0026#34;] } Det er ingen begrensninger rundt hvor store/dype uttrykkene kan være. Som en øvelse, se om du klarer å lese hva dette uttrykket gjør, og hvilke mulige verdier det kan returnere:\n[ \u0026#34;if\u0026#34;, [\u0026#34;greaterThanEq\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;age\u0026#34;], 16], [ \u0026#34;if\u0026#34;, [\u0026#34;lessThan\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;age\u0026#34;], 62], \u0026#34;Please consider applying for our open position!\u0026#34;, \u0026#34;else\u0026#34;, [\u0026#34;concat\u0026#34;, \u0026#34;At \u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;age\u0026#34;], \u0026#34;, you are eligible for retirement\u0026#34;] ], \u0026#34;else\u0026#34;, [\u0026#34;concat\u0026#34;, \u0026#34;At \u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;age\u0026#34;], \u0026#34;, you should stay in (pre)school\u0026#34;] ] Vis/skjul innhold\rRøpealarm: Klikk her for en tolkning av uttrykket over\rUttrykket sjekker verdien til en tenkt komponent med ID \u0026ldquo;alder\u0026rdquo;. Dersom personen er 16 år eller mer, for eksempel 45 år gammel, returneres teksten:\nPlease consider applying for our open position!\nFor en person som er 62 år returneres teksten:\nAt 62, your are eligible for retirement\nOg for en person som er 15 år (eller yngre, som f.eks. en 4-åring), returneres teksten:\nAt 4, you should stay in (pre)school\nBruksområder Dynamiske uttrykk er foreløpig tilgjengelig for bruk i disse egenskapene, som definert i layout-filer.\nKomponenter Egenskap Forventet verdi Frontend Backend Sider/layouts hidden Boolsk ✅ ✅ Alle hidden Boolsk ✅ ✅ Skjemakomponenter required Boolsk ✅ ✅ Skjemakomponenter readOnly Boolsk ✅ ❌ Repeterende grupper edit.addButton Boolsk ✅ ❌ Repeterende grupper edit.saveButton Boolsk ✅ ❌ Repeterende grupper edit.deleteButton Boolsk ✅ ❌ Repeterende grupper edit.saveAndNextButton Boolsk ✅ ❌ Alle textResourceBindings.[textResourceBinding] * Streng ✅ ❌ * = Hvilke verdier man kan overstyre med textResourceBindings varierer fra komponent til komponent, men vil fungere på alle steder der det brukes. TextResourceBindigs for repeterende grupper finner du her\nVis/skjul innhold\rEksempel: Styre redigeringsknapp-tekst i repeterende gruppe\rHer endrer vi teksten til redigeringsknappen i en repeterende gruppe basert på om IsPrefill er satt til true i en gitt adresse i datamodellen. Dersom IsPrefill er true for en adresse, vil raden som viser frem den adressen ha en redigerings-knapp med teksten \u0026quot;View\u0026quot;. Hvis IsPrefill er false blir teksten på knappen til den spesifikke raden \u0026quot;Edit\u0026quot;.\nDet er verdt å merke seg at dersom et oppslag på IsPrefill gir resultatet null(ikke funnet) så konverteres resultatet til false når det blir brukt i en if. Les mer detaljert om dette i seksjonene if og datatyper\n{ \u0026#34;id\u0026#34;: \u0026#34;repeatingAddressGroup\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;field-id-one\u0026#34;, \u0026#34;field-id-two\u0026#34;, ], \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Citizen.FormerAdresses\u0026#34; }, \u0026#34;maxCount\u0026#34;: 10, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;edit_button_open\u0026#34;: [ \u0026#34;if\u0026#34;, [ \u0026#34;dataModel\u0026#34;, \u0026#34;Citizen.FormerAdresses.IsPrefill\u0026#34; ], \u0026#34;View\u0026#34;, \u0026#34;else\u0026#34;, \u0026#34;Edit\u0026#34; ] } } Testing, feilsøking og utvikling av uttrykk Når man skal skrive et uttrykk er det greit å vite noenlunde hva resultatet kommer til å bli, og om uttrykket er gyldig. Ugyldige uttrykk gir en advarsel i JavaScript-konsollet i nettleseren når siden lastes, så det kan være lurt å ha dette konsollet åpent når man utvikler en applikasjon og tester uttrykkene lokalt.\nDet er også mulig å teste ut kjøring av et uttrykk rett i nettleserens JavaScript-konsoll. Det gjøres ved å bruke funksjonen evalExpression(). Som første parameter tar den inn et hvilket som helst uttrykk, og resultatet skrives tilbake til konsollet:\nUttrykk vil også kunne oppføre seg annerledes alt etter hvilken komponent de evalueres i nærheten av. Som et valgfritt andre parameter kan du også sende inn ID-en til en komponent som skal brukes som kontekst når uttrykket evalueres. Hvis du er usikker på hvilke komponenter og IDer som er tilgjengelige på siden du ser på i applikasjonen, kan du prøve å sende inn en tom streng eller ugyldig komponent-ID som andre parameter, så vil du få tips til hvilke ID-er du kan bruke.\nVis/skjul innhold\rEksempel på ID-er og evaluering i repterende grupper\rNB: Her beskrives noen implementasjonsdetaljer i app-frontend-react, og er kun relevant når du skal prøve et uttrykk i JavaScript-konsollet som er avhengig av en kjent posisjon i en repeterende gruppe. Dette kan endres i fremtiden, og slike endringer vil ikke påvirke uttrykk som man har definert i en applikasjon. Der hentes konteksten ut fra hvor uttrykket er definert i layout-filen.\nSe for deg en repeterende gruppe for personer med to felt; navn og alder. Gitt dette uttrykket:\n[\u0026quot;component\u0026quot;, \u0026quot;alder\u0026quot;]\nHva vil alderen være? Det vil være kunne variere etter hvilken gruppe som evaluerer uttrykket. Har man har to grupper/rader vil både navn- og alder-komponentene finnes to ganger hver. Disse vil få ID-ene navn-0 og alder-0 (for den første raden) og navn-1 og alder-1 (for den andre raden). Du kan lete etter den nærmeste alder-komponenten (den som tilhører samme gruppe/rad som navn-komponenten) ved å spesifisere en mer nøyaktig ID i tilfeller der uttrykk evalueres i repeterende gruppe.\nTenk deg at følgende data er fyllt inn i en repeterende gruppe:\nNavn Komponent-ID Alder Komponent-ID Per navn-0 24 alder-0 Kari navn-1 36 alder-1 Ola navn-2 18 alder-2 evalExpression([\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;]); // Eksempel 1 evalExpression([\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;], \u0026#34;navn\u0026#34;); // Eksempel 2 evalExpression([\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;], \u0026#34;navn-0\u0026#34;); // Eksempel 3 evalExpression([\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;], \u0026#34;navn-1\u0026#34;); // Eksempel 4 Denne vil finne \u0026ldquo;første og beste\u0026rdquo; alder-komponent, og finner dermed alder-0. Den returnerer derfor 24, Per sin alder. Denne prøver å evaluere uttrykket i kontekst av den første navn-komponenten den finner, som er navn-0. Den nærmeste alder-komponenten til navn-0 er alder-0, og dermed vår vi igjen 24, Per sin alder. Her prøver vi å lete i kontekst av navn-komponenten på første rad, og igjen finner vi 24, Per sin alder. I siste eksempel har vi spesifisert andre rad i den repeterende gruppen ved å evaluere i kontekst av navn-1. Her finner vi den nærmeste alder-komponenten alder-1, som er 36, Kari sin alder. Funksjoner Disse funksjonene er tilgjengelige for bruk i uttrykk:\nFunksjonsnavn Parametre Returverdi Frontend Backend equals Streng, Streng Boolsk ✅ ✅ notEquals Streng, Streng Boolsk ✅ ✅ not Boolsk Boolsk ✅ ✅ greaterThan Tall, Tall Boolsk ✅ ✅ greaterThanEq Tall, Tall Boolsk ✅ ✅ lessThan Tall, Tall Boolsk ✅ ✅ lessThanEq Tall, Tall Boolsk ✅ ✅ concat Ingen eller flere strenger Streng ✅ ✅ and En eller flere boolske verdier Boolsk ✅ ✅ or En eller flere boolske verdier Boolsk ✅ ✅ if Se detaljert beskrivelse Se detaljert beskrivelse ✅ ✅ instanceContext Streng Streng ✅ ✅ frontendSettings Streng Streng ✅ ✅ dataModel Streng Streng ✅ ✅ component Streng Streng ✅ ✅ Detaljerte beskrivelser og eksempler\nVis/skjul innhold\requals / notEquals\rDisse to funksjonene sammenligner to strenger for å sjekke om de er like (equals) eller ulike (notEquals). Om du sender inn andre verdier enn strenger, blir verdiene konvertert og sammenlignet som strenger (les mer om konvertering her).\nEksempler:\n{ \u0026#34;id\u0026#34;: \u0026#34;lastName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, ... \u0026#34;hidden\u0026#34;: [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Model.FirstName\u0026#34;], \u0026#34;John\u0026#34; ], \u0026#34;readOnly\u0026#34;: [\u0026#34;notEquals\u0026#34;, [\u0026#34;frontendSettings\u0026#34;, \u0026#34;FormIsEditable\u0026#34;], true ] } notEquals er i prinsippet det samme som, og en snarvei til, [\u0026quot;not\u0026quot;, [\u0026quot;equals\u0026quot;, ...]].\nSe også tips og triks under Streng eller mindre streng sammenligning?\nVis/skjul innhold\rnot\rDenne funksjonen tar inn en boolsk verdi eller noe som kan konverteres til en boolsk verdi, og returnerer den motsatte boolske verdien. Sann blir til usann, usann blir til sann.\nFunksjonen kan være nyttig om du ønsker å snu et uttrykk. Istedenfor å tenke at du skal skrive et uttrykk som skjuler en komponent gitt noen forutsetninger, kan du pakke uttrykket inn i not og skrive uttrykket ut fra hva som skal til for å vise komponenten:\n{ \u0026#34;id\u0026#34;: \u0026#34;lastName\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;hidden\u0026#34;: [\u0026#34;not\u0026#34;, [\u0026#34;or\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;ShowLastName\u0026#34;], [\u0026#34;frontendSettings\u0026#34;, \u0026#34;ShowAllFields\u0026#34;] ] ] } Vis/skjul innhold\rgreaterThan / greaterThanEq / lessThan / lessThanEq\rDisse 4 funksjonene forventer to tall inn, og sammenligner om det første med det andre. Det vil si, for funksjonen greaterThan er uttrykket sant dersom det første tallet er større enn det andre.\nFunksjon Beskrivelse Symbol greaterThan Er det første tallet større enn det andre tallet? \u0026gt; greaterThanEq Er det første tallet større enn eller lik det andre tallet? ≥ lessThan Er det første tallet mindre enn det andre tallet? \u0026lt; lessThanEq Er det første tallet mindre enn eller lik det andre tallet? ≤ Dersom noen av argumentene til disse funksjonene er null blir resultatet false (uavhengig av om det er det første eller andre argumentet).\nEksempel som sjekker om alder er over (eller lik) 18:\n[\u0026#34;greaterThanEq\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;], 18] Vis/skjul innhold\rconcat\rDenne funksjonen tar inn 0 eller flere strenger som argumenter, og returnerer en streng hvor alle strengene i argumentene er slått sammen. Kalles funksjonen uten noen argumenter gis det en tom streng.\nLegg merke til at funksjonen ikke automatisk legger til mellomrom eller komma når den slår sammen strenger. For å gi et mer lesbart resultat anbefales det å legge inn bindetegn hvor nødvendig:\n[\u0026#34;concat\u0026#34;, \u0026#34;Gratulerer med \u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;alder\u0026#34;], \u0026#34;-årsdagen!\u0026#34; ] Uttrykket over gir teksten Gratulerer med 18-årsdagen! dersom verdien i alder-komponenten var 18.\nI concat-funksjonen tolkes null-verdier som tomme strenger. Boolske verdier skrives ut som strengene \u0026quot;true\u0026quot; og \u0026quot;false\u0026quot;.\nVis/skjul innhold\rand / or\rFunksjonene and og or forventer 1 eller flere boolske verdier, og gir et resultat ut fra om henholdsvis alle eller minst en av verdiene var sanne (true).\nFunksjon Beskrivelse and Er alle argumentene sanne? (true) or Er minst ett av argumentene sanne? (true) Gir man null-verdier tolkes disse som usann (false). Eksempler på bruk finnes under Streng eller mindre streng sammenligning?\nVis/skjul innhold\rif\rif-funksjonen kan brukes for å forgrene et uttrykk slik at returverdien styres av resultatet av et annet boolsk uttrykk. Funksjonen kan kalles på to forskjellige måter; med 2 eller 4 argumenter:\nArgument Alternativ 1 Alternativ 2 Første argument Boolsk Boolsk Andre argument Vilkårlig type Vilkårlig type Tredje argument Strengen \u0026quot;else\u0026quot; Fjerde argument Vilkårlig type I alternativ 1 vil returverdien til funksjonen bli verdien gitt som andre argument dersom første argument er sant (true). Om ikke returneres verdien null.\nI alternativ 2 vil returverdien til funksjonen bli verdien gitt som andre argument dersom første argument er sant (true). Om ikke returneres verdien gitt i fjerde argument. Man må alltid gi strengen \u0026quot;else\u0026quot; som tredje argument om man vil kalle funksjonen med 4 argumenter. Det tredje argumentet er bare til for å gjøre uttrykket mer lesbart, og har ingen funksjon ellers.\nOm man ønsker flere betingelser og mulige returverdier kan man nøste flere kall til if inne i andre eller fjerde argument:\n[\u0026#34;if\u0026#34;, [\u0026#34;greaterThan\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;birthYear\u0026#34;], 1945], \u0026#34;Du ble født etter verdenskrigene\u0026#34;, \u0026#34;else\u0026#34;, [\u0026#34;if\u0026#34;, [\u0026#34;greaterThanEq\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;birthYear\u0026#34;], 1939], \u0026#34;Du ble født under andre verdenskrig\u0026#34;, \u0026#34;else\u0026#34;, \u0026#34;Du ble født før andre verdenskrig\u0026#34; ] ] Vis/skjul innhold\rinstanceContext (oppslag)\rDenne funksjonen gjør det mulig å hente ut informasjon om gjeldende instans. Følgende nøkler kan brukes fom første argument:\nNøkkel Verdi Eksempelverdi instanceId Gjeldende instans-ID 512345/48c31ffc-dcdd-416d-8bc7-194bec3b7bf0 instanceOwnerPartyId Gjeldende aktør-ID 512345 instanceOwnerPartyType Hva slags aktør eier instansen \u0026quot;org\u0026quot;, \u0026quot;person\u0026quot;, \u0026quot;selfIdentified\u0026quot; eller \u0026quot;unknown\u0026quot; appId Den aktive appen sin ID org/app-name Alle disse oppslagene vil gi verdien null om man jobber i en tiltandsløs kontekst. Om man gir andre nøkler enn de over, vil oppslaget resultere i en feilmelding. Denne oppførselen er unik blant oppslagsfunksjonene, og gjøres for å sikre at man ikke prøver å hente informasjon som finnes i instansen men som ikke (enda) er eksponert via en nøkkel her. Gi oss en tilbakemelding om du har ønsker om å hente ut instansdata som ikke er tilgjengelig i denne funksjonen.\nOppslaget gjøres i samme datakilde som er tilgjengelig for språk/tekster.\nVis/skjul innhold\rfrontendSettings (oppslag)\rDette oppslaget gjør det mulig å hente informasjon fra en datakilde som kan styres ulikt for hvert kjøretidsmiljø.\nOppslaget gjøres i samme datakilde som er tilgjengelig for språk/tekster, og oppsettet er beskrevet i detalj der.\nMerk: Datakilden heter applicationSettings når brukt i språk/tekster, men verdiene må alltid lagres under nøkkelen FrontEndSettings i appsettings.{miljø}.json). Av den grunn har funksjonen fått navnet frontendSettings her, for å indikere at oppslag ikke kan gjøres i resten av appsettings.{miljø}.json.\nVis/skjul innhold\rdataModel (oppslag)\rDenne oppslagsfunksjonen gjør det mulig å hente verdier direkte fra gjeldende datamodell. Første og eneste argument må peke et sted i datamodellen, og bruker det samme punktum-separerte formatet som brukt i dataModelBindings. Ved bruk inne i repeterende grupper trenger man ikke bruke plassholdere for indekser til gruppen - uttrykket finner selv den relative plasseringen i kontekst av en repeterende gruppe.\nLegg merke til at oppslag bare fungerer mot datatyper som allerede er støttet i uttrykkene. Dersom man slår opp et objekt eller en liste/array i datamodellen med dataModel-funksjonen får man alltid resultatet null. Denne funksjonaliteten kan endres, da det er planlagt støtte for objekter og lister i uttrykkene i fremtiden.\nEksempel på oppslag i repeterende gruppe:\n[ { \u0026#34;id\u0026#34;: \u0026#34;ansatte\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Ansatte i selskapet\u0026#34; }, \u0026#34;maxCount\u0026#34;: 99999, \u0026#34;children\u0026#34;: [\u0026#34;ansatt-navn\u0026#34;, \u0026#34;ansatt-alder\u0026#34;], \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Ansatte\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;ansatt-navn\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Fullt navn\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Ansatte.Navn\u0026#34; }, \u0026#34;hidden\u0026#34;: [\u0026#34;lessThan\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;Ansatte.Alder\u0026#34;], 18] }, { \u0026#34;id\u0026#34;: \u0026#34;ansatt-alder\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Alder\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;Ansatte.Alder\u0026#34; } \u0026#34;hidden\u0026#34;: [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;Ansatte[0].Navn\u0026#34;], \u0026#34;Ola Nordmann\u0026#34;] } ] Følgende kan observeres:\nDet første oppslaget (for å styre hidden på komponenten ansatt-navn) styres ut fra alderen til hver ansatt. Om den ansatte er under 18 år skjules ansatt-navn. Legg merke til at samme sti i datamodellen blir brukt som simpleBinding på ansatt-alder. Det andre oppslaget (for å styre hidden på komponenten ansatt-alder) bruker [0] på oppslaget i datamodellen. Dette fungerer også, men oppførselen er kanskje uventet; her skjules alle alder-komponenter dersom navnet på den første ansatte har navnet Ola Nordmann. Vis/skjul innhold\rcomponent (oppslag)\rOppslag direkte på komponent tilsvarer på mange måter et oppslag mot datamodell med dataModel. Et uttrykk som slår opp verdien til en komponent kommer til å lete etter komponenten og returnere verdien lagret på komponenten sin simpleBinding i datamodellen. For øyeblikket støttes ingen andre verdier enn den lagret mot simpleBinding (om andre verdier ønskes må man gå direkte mot dataModel).\nOppslag mot en komponent vil derimot returnere null dersom komponenten man slår opp verdien til er skjult (selv om komponenten ellers har tilknyttet data i datamodellen). Dette gjør det til en viss grad mulig å styre visning av en komponent basert på om en annen komponent er vist eller ikke. Dersom komponenten ble funnet på en helt annen (men skjult) side gir også oppslaget verdien null selv om datamodellen har en verdi tilknyttet komponenten.\nI likhet med dataModel vil oppslag mot en komponent-id forsøke å finne komponenten i nærheten av uttrykket i kontekst av repeterende grupper. Det vil først søkes etter komponenten i gjeldende rad, før det letes oppover i sidestrukturen.\nDatatyper Funksjoner i uttrykkene har en forventning om at argumentene som blir sendt inn har en spefikk type. Dersom et argument blir sendt inn har en annen type enn forventet, blir verdien forsøkt konvertert til riktig type. Som et eksempel forventer funksjonen equals to strenger, men om du sender inn den boolske verdien true som det ene eller andre argumentet fungerer det også fint, siden den boolske verdien true blir konvertert til strengen \u0026quot;true\u0026quot;.\n[\u0026#34;equals\u0026#34;, true, \u0026#34;true\u0026#34;] Uttrykket over fungerer, og gir true som resultat (fordi true og \u0026quot;true\u0026quot; sammenlignes som samme verdi ved at true konverteres til \u0026quot;true\u0026quot; før sammenligningen). Dette gjør også at du kan kalle en funksjon som returnerer en datatype og f.eks. sammenligne med en helt annen datatype. Les mer om hvilke datatyper som kan konverteres til hva under.\nAlle funksjoner som forventer en spesifikk datatype som argument vil også kunne fungere om man sender inn null, men noen steder vil en null-verdi gi en feilmelding - for eksempel om man prøver å slå opp i datamodellen med [\u0026quot;dataModel\u0026quot;, null]. I concat-funksjonen vil derimot en null-verdi bli tolket som en tom streng.\nStrenger Strenger inneholder vilkårlig tekst, og er en bred datatype som tall og boolske verdier kan konverteres til.\nNoen strenger kan også konverteres til andre datatyper:\nStrengverdi Kan erstatte Eksempler Heltall med eller uten negativt fortegn Tall 3, -8, 71254 Flyttall med eller uten negativt fortegn, med punktum istedenfor komma Tall 3.14, -33.0, 123.123 true eller false med små eller store bokstaver Boolsk true, True, FALSE null med små eller store bokstaver Null null, Null, NULL Alle andre strenger enn de i tabellen over vil gi feilmelding om de blir forsøkt konvertert til andre typer.\nTall Tallverdier gjelder positive og negative heltall og flyttall (tall med komma). Noen strenger blir også konvertert automatisk til en tallverdi, som vist i tabellen til strenger over. For at konvertering av en streng til et tall skal fungere, må strengen oppfylle følgende:\nStrengen inneholder bare et tall, ingen annen tekst foran/bak tallet Negativt fortegn (-) kan brukes, men positivt fortegn (+) støttes ikke. Flyttall må representeres med punktum, ikke komma. Tusenskilletegn eller annen tallformattering støttes ikke. Alle andre strenger vil gi en feilmelding om de blir forsøkt konvertert til et tall. Forsøker man å konvertere en boolsk verdi til et tall, gir det også en feilmelding.\nFunksjoner som forventer å få inn et tall kan også få inn null. Se mer om hvilken effekt det har under beskrivelsen til hver funksjon.\nBoolske verdier Boolske verdier omfatter true (sann) og false (usann). Når man kaller en funksjon som forventer å få inn en boolsk verdi, kan man også sende inn enkelte andre typer, som blir konvertert til en boolsk verdi:\nTallene 1 og 0 fungerer som henholdsvis true og false Strengene \u0026quot;1\u0026quot; og \u0026quot;0\u0026quot; fungerer likt som tallene (og blir henholdsvis true og false) Strengene \u0026quot;true\u0026quot; og \u0026quot;false\u0026quot; konverteres også til en boolsk verdi Verdien null fungerer likt som false Alle andre verdier gir en feilmelding om de blir sendt til en funksjon som forventer en boolsk verdi. Legg merke til at disse reglene er litt forskjellige fra reglene til strenger. Det er dermed forskjell på hvilke verdier som kan tolkes som en boolsk verdi for en funksjon som forventer et boolsk argument - og hvilke verdier som er like en boolsk verdi. Funksjonen equals sammenligner verdier som strenger, og dermed vil tallet 1 og strengen \u0026quot;1\u0026quot; sammenlignes som like, men den vil ikke gjenkjenne 1 og true som like verdier.\nDet kan kanskje se ut som følgende uttrykk er like:\n\u0026quot;hidden\u0026quot;: [\u0026quot;dataModel\u0026quot;, \u0026quot;hideName\u0026quot;] \u0026quot;hidden\u0026quot;: [\u0026quot;equals\u0026quot;, [\u0026quot;dataModel\u0026quot;, \u0026quot;hideName\u0026quot;], true] \u0026quot;hidden\u0026quot;: [\u0026quot;if\u0026quot;, [\u0026quot;dataModel\u0026quot;, \u0026quot;hideName\u0026quot;], true, \u0026quot;else\u0026quot;, false] Hvis verdien (her gitt fra oppslaget [\u0026quot;dataModel\u0026quot;, \u0026quot;hideName\u0026quot;]) er true eller \u0026quot;true\u0026quot; vil komponenten skjules, men dersom verdien er 1 eller \u0026quot;1\u0026quot; vil komponenten bare skjules med uttrykkene i alternativ 1 og 3. Dette fordi resultatet i uttrykket for hidden konverteres til en boolsk verdi, og if forventer en boolsk verdi som første argument. Derimot vil equals sammenligne verdiene som strenger, og \u0026quot;1\u0026quot; er ikke lik \u0026quot;true\u0026quot;.\nSe også tips og triks under Streng eller mindre streng sammenligning?\nNull De fleste steder hvor man forventer å få inn en streng, tall eller boolske verdier skal også tåle en null-verdi. Null-verdier indikerer at en spesifikk verdi mangler, og det er forskjell på f.eks. en null-verdi, en tom streng og tallet 0.\nDersom man gjør et oppslag i en funksjon som dataModel, og verdien man leter etter ikke finnes/er satt, vil som regel null bli resultatet.\nTips og triks Vise/skjule hele sider Uttrykk kan brukes til å vise/skjule hele sider. I eksempelet under vil hele siden skjules dersom en komponent (på en av de andre sidene) har verdien no eller ikke er satt.\n{ \u0026#34;$schema\u0026#34;: \u0026#34;https://altinncdn.no/schemas/json/layout/layout.schema.v1.json\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;hidden\u0026#34;: [\u0026#34;or\u0026#34;, [\u0026#34;equals\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;hasComplaints\u0026#34;], \u0026#34;no\u0026#34;], [\u0026#34;equals\u0026#34;, [\u0026#34;component\u0026#34;, \u0026#34;hasComplaints\u0026#34;], null] ], \u0026#34;layout\u0026#34;: [ ... ] } } Dette kan sees på som et alternativ til sporvalg-funksjonaliteten, men i motsetning til sporvalg gjøres utregningen av disse uttrykkene i både frontend og backend, dermed er det ikke nødvendig å legge til \u0026quot;triggers\u0026quot;: [\u0026quot;calculatePageOrder\u0026quot;] for å få funksjonaliteten til å fungere.\nDersom siden man stod på blir skjult, vil applikasjonen automatisk gå videre til neste tilgjengelige side i side-rekkefølgen. Om alle de neste sidene er skjult, vises den første mulige siden i rekkefølgen istedenfor.\nStreng eller mindre streng sammenligning? Måten uttrykkene kjøres på gjør at de kan virke litt strenge (ved at f.eks. 0 og null er ulike verdier når man sammenligner med equals). Det er et designvalg gjort i Altinn av to grunner:\nStrenge regler er tydelige regler. Uttrykkene vil heller gi en feilmelding om noe ikke er som forventet, enn å la deg lure på hvorfor det ble slikt det ble. Hvis uttrykkene behandler mange ulike verdier som like, fratar vi deg muligheten til å skille mellom dem om du skulle ønske det. Om man ønsker mindre streng sammenligning, kan man f.eks. konstruere et uttrykk som bruker or-funksjonen til å gjenkjenne flere forskjellige verdier:\n[\u0026#34;or\u0026#34;, [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], 0], [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], false], [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], null], [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], \u0026#34;\u0026#34;] ] Husk også at konvertering til boolsk verdi tillater flere alternativer enn strenger (som equals forventer). Siden funksjonen or forventer boolske verdier som argumenter, og verdiene 0, false og null allerede tillates som boolske verdier vil følgende fungere likt som uttrykket over:\n[\u0026#34;or\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], [\u0026#34;equals\u0026#34;, [\u0026#34;dataModel\u0026#34;, \u0026#34;My.Path\u0026#34;], \u0026#34;\u0026#34;] ] "
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v1/",
	"title": "v1",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v1 av deployment.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i deployment i v1.1.0\nHva er nytt\rOversikt over endringer som ble introdusert i v1 av deployment.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/community/changelog/deployment/v2/",
	"title": "v2",
	"tags": [],
	"description": "Oversikt over endringer introdusert i v2 av deployment.",
	"content": "\rBreaking changes\rOversikt over breaking changes introdusert i deployment i v2.0.0\nHva er nytt\rOversikt over endringer som ble introdusert i v2 av deployment.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/tags/validering/",
	"title": "validering",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/logic/validation/",
	"title": "Validering",
	"tags": [],
	"description": "Hvordan legge til logikk for å validere skjemadata?",
	"content": "Introduksjon Valideringer sørger for at brukerens input er gyldig med tanke på datamodellen, i tillegg til alle egendefinerte regler som settes opp for applikasjonen. Valideringer kan kjøres enten på klient (dvs. browseren) eller serversiden.\nMan kan også sette opp validering til å kjøre ved sidebytte.\nKlientside-validering Dette er validering som kjøres i browseren, FØR data er sendt til server for lagring. Dette gjør det mulig å gi raske tilbakemeldinger til sluttbruker underveis i utfylling.\nKlientside-validering baserer seg på datamodellen som hører til skjemaet, og bruker denne til å bestemme hva som er gyldig input i et felt. Helt konkret brukes JSON Schema utgaven av datamodellen for valideringen. Denne genereres automatisk når man laster opp XSD. Det går an å gjøre endringer i JSON schema direkte for å tilpasse valideringen ved behov.\nMerk at dersom man gjør tilpasninger i JSON schema manuelt, for å så oppdatere XSD og laste inn på nytt, vil nytt JSON schema også genereres, og alle manuelle tilpasninger må gjøres på nytt. Derfor er det anbefalt å gjøre endringer i XSD og/eller datamodelleringsverktøyet for at disse endringene skal reflekteres i JSON schema.\nEt eksempel på hvordan et felt kan defineres i JSON schema datamodellen er:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34; } Input i dette feltet vil valideres mot begrensningene som er satt opp, og en feilmelding vil vises dersom disse ikke møtes - i dette tilfellet, dersom input er en tekst med lengde mer enn 4 karakterer.\nStandard feilmeldinger Det er satt opp standard feilmeldinger for alle valideringene som gjøres på klientsiden. Se oversikten under.\nRegel Feilmelding bokmål Feilmelding nynorsk Feilmelding engelsk min \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minste gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Minimum valid value is {0}\u0026rsquo; max \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Største gyldig verdi er {0}\u0026rsquo; \u0026lsquo;Maximum valid value is {0}\u0026rsquo; minLength \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller flere tegn\u0026rsquo; \u0026lsquo;Use {0} or more characters\u0026rsquo; maxLength \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Bruk {0} eller færre tegn\u0026rsquo; \u0026lsquo;Use {0} or fewer characters\u0026rsquo; length \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Antall tillatte tegn er {0}\u0026rsquo; \u0026lsquo;Number of characters allowed is {0}\u0026rsquo; pattern \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Feil format eller verdi\u0026rsquo; \u0026lsquo;Wrong format or value\u0026rsquo; required \u0026lsquo;Du må fylle ut {0}\u0026rsquo; \u0026lsquo;Du må fylle ut {0}\u0026rsquo; \u0026lsquo;You have to fill out {0}\u0026rsquo; enum \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Kun verdiene {0} er tillatt\u0026rsquo; \u0026lsquo;Only the values {0} are permitted\u0026rsquo; Spesielt om standard feilmelding for påkrevde felter For en smidigere brukeropplevelse vises ikke feilmeldinger for manglende utfylling av påkrevde felter under utfylling av et skjema, med mindre validering trigges på et enkeltfelt, ved lagring av en rad i en repeterende gruppe eller ved navigering til en annen side.\nFeilmeldingen for påkrevde felter er \u0026ldquo;Du må fylle ut {0}\u0026rdquo;. Her blir {0} erstattet med det feltet som feilmeldingen gjelder for. Dette gjøres på følgende måte:\nBruker feltets shortName tekst. Dette er en ny tekst som kan settes opp pr. komponent på samme måte som ledetekst (title) settes i dag. Denne teksten brukes pr nå KUN i forbindelse med feilmeldingen for påkrevde felter. Om shortName ikke er definert brukes feltets title tekst (det som er definert som ledetekst for feltet), og teksten vil bli forsøkt gjort om til en tekst med liten forbokstav (med mindre teksten ser ut som en forkortelse). I noen spesialtilfeller (Adresse-komponenten) der det er flere felter i ett brukes de standard-tekstene som er definert for feltene i komponenten. Eksempel: Felt med kun title { \u0026#34;id\u0026#34;: \u0026#34;fornavn\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tekst-fornavn\u0026#34; }, ... //osv } Og tekster i ressurs-fil:\n... { \u0026#34;id\u0026#34;: \u0026#34;tekst-fornavn\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Fornavn\u0026#34; } Da vil valideringmeldingen bli \u0026quot;Du må fylle ut Fornavn\u0026quot;.\nEksempel: Felt med shortName Dersom feltets ledetekst er lang eller ikke egner seg til bruk i valideringsmeldingen, kan man legge til en shortName tekst som brukes i stedet. Merk at dette kun gjelder for denne spesifikke valideringsmeldingen - shortName teksten er ikke i bruk ellers i løsningen pr nå.\n{ \u0026#34;id\u0026#34;: \u0026#34;fornavn\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;tekst-fornavn\u0026#34;, \u0026#34;shortName\u0026#34;: \u0026#34;fornavn-kort\u0026#34; }, ... //osv } Og tekster i ressurs-fil:\n... { \u0026#34;id\u0026#34;: \u0026#34;tekst-fornavn\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Her kan du skrive ditt fornavn\u0026#34;, }, { \u0026#34;id\u0026#34;: \u0026#34;fornavn-kort\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;fornavnet ditt\u0026#34;, } Da vil valideringmeldingen bli \u0026quot;Du må fylle ut fornavnet ditt\u0026quot;.\nEgendefinerte feilmeldinger Det er mulig å definere egne feilmeldinger som skal vises når et felt får valideringsfeil. Dette gjøres ved å legge på en parameter errorMessage der hvor feltet er definert i JSON schema. JSON schema filen ligger i mappen App/models og følger navnestandard *.schema.json.\nF.eks., man kan utvide eksempelet over:\n\u0026#34;someField\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;myCustomError\u0026#34; } Man kan skrive ønsket tekst direkte inn her, eller bruke en tekstnøkkel for en tekst definert i ressursfilene for språkstøtte.\nLegg merke til at om man har en referanse til en definisjon så må feilmeldingen ligge på property-feltet, og ikke på referansen/definisjonen. Eksempel:\n{ \u0026#34;properties\u0026#34;: { \u0026#34;person\u0026#34;: { \u0026#34;$ref\u0026#34; : \u0026#34;#/definitions/personDefinition\u0026#34;, \u0026#34;errorMessage\u0026#34;: \u0026#34;myCustomError\u0026#34;, } }, \u0026#34;definitions\u0026#34;: { \u0026#34;personDefinition\u0026#34; : { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, ... } } Merk at ved XSD-endringer, så vil ev. egendefinerte feilmeldinger forsvinne da JSON schema filen genereres på nytt fra XSD. På sikt er det tenkt at det å sette opp egendefinerte feilmeldinger skal være mulig å gjøre via datamodelleringsverktøyet i Altinn Studio. Per nå må dette gjøres manelt.\rServerside-validering Serverside-validering kan deles opp i to kategorier:\nValideringer mot datamodell - Disse kjører automatisk når brukeren prøver å sende inn skjemadata. Egendefinerte valideringer - Disse skrives av applikasjonsutvikleren, og kjører når brukeren prøver å sende inn skjemadata eller flytte prosessen til et nytt steg. Hvordan legge til egendefinert validering Egendefinerte validering kan igjen deles opp i to kategorier; task-validering og data-validering.\nTask-validering vil kjøres hver gang validering trigges enten manuelt fra applikasjonen eller når man prøver å flytte seg framover i prosessen. Data-validering vil kjøre dersom man står på et steg som har definerte dataelementer knyttet til seg. Valideringer skrives i C# og avhengig av hvilken versjon av applikasjonsmalen og Nuget pakkene du er på, så vil implementeringen variere litt. I tidligere versjon så er det en pre-definert fil med metoder du kan legge inn logikken, mens fra versjon 7 og fremover så implementerer du et grensesnitt i den klassen du selv vil. Grensesnittet er tilfeldigvis likt den pre-definerte filen. Eksemplene som refererer til metoder vil derfor være de samme for alle versjoner.\nv4, v5, v6\rValideringer legges til i ValidationHandler.cs -filen i applikasjonsmalen. Filen kan aksesseres og endres i Altinn Studio via logikkmenyen, ved å velge Rediger valideringer, eller direkte i applikasjonsrepoet der ligger filen i logic/Validation-mappen.\rv7\rI versjon 7 har vi endret måten preutfylling med egendefinert kode gjøres på. Vi benytter nå dependency injection i stedet for overstyring av metoder. Hvis du tidligere plasserte koden din i _ValidationHandler og ValidateTask metodene in ValidationHandler.cs klassen så vil du erfare at det er mer eller mindre det samme som nå gjøres.\nOpprett en klasse som implementerer IInstanceValidator grensesnittet som ligger i Altinn.App.Core.Features.Validation navnerommet.\nDu kan navngi og plassere filene i den mappestrukturen du selv ønsker i prosjektet ditt. Men vi anbefaler at du benytter meningsfulle navnerom som i et hvilket som helst annet .Net prosjekt. Registrer din implementering i Program.cs klassen services.AddTransient\u0026lt;IInstanceValidator, InstanceValidator\u0026gt;(); Dette sørger for at din kode er kjent for applikasjonen og at koden blir kjørt når den skal. Fra dette punktet og videre skal eksemplene være de samme for alle versjoner :)\nEndringer gjøres i ValidateData og ValidateTask-metodene. Førstnevnte får inn et dataobjekt og sistnevnte får inn instansen og taskId. For å legge til en valideringsfeil brukes AddModelError-metoden til validationResults object som sendes med i begge metodene.\nEt eksempel på en enkel data-validering som sjekker at feltet FirstName ikke inneholder verdien 1337, når rotelementet til modellen er Skjema er vist nedenfor:\npublic void ValidateData(object data, ModelStateDictionary validationResults) { if (data.GetType() == typeof(Skjema)) { // Cast instance data to model type Skjema model = (Skjema)data; // Get value to test - FirstName string firstName = Skjema?.Person?.FirstName; // Check if FirstName exists, and contains the value \u0026#34;1337\u0026#34; if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;)) { // Add validation error, with error message and list // of affected fields (in this case Person.FirstName) validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;Error: First name cannot contain the value \u0026#39;1337\u0026#39;.\u0026#34; ); } } } Se kommentarer i koden over for en forklaring på hva de ulike delene gjør.\nI det andre parameteret til metoden AddModelError, der det står \u0026ldquo;Error: First name cannot contain the value \u0026lsquo;1337\u0026rsquo;\u0026rdquo;, kan man bruke en tekstnøkkel for en tekst definert i ressursfilene for språkstøtte.\nEt eksempel på en enkel task-validering som sjekker hvor lang tid brukeren har brukt på Task_1 og returnerer en feil dersom det har tatt lenger enn 3 dager.\npublic async Task ValidateTask(Instance instance, string taskId, ModelStateDictionary validationResults) { if (taskId.Equals(\u0026#34;Task_1\u0026#34;)) { DateTime deadline = ((DateTime)instance.Created).AddDays(3); if (DateTime.UtcNow \u0026lt; deadline) { validationResults.AddModelError(\u0026#34;Task_1\u0026#34;, $\u0026#34;Ferdigstilling av Task_1 har tatt for lang tid. Vennligst start på nytt.\u0026#34;); } } } Enkeltfeltvalidering Dersom det er behov for umiddelbar validering av et felt som ikke kan dekkes i klientsidevalideringen, så kan man sette opp en trigger for validering på enkeltfelter i formLayout.json\nMERK: Det er foreløpig ikke støtte for å sette opp trigger for validering av enkeltfelter for Stateless apps.\r{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;3611fb2a-c06b-4fa7-a400-3f6c1ece64e1\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;25795.OppgavegiverNavnPreutfyltdatadef25795.Label\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;simpleBinding\u0026#34;: \u0026#34;etatid\u0026#34; }, \u0026#34;type\u0026#34;: \u0026#34;Input\u0026#34;, \u0026#34;triggers\u0026#34;: [\u0026#34;validation\u0026#34;] , // \u0026lt;--- Add this field }, { \u0026#34;id\u0026#34;: \u0026#34;9ec368da-d6a9-4fbd-94d0-b4dfa8891981\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Button\u0026#34;, \u0026#34;textResourceBindings\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Button\u0026#34; }, \u0026#34;dataModelBindings\u0026#34;: {}, \u0026#34;textResourceId\u0026#34;: \u0026#34;Standard.Button.Button\u0026#34;, \u0026#34;customType\u0026#34;: \u0026#34;Standard\u0026#34; } ] } } Merk at dersom du definerer at et felt skal trigge validering på serverside, så er det kun resultatet av denne valideringen som vil vises. Det vil si at dersom det er annen klient-side validering som er definert, så vil en ev. server-validering av feltet overskrive disse. Pass derfor på å implementere alle nødvendige valideringer på feltet også på server-siden, det går an å legge flere feilmeldinger på samme felt ved behov.\rKonfigurasjonen overfor vil resultere i at din egendefinerte validering i ValidationHandler.cs vil trigges hver gang feltet oppdaterer seg. Dersom du har behov for å vite hvilket felt som trigget valideringen er denne tilgjengelig i http-konteksten som en header på requesten ved navn ValidationTriggerField.\nEt eksempel på en egendefinert validering der headerverdien hentes ut er vist nedenfor.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { _httpContextAccessor.HttpContext .Request.Headers .TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues triggerValues); string triggerField = triggerValues.FirstOrDefault(string.Empty); if (triggerField.Equals(\u0026#34;kommune\u0026#34;)) { // Cast instance data to model type flyttemelding model = (flyttemelding)data; // Get value to test - Kommune string kommune = model.kommune; if (!kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError(triggerField, \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } await Task.CompletedTask; } OBS Merk at validering av enkeltfelter bør implementeres slik at det kjører både på trigger og under generell validering. Eksempelet som omhandler flere komplekse valideringer viser hvordan dette kan implementeres.\nDet er gjort flere ting for å få denne kodesnutten til å kjøre\nI ValidationHandler.cs inkluderes using Microsoft.Extensions.Primitives; øverst i filen for å kunne ta i bruk StringValues. I App.cs inkluderes using Microsoft.AspNetCore.Http; øverst i filen for å kunne ta i bruk IHttpContextAccessor. I App.cs dependency injectes IHttpContextAccessor i konstruktøren og sendes med videre til ValidationHandler. public App( IAppResources appResourcesService, ILogger\u0026lt;App\u0026gt; logger, IData dataService, IProcess processService, IPDF pdfService, IProfile profileService, IRegister registerService, IPrefill prefillService, IHttpContextAccessor httpContextAccessor // \u0026lt;--- Add this line ) : base(appResourcesService, logger, dataService, processService, pdfService, prefillService) { _logger = logger; _validationHandler = new ValidationHandler(httpContextAccessor); // \u0026lt;--- Include the new property here _calculationHandler = new CalculationHandler(); _instantiationHandler = new InstantiationHandler(profileService, registerService); } Dersom man har flere komplekse valideringer som er tidkrevende er det anbefalt å implementere flere private metoder for validering av disse og bruke ValidationTriggerField til å avgjøre hvilken private metode som skal kjøres. Man kan bl.a. bruke en switch statement for å oppnå dette.\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model) { _httpContextAccessor.HttpContext .Request.Headers .TryGetValue(\u0026#34;ValidationTriggerField\u0026#34;, out StringValues triggerValues); string triggerField = triggerValues.FirstOrDefault(string.Empty); switch (triggerField) { case \u0026#34;kommune\u0026#34;: ValidateKommune(model, validationResults); break; case \u0026#34;boaddresse\u0026#34;: ValidateBoAdresse(model, validationResults); break; default: ValidateKommune(model, validationResults); ValidateBoAdresse(model, validationResults); break; } } } private void ValidateKommune(flyttemelding model, ModelStateDictionary validationResults) { if (model.kommune != null \u0026amp;\u0026amp; !model.kommune.Equals(\u0026#34;Oslo\u0026#34;)) { validationResults.AddModelError( nameof(model.kommune), \u0026#34;Dette er ikke en gyldig kommune.\u0026#34;); } } private void ValidateBoAdresse(flyttemelding model, ModelStateDictionary validationResults) { if (model.boaddresse != null \u0026amp;\u0026amp; model.boaddresse.Length \u0026gt; 150) { validationResults.AddModelError( nameof(model.boaddresse), \u0026#34;Boadresse kan ikke være lengere enn 150 tegn.\u0026#34;); } } Spesifisere at valideringsfeil er fikset Når validering trigges av et enkelt felt, så vil alle tidligere valideringer på dette feltet fjernes i påvente av svar fra den siste valideringen. Dersom et felt trigger validering som oppdaterer/legger til feilmelding på flere felter på en gang, vil ikke disse fjernes selv om det ikke lenger er noen feil i disse feltene. Dette er fordi man ikke har noen måte å vite hvilke felter som ev. er validert ifm en enkeltfeltvalidering.\nF.eks., dersom man har 2 felter: fornavn og etternavn. Begge felter trigger enkeltfeltvalidering, og dersom begge feltene har verdi så validerer man at fullt navn ikke kan være lengre enn 50 tegn. Feilmelding settes da på begge feltene. Dersom man retter opp i dette ved å endre fornavn, vil feilmeldingen fra fornavn-feltet forsvinne, men feilmeldingen som vises på etternavn-feltet vises fortsatt selv om valideringen ikke setter noen feilmeldinger på feltene.\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } } For å kunne fjerne gamle feilmeldinger i et sånt tilfelle, er det lagt til støtte for å kunne spesifisere at en valideringsfeil er fikset. Da vil det aktuelle feltet kunne få beskjed om at en spesifikk feilmelding som den viser frem er fikset og skal skjules.\nDette gjøres ved å legge til en valideringsfeil i koden i det tilfellet der det ikke er noen feil i valideringen, og sette *FIXED* foran selve feilmeldingen. Dette tilsvarer oppsettet for myk validering. Denne prefixen gjør at feilmeldingen som settes fjernes fra det aktuelle feltet, eller ignoreres (dersom det ikke er noen feilmelding på feltet fra før).\nMan kan da utvide eksempelet over for å støtte dette:\nprivate void ValidateFullName(Datamodell model, ModelStateDictionary validationResults) { if (!string.isNullOrEmpty(model.fornavn) \u0026amp;\u0026amp; !string.isNullOrEmpty(model.etternavn) \u0026amp;\u0026amp; model.fornavn.Length + model.etternavn.Length \u0026gt; 50) { validationResults.addModelError(nameof(model.fornavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } else { validationResults.addModelError(nameof(model.fornavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); validationResults.addModelError(nameof(model.etternavn), \u0026#34;*FIXED*Fullt navn kan ikke være lengre enn 50 tegn.\u0026#34;); } } Dersom du har problemer med å få dette til å fungere, og du ser valideringsmeldinger med *FIXED* foran meldingen istedenfor at meldingen forsvinner, bør du dobbeltsjekke at du har \u0026quot;FixedValidationPrefix\u0026quot;: \u0026quot;*FIXED*\u0026quot; satt under GeneralSettings i appsettings.json.\nMyke valideringer Myke valideringer er valideringsmeldinger som ikke stopper bruker fra å sende inn eller gå videre til neste steg i prosessen, men som benyttes til å gi brukeren ulike former for informasjon. Denne typen valideringer kan f.eks. brukes til å be brukeren om å verifisere input som virker feil eller rart, men som strengt tatt ikke er ugyldig, eller gi nyttig informasjon for videre utfylling.\nMeldinger basert på myke validering vil vises en gang, men bruker kan velge å klikke seg videre uten å utføre endringer.\nMyke valideringer legges til fra server-siden i validerings-logikken, på samme måte som vanlige validerings-feil. Forskjellen er at valideringsmeldingen må prefixes med typen validering man ønker å gi, f.eks *WARNING*. Dette vil da tolkes som en myk validering. Prefixen *WARNING* blir ikke synlig for sluttbruker.\nDe tilgjengelige typene myke valideringer er WARNING, INFO og SUCCESS.\nKodeeksempel\npublic async Task ValidateData(object data, ModelStateDictionary modelState) { if (data is TestModel testModel) { string firstName = testModel?.Person?.FirstName; if (firstName != null \u0026amp;\u0026amp; firstName.Contains(\u0026#34;1337\u0026#34;)) { validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;*WARNING*Are you sure your first name contains 1337?\u0026#34;); } if (firstName != null \u0026amp;\u0026amp; firstname.Contains(\u0026#34;Altinn\u0026#34;)) { validationResults.AddModelError( \u0026#34;Person.FirstName\u0026#34;, \u0026#34;*SUCCESS*Altinn is a great name!\u0026#34;); } } await Task.CompletedTask; } Eksempler på visning av de ulike valieringene ser du nedenfor:\n)\nDet er også mulig å overstyre tittelen man ser på meldingene ved å legge til nøkklene soft_validation.info_title, soft_validation.warning_title, og soft_validation.success_title i tekstressursene om man ønsker å sette custom tittel.\nGruppevalidering Det er mulig å gjøre valideringer på en repeterende gruppe i det brukeren ønsker å lagre en gitt rad. Dette gjøres ved å legge til en trigger på gruppe-komponenten i layoutfilen (f.eks FormLayout.json). Det er to forskjellige triggere som kan brukes på grupper; validation kjører validering på hele gruppen, og validateRow kjører kun validering på raden brukeren prøver å lagre. Eksempel:\n{ \u0026#34;data\u0026#34;: { \u0026#34;layout\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;demo-gruppe\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Group\u0026#34;, \u0026#34;children\u0026#34;: [ \u0026#34;...\u0026#34; ], \u0026#34;maxCount\u0026#34;: 3, \u0026#34;dataModelBindings\u0026#34;: { \u0026#34;group\u0026#34;: \u0026#34;Endringsmelding-grp-9786.OversiktOverEndringene-grp-9788\u0026#34; }, \u0026#34;triggers\u0026#34;: [\u0026#34;validateRow\u0026#34;] // \u0026lt;--- Legg til denne }, ... ] } } Dette vil da sørge for at det vil kjøres validering på komponentene som er en del av gruppen på den aktuelle raden man jobber på. Om det finnes valideringsfeil så vil man stoppes fra å lagre gruppen før dette er rettet opp i.\nOm man legger til validering på gruppe-komponenten så vil det også gå et kall mot valideringen backend med en header som spesifiserer hvilken komponent som trigget valideringen: ComponentId. I tillegg er rad-indeksen for raden som blir lagret tilgjengelig i headeren RowIndex. Dersom gruppen er en nøstet gruppe, er verdien en komma-separert liste med indekser, ellers er indeksen ett enkelt tall. Valideringer er skrevet i C#, i ValidationHandler.cs-filen i applikasjonsmalen. I valideringen kan man så hente ut komponent-id\u0026rsquo;en og skreddersy eventuelle valideringer som skal gjøres backend, eksempel:\npublic async Task ValidateData(object data, ModelStateDictionary validationResults) { if (data is flyttemelding model) { _httpContextAccessor.HttpContext .Request.Headers .TryGetValue(\u0026#34;ComponentId\u0026#34;, out StringValues compIdValues); _httpContextAccessor.HttpContext .Request.Headers .TryGetValue(\u0026#34;RowIndex\u0026#34;, out StringValues rowIndexValues); string componentId = compIdValues.FirstOrDefault(string.Empty); switch (componentId) { case \u0026#34;top-level-group\u0026#34;: // kjør valideringer spesifikke til gruppen // Hent rad-indeksen for en ikke-nøstet gruppe int rowIndex = int .Parse(rowIndexValues.FirstOrDefault(string.Empty)); break; case \u0026#34;nested-group\u0026#34;: // Hent alle rad-indekser for en nøstet gruppe int[] rowIndices = rowIndexValues .FirstOrDefault(string.Empty) .Split(\u0026#34;,\u0026#34;, StringSplitOptions.RemoveEmptyEntries) .Select(s =\u0026gt; int.Parse(s)) .ToArray(); break; default: // kjør valideringene i sin helhet break; } } } For tips til hvordan man løser komplekse valideringer se ekemplene under enkeltfeltvalidering.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/",
	"title": "Veiledning for autorisasjonsregler",
	"tags": [],
	"description": "Autorisasjonsregler må defineres med omhu. Disse retningslinjene forteller hva applikasjonseier må vurdere før autorisasjonsregler settes for en applikasjon",
	"content": "Autorisasjonsregler defineres i henhold til XACML 3.0-standarden. Reglene vil angi hvilke betingelser som må være til stede for å gi en bestemt bruker tilgang til å utføre ett eller flere trinn i en applikasjons definerte arbeidsprosess.\nDu må vite hva du gjør! Eier av tjenesten er selv ansvarlig for å lage autorisasjonsregler og velge riktige roller som gir tilgang til beskyttet informasjon. Selv om XACML-standarden gir utvikleren stor frihet til å definere regler og velge de roller man ønsker, så må disse retningslinjene følges for å sikre at tilgang til applikasjonen er korrekt og fungerer etter hensikten.\nFor å ta de riktige valgene når du lager autorisasjonsregler for appen din trenger du en generell forståelse av hvordan Altinn Autorisasjon fungerer og hvordan den brukes til å kontrollere tilgang. På denne siden kan du lese mer om Altinn Autorisasjon.\nRoller må velges med omhu! I konfigurasjonsfil for autorisasjon brukes roller for å definere hvem som har lov til å utføre hvilke handlinger. Altinn tilbyr et sett med roller som kan brukes som betingelse for å få tilgang til et bestemt trinn i arbeidsprosessen og informasjon som vises.\nFør du velger hvilken rolle du skal bruke, må du være sikker på at du har en god forståelse av hva disse rollene betyr og hva slags tjenester og informasjon som forventes at denne rollen har tilgang til. Det er viktig at autorisasjonsregler og valg av roller samsvarer med intensjoner og forventninger som administrator for aktøren har. For eksempel forventer antagelig admnistrator at rollen \u0026ldquo;Skatt\u0026rdquo; gir tilgang til tjenester knyttet til for eksempel skatterapportering, men ikke at denne rollen gir tilgang til tjenester innen Lønn og personalområdet. På samme måte skal man være forsiktig med å bruke for eksempel rollen \u0026ldquo;Kontaktperson\u0026rdquo; fra Enhetsregisteret til å gi tilgang til tjenester med mindre man har vurdert grunnlaget for at denne får tilgang på en grundig måte.\nHvis du ikke finner en rolle du synes passer må du ta kontakt med Altinn slik at vi kan vurdere om nye roller bør opprettes.\nHer kan du lese mer om hvilke roller som finnes i Altinn.\nUnngå endringer av autorisasjonsregler etter produksjonssetting Endringer i autorisasjonsregler i etterkant av en produksjonssetting vil medføre at f eks brukere som har fått tilgang til tjenesten gjennom delegering av en rolle som tidligere var satt på tjenesten senere kanskje ikke får utført tjenesten allikevel.\nDette vil pålegge virksomheter som skal bruke tjenesten en administrasjonsbyrde fordi de da må rydde opp i delegeringer gjort med utgangspunkt i gammel policy. En slik praksis vil som regel gi misfornøyde brukere av applikasjonen.\nBe om hjelp! Som applikasjonseier må du alltid vurdere om intensjonene i beskrivelsen av rollen stemmer overens med tjenesten eller tilgangen til data som applikasjonen din gir.\nÅ gi feil personer tilgang til data de ikke burde ha er ingen god markedsføring for tjenesten din. Vi anbefaler deg derfor sterkt å kontakte Altinn for veiledning i valg av roller og oppsett av autorisasjonsregler hvis du er usikker.\rAutorisasjonsregler må testes Autorisasjonsregler må som alt annet testes før applikasjonen lanseres for å verifisere at riktige roller har tilgang til nødvendig data.\nHer kan du lese våre anbefalinger knyttet til testing av autorisasjonsregler.\nAltinn kan pålegge å endre autorisasjonsregler Selv om det er applikasjonseierens ansvar å konstruere riktig autorisasjonsregel og velge riktige roller, vil Altinn gjennomføre stikkkontroller med autorisasjonsreglene for tjenester som settes i produksjon. Hvis vi oppdager det vi anser som feil bruk av Altinn Autorisasjon så vil vi, om nødvendig, ta tjenesten ut av produksjon eller pålegge endringer i autorisasjonsregler.\n"
},
{
	"uri": "https://docs.altinn.studio/nb/app/development/configuration/authorization/guidelines_authorization/roles_and_rights/roles_altinn/altinn_roles_enterprices/",
	"title": "Altinn roller brukt av virksomheter",
	"tags": [],
	"description": "Denne siden beskriver hvilke Altinn roller som kan benyttes for å gi en bruker tilgang til en applikasjon på vegne av en virksomhet",
	"content": "Lønn og personalmedarbeider Beskrivelse: Denne rollen gir rettighet til lønns- og personalrelaterte tjenester. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nRegnskapsmedarbeider Beskrivelse: Denne rollen gir rettighet til regnskapsrelaterte skjema og tjenester. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nBegrenset signeringsrettighet Beskrivelse: Tilgang til å fylle ut og signere utvalgte skjema og tjenester, hovedsaklig innenfor økonomiske og forretningsmessige forhold. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nSamferdsel Beskrivelse: Rollen gir rettighet til tjenester relatert til samferdsel. For eksempel tjenester fra Statens Vegvesen, Sjøfartsdirektoratet og Luftfartstilsynet. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nUtfyller/Innsender Beskrivelse: Denne rollen gir rettighet til et bredt utvalg skjema og tjenester som ikke har så strenge krav til autorisasjon. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nEnergi, miljø og klima Beskrivelse: Tilgang til tjenester relatert til energi, miljø og klima. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nØkokrim rapportering Beskrivelse: Tilgang til tjenester fra Økokrim. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nPatent, varemerke og design Beskrivelse: Denne rollen gir rettighet til tjenester relatert til patent, varemerke og design. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nSignerer av Samordnet registermelding Beskrivelse: Denne rollen gir rettighet til tjenester på vegne av enheter/foretak. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nHelse-, sosial- og velferdstjenester Beskrivelse: Tilgang til helse-, sosial- og velferdsrelaterte tjenester. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nKommunale tjenester Beskrivelse: Rollen gor tilgang til kommunale tjenester. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nPrimærnæring og næringsmiddel Beskrivelse: Denne rollen gir rettighet til tjenester innen import, foredling, produksjon og/eller salg av primærnæringsprodukter og andre næringsmiddel, samt dyrehold, akvakultur, planter og kosmetikk. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nPost/arkiv Beskrivelse: Denne rollen gir rettighet til å lese meldinger som blir sendt til brukerens meldingsboks. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nPlan- og byggesak Beskrivelse: Rollen er forbeholdt skjemaer og tjenester som er godkjent av Direktoratet for byggkvalitet (DiBK). Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nTaushetsbelagt post Beskrivelse: Denne rollen gir tilgang til taushetsbelagt post fra stat og kommune. Ved regelverksendringer eller innføring av nye digitale tjenester kan det bli endringer i tilganger som rollen gir.\nRoller som utgår Roller laget i overgang mellom 2.0 og 3.0 Disse rollene skal ikke lengre benyttes for å tilgangsstyre til applikasjoner:\nAlgetestdata Beskrivelse: Havforskningsinstituttet - registrering av algetestdata\nTransportløyvegaranti Beskrivelse: Statens vegvesen - rolle som gir tilgang til app for transportløyvegarantister\nRevisorattesterer - MVA kompensasjon Beskrivelse: Denne rollen gir revisor rettighet til å attestere tjenesten Merverdiavgift - søknad om kompensasjon (RF-0009).\n"
}]